This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  api/
    achievementService.js
    analogyService.js
    apiClient.js
    apiConfig.js
    authService.js
    dailyStationService.js
    grcService.js
    leaderboardService.js
    newsletterService.js
    passwordResetService.js
    profileService.js
    ResourcesService.js
    scenarioService.js
    shopService.js
    supportService.js
    testService.js
    xploitService.js
  components/
    AchievementItem.js
    FormattedQuestion.js
    ResourceItemComponent.js
    ResourceRandomModal.js
    ResourcesCategoriesComponent.js
    TestProgressComponent.js
  constants/
    shop/
      shopConstants.js
    achievementConstants.js
    resourcesConstants.js
    supportConstants.js
    testConstants.js
  hooks/
    useAchievements.js
    useLeaderboard.js
    useResources.js
    useShop.js
    useSupport.js
    useTest.js
  navigation/
    AppNavigator.js
    AuthNavigator.js
    MainNavigator.js
    TestNavigator.js
  screens/
    auth/
      CreateUsernameScreen.js
      ForgotPasswordScreen.js
      LoginScreen.js
      RegisterScreen.js
      ResetPasswordScreen.js
    profile/
      AchievementsScreen.js
      ProfileScreen.js
      SupportScreen.js
    shop/
      components/
        AvatarItem.js
        BoostItem.js
        ColorItem.js
      ShopScreen.js
    tests/
      categories/
        APlus2Screen.js
        APlusScreen.js
        AWSCloudScreen.js
        CaspPlusScreen.js
        CisspScreen.js
        CloudPlusScreen.js
        CySAPlusScreen.js
        DataPlusScreen.js
        LinuxPlusScreen.js
        NetworkPlusScreen.js
        PenPlusScreen.js
        SecurityPlusScreen.js
        ServerPlusScreen.js
      TestListScreen.js
      TestScreen.js
    tools/
      AnalogyHubScreen.js
      DailyStationScreen.js
      GRCScreen.js
      NewsletterScreen.js
      ResourcesScreen.js
      ScenarioSphereScreen.js
      XploitCraftScreen.js
    HomeScreen.js
    LeaderboardScreen.js
  store/
    slices/
      achievementsSlice.js
      shopSlice.js
      userSlice.js
    index.js
.gitignore
App.js
app.json
index.js
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/api/achievementService.js">
// src/api/achievementService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

/**
 * Fetch all achievements
 * @returns {Promise} - Resolution of the API call
 */
export const fetchAchievements = async () => {
  try {
    const response = await apiClient.get(API.ACHIEVEMENTS);
    return response.data;
  } catch (error) {
    console.error('Achievements fetch error:', error);
    throw new Error(error.response?.data?.error || 'Failed to fetch achievements');
  }
};

/**
 * Get achievement details by ID
 * @param {string} achievementId - The achievement's ID
 * @returns {Promise} - Resolution of the API call
 */
export const getAchievementById = async (achievementId) => {
  try {
    const response = await apiClient.get(`${API.ACHIEVEMENTS}/${achievementId}`);
    return response.data;
  } catch (error) {
    console.error('Achievement details fetch error:', error);
    throw new Error(error.response?.data?.error || 'Failed to fetch achievement details');
  }
};

/**
 * Get unlocked achievements for a user
 * @param {string} userId - The user's ID
 * @returns {Promise} - Resolution of the API call
 */
export const getUserAchievements = async (userId) => {
  try {
    const response = await apiClient.get(`${API.USER.DETAILS(userId)}`);
    return response.data.achievements || [];
  } catch (error) {
    console.error('User achievements fetch error:', error);
    throw new Error(error.response?.data?.error || 'Failed to fetch user achievements');
  }
};

/**
 * Export all functions for consistent usage
 */
export default {
  fetchAchievements,
  getAchievementById,
  getUserAchievements
};
</file>

<file path="src/api/analogyService.js">
// src/api/analogyService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

export const streamAnalogy = async (analogyType, concept1, concept2 = '', concept3 = '', category = 'real-world') => {
  try {
    const response = await apiClient.post(
      API.ANALOGY.STREAM,
      {
        analogy_type: analogyType,
        concept1,
        concept2,
        concept3,
        category
      },
      {
        responseType: 'text',
        // For streaming responses
        onDownloadProgress: progressEvent => {
          const text = progressEvent.currentTarget.response;
          // You can implement a callback here to handle partial text
          // Or return a promise that resolves with chunks
        }
      }
    );
    
    return response.data;
  } catch (error) {
    console.error('Error streaming analogy:', error);
    throw error;
  }
};
</file>

<file path="src/api/apiClient.js">
// src/api/apiClient.js
import axios from 'axios';
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';

// Create an axios instance
const apiClient = axios.create({
  timeout: 30000, // 30 seconds
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  },
});

// Request interceptor to include auth info and cookies
apiClient.interceptors.request.use(
  async (config) => {
    try {
      const userId = await SecureStore.getItemAsync('userId');
      
      if (userId) {
        // For API calls that expect the userId
        if (config.method === 'post') {
          if (!config.data) {
            config.data = {};
          }
          
          // Only add userId if it's not already in the data
          if (typeof config.data === 'object' && !config.data.userId) {
            config.data.userId = userId;
          }
        }
        
        // Handle cookie-based auth for your backend
        config.withCredentials = true;
        
        // Some APIs might need userId in headers
        config.headers.userId = userId;
      }
      
      return config;
    } catch (error) {
      console.error('API interceptor error:', error);
      return config;
    }
  },
  (error) => Promise.reject(error)
);

// Add response interceptor to handle errors
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    // Handle 401 Unauthorized errors
    if (error.response && error.response.status === 401) {
      // Clear stored credentials
      await SecureStore.deleteItemAsync('userId');
      
      // You could dispatch a logout action here if needed
      // Or redirect to login screen
    }
    
    return Promise.reject(error);
  }
);

export default apiClient;
</file>

<file path="src/api/apiConfig.js">
// src/api/apiConfig.js
import Constants from 'expo-constants';

// Use different URLs based on environment
const DEV_URL = 'http://192.168.1.172:8080/api'; // Replace with your local IP - can it be localhost?
const PROD_URL = 'https://certgames.com/api';

// Determine which URL to use
const isProduction = !__DEV__;
export const BASE_URL = isProduction ? PROD_URL : DEV_URL;

export const API = {
  // Auth endpoints
  AUTH: {
    LOGIN: `${BASE_URL}/test/login`,
    REGISTER: `${BASE_URL}/test/user`,
    FORGOT_PASSWORD: `${BASE_URL}/password-reset/request-reset`,
    RESET_PASSWORD: `${BASE_URL}/password-reset/reset-password`,
    VERIFY_TOKEN: (token) => `${BASE_URL}/password-reset/verify-token/${token}`,
    OAUTH_GOOGLE: `${BASE_URL}/oauth/login/google`,
    OAUTH_APPLE: `${BASE_URL}/oauth/login/apple`,
  },
  
  RESOURCES: {
    CATEGORIES: `${BASE_URL}/resources/categories`,
    BY_CATEGORY: `${BASE_URL}/resources/category`,
    TRACK_CLICK: `${BASE_URL}/resources/track-click`,
  },
  // User endpoints
  USER: {
    DETAILS: (userId) => `${BASE_URL}/test/user/${userId}`,
    DAILY_BONUS: (userId) => `${BASE_URL}/test/user/${userId}/daily-bonus`,
    ADD_COINS: (userId) => `${BASE_URL}/test/user/${userId}/add-coins`,
    ADD_XP: (userId) => `${BASE_URL}/test/user/${userId}/add-xp`,
    CHANGE_USERNAME: `${BASE_URL}/test/user/change-username`,
    CHANGE_EMAIL: `${BASE_URL}/test/user/change-email`,
    CHANGE_PASSWORD: `${BASE_URL}/test/user/change-password`,
  },
  
  // Test endpoints
  TESTS: {
    // No LIST endpoint - we generate test objects programmatically in testService.js
    DETAILS: (category, testId) => `${BASE_URL}/test/tests/${category}/${testId}`,
    ATTEMPT: (userId, testId) => `${BASE_URL}/test/attempts/${userId}/${testId}`,
    FINISH: (userId, testId) => `${BASE_URL}/test/attempts/${userId}/${testId}/finish`,
    SUBMIT_ANSWER: (userId) => `${BASE_URL}/test/user/${userId}/submit-answer`,
    UPDATE_ANSWER: (userId, testId) => `${BASE_URL}/test/attempts/${userId}/${testId}/answer`,
    UPDATE_POSITION: (userId, testId) => `${BASE_URL}/test/attempts/${userId}/${testId}/position`,
    LIST_ATTEMPTS: (userId) => `${BASE_URL}/test/attempts/${userId}/list`,
  },
  
  // Analogy Tool
  ANALOGY: {
    STREAM: `${BASE_URL}/analogy/stream_analogy`,
    GENERATE: `${BASE_URL}/analogy/generate_analogy`, // Legacy endpoint
  },
  
  // Scenario Tool
  SCENARIO: {
    STREAM_SCENARIO: `${BASE_URL}/scenario/stream_scenario`,
    STREAM_QUESTIONS: `${BASE_URL}/scenario/stream_questions`,
  },
  
  // GRC Tool
  GRC: {
    STREAM_QUESTION: `${BASE_URL}/grc/stream_question`,
    GENERATE_QUESTION: `${BASE_URL}/grc/generate_question`, // Legacy endpoint
  },
  
  // Xploitcraft Tool
  XPLOIT: {
    GENERATE_PAYLOAD: `${BASE_URL}/payload/generate_payload`,
  },
  
  // Daily Question
  DAILY: {
    GET_QUESTION: `${BASE_URL}/test/daily-question`,
    SUBMIT_ANSWER: `${BASE_URL}/test/daily-question/answer`,
  },
  
  // Achievements and shop
  ACHIEVEMENTS: `${BASE_URL}/test/achievements`,
  SHOP: {
    ITEMS: `${BASE_URL}/test/shop`,
    PURCHASE: (itemId) => `${BASE_URL}/test/shop/purchase/${itemId}`,
    EQUIP: `${BASE_URL}/test/shop/equip`,
  },
  
  // Support
  SUPPORT: {
    THREADS: `${BASE_URL}/support/my-chat`,
    THREAD: (threadId) => `${BASE_URL}/support/my-chat/${threadId}`,
    CLOSE_THREAD: (threadId) => `${BASE_URL}/support/my-chat/${threadId}/close`,
  },
  
  // Newsletter
  NEWSLETTER: {
    SUBSCRIBE: `${BASE_URL}/newsletter/subscribe`,
    UNSUBSCRIBE: `${BASE_URL}/newsletter/unsubscribe`,
    UNSUBSCRIBE_BY_TOKEN: (token) => `${BASE_URL}/newsletter/unsubscribe/${token}`,
  },
  
  // Leaderboard
  LEADERBOARD: {
    PUBLIC: `${BASE_URL}/public-leaderboard/board`,
    USER: `${BASE_URL}/test/leaderboard`,
  },
  
  // Contact Form
  CONTACT: `${BASE_URL}/contact-form`,
};
</file>

<file path="src/api/authService.js">
// src/api/authService.js
import apiClient from './apiClient';
import { API } from './apiConfig';
import * as SecureStore from 'expo-secure-store';

export const loginUser = async (credentials) => {
  try {
    const response = await apiClient.post(API.AUTH.LOGIN, credentials);
    
    if (response.data && response.data.user_id) {
      // Store user ID securely
      await SecureStore.setItemAsync('userId', response.data.user_id);
    }
    
    return response.data;
  } catch (error) {
    console.error('Login error:', error.response?.data || error.message);
    throw error;
  }
};

export const registerUser = async (userData) => {
  try {
    const response = await apiClient.post(API.AUTH.REGISTER, userData);
    return response.data;
  } catch (error) {
    console.error('Registration error:', error.response?.data || error.message);
    throw error;
  }
};

export const fetchUserData = async (userId) => {
  try {
    const response = await apiClient.get(API.USER.DETAILS(userId));
    return response.data;
  } catch (error) {
    console.error('Fetch user error:', error.response?.data || error.message);
    throw error;
  }
};

export const logoutUser = async () => {
  try {
    await SecureStore.deleteItemAsync('userId');
    // No need to call backend logout endpoint if you're using stateless JWT auth
    // If you want to invalidate server-side session, uncomment:
    // await apiClient.post('/api/logout');
    return { success: true };
  } catch (error) {
    console.error('Logout error:', error);
    throw error;
  }
};

export const claimDailyBonus = async (userId) => {
  try {
    const response = await apiClient.post(API.USER.DAILY_BONUS(userId));
    return response.data;
  } catch (error) {
    console.error('Daily bonus error:', error.response?.data || error.message);
    throw error;
  }
};
</file>

<file path="src/api/dailyStationService.js">
// src/api/dailyStationService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

/**
 * Claim the daily bonus
 * @param {string} userId - The user's ID
 * @returns {Promise} - Resolution of the API call
 */
export const claimDailyBonus = async (userId) => {
  try {
    const response = await apiClient.post(API.USER.DAILY_BONUS(userId));
    return response.data;
  } catch (error) {
    console.error('Daily bonus claim error:', error);
    throw new Error(error.response?.data?.message || error.response?.data?.error || 'Failed to claim daily bonus');
  }
};

/**
 * Get the daily question
 * @param {string} userId - The user's ID
 * @returns {Promise} - Resolution of the API call
 */
export const getDailyQuestion = async (userId) => {
  try {
    const response = await apiClient.get(`${API.DAILY.GET_QUESTION}?userId=${userId}`);
    return response.data;
  } catch (error) {
    console.error('Daily question fetch error:', error);
    throw new Error(error.response?.data?.error || 'Failed to get daily question');
  }
};

/**
 * Submit an answer to the daily question
 * @param {string} userId - The user's ID
 * @param {number} dayIndex - The day index of the question
 * @param {number} selectedIndex - The selected answer index
 * @returns {Promise} - Resolution of the API call
 */
export const submitDailyAnswer = async (userId, dayIndex, selectedIndex) => {
  try {
    const response = await apiClient.post(API.DAILY.SUBMIT_ANSWER, {
      userId,
      dayIndex,
      selectedIndex
    });
    return response.data;
  } catch (error) {
    console.error('Daily answer submission error:', error);
    throw new Error(error.response?.data?.error || 'Failed to submit daily answer');
  }
};
</file>

<file path="src/api/grcService.js">
// src/api/grcService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

export const streamGRCQuestion = async (category = 'Random', difficulty = 'Easy') => {
  try {
    const response = await apiClient.post(
      API.GRC.STREAM_QUESTION,
      { category, difficulty },
      {
        responseType: 'json',
        onDownloadProgress: progressEvent => {
          const jsonChunks = progressEvent.currentTarget.response;
          // Process JSON chunks here
        }
      }
    );
    
    return response.data;
  } catch (error) {
    console.error('Error streaming GRC question:', error);
    throw error;
  }
};
</file>

<file path="src/api/leaderboardService.js">
// src/api/leaderboardService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

// Helper to format image URLs
const formatImageUrl = (url) => {
  if (!url) return null;
  
  // If it's already a complete URL, return it
  if (url.startsWith('http://') || url.startsWith('https://')) {
    return url;
  }
  
  // Fix relative URLs
  if (!url.startsWith('/')) {
    url = '/' + url;
  }
  
  return url;
};

/**
 * Fetch the global leaderboard data
 * @param {number} skip - Number of items to skip (for pagination)
 * @param {number} limit - Number of items to fetch per page
 * @returns {Promise} - Resolution of the API call
 */
export const fetchLeaderboard = async (skip = 0, limit = 20) => {
  try {
    const response = await apiClient.get(`${API.LEADERBOARD.USER}?skip=${skip}&limit=${limit}`);
    
    // Process the data to ensure all fields are present and image URLs are properly formatted
    if (response.data && response.data.data) {
      response.data.data = response.data.data.map((item, index) => {
        if (item.avatarUrl) {
          item.avatarUrl = formatImageUrl(item.avatarUrl);
        }
        
        // Ensure rank is calculated if not provided
        if (!item.rank) {
          item.rank = skip + index + 1;
        }
        
        return item;
      });
    }
    
    return response.data || { data: [], total: 0 };
  } catch (error) {
    console.error('Leaderboard fetch error:', error);
    throw new Error(error.response?.data?.error || 'Failed to fetch leaderboard');
  }
};

/**
 * Fetch the public leaderboard data (no authorization required)
 * @param {number} skip - Number of items to skip (for pagination)
 * @param {number} limit - Number of items to fetch per page
 * @returns {Promise} - Resolution of the API call
 */
export const fetchPublicLeaderboard = async (skip = 0, limit = 20) => {
  try {
    const response = await apiClient.get(`${API.LEADERBOARD.PUBLIC}?skip=${skip}&limit=${limit}`);
    return response.data;
  } catch (error) {
    console.error('Public leaderboard fetch error:', error);
    throw new Error(error.response?.data?.error || 'Failed to fetch public leaderboard');
  }
};

/**
 * Fetch user's current rank and nearby users
 * @param {string} username - The user's username to look up
 * @returns {Promise} - Resolution of the API call
 */
export const fetchUserRanking = async (username) => {
  if (!username) {
    console.warn('No username provided to fetchUserRanking');
    return null;
  }
  
  try {
    // Get the full leaderboard to find user's position
    const response = await apiClient.get(`${API.LEADERBOARD.USER}?skip=0&limit=1000`);
    const leaderboardData = response.data?.data || [];
    
    // Find the user's entry in the leaderboard by username
    const userIndex = leaderboardData.findIndex(item => 
      item.username === username
    );
    
    if (userIndex >= 0) {
      const userEntry = leaderboardData[userIndex];
      return {
        rank: userIndex + 1, // Calculate rank based on position in array
        username: userEntry.username,
        level: userEntry.level,
        xp: userEntry.xp,
        avatarUrl: userEntry.avatarUrl ? formatImageUrl(userEntry.avatarUrl) : null
      };
    } else {
      // If user not found in leaderboard, return null
      console.warn(`User ${username} not found in leaderboard data`);
      return null;
    }
  } catch (error) {
    console.error('User ranking fetch error:', error);
    // Return null instead of throwing, so the app can continue functioning
    return null;
  }
};
</file>

<file path="src/api/newsletterService.js">
// src/api/newsletterService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

/**
 * Subscribe to the newsletter
 * @param {string} email - Email address to subscribe
 * @returns {Promise} - Resolution of the API call
 */
export const subscribeToNewsletter = async (email) => {
  try {
    const response = await apiClient.post(API.NEWSLETTER.SUBSCRIBE, { email });
    return response.data;
  } catch (error) {
    console.error('Newsletter subscription error:', error);
    throw new Error(error.response?.data?.error || 'Failed to subscribe to newsletter');
  }
};

/**
 * Unsubscribe from the newsletter
 * @param {string} email - Email address to unsubscribe
 * @returns {Promise} - Resolution of the API call
 */
export const unsubscribeFromNewsletter = async (email) => {
  try {
    const response = await apiClient.post(API.NEWSLETTER.UNSUBSCRIBE, { email });
    return response.data;
  } catch (error) {
    console.error('Newsletter unsubscription error:', error);
    throw new Error(error.response?.data?.error || 'Failed to unsubscribe from newsletter');
  }
};

/**
 * Unsubscribe using a token (one-click unsubscribe)
 * @param {string} token - Unsubscribe token from email
 * @returns {Promise} - Resolution of the API call
 */
export const unsubscribeByToken = async (token) => {
  try {
    const response = await apiClient.get(API.NEWSLETTER.UNSUBSCRIBE_BY_TOKEN(token));
    return response.data;
  } catch (error) {
    console.error('Token unsubscription error:', error);
    throw new Error(error.response?.data?.error || 'Failed to unsubscribe with token');
  }
};
</file>

<file path="src/api/passwordResetService.js">
// src/api/passwordResetService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

export const requestPasswordReset = async (email) => {
  try {
    const response = await apiClient.post(API.AUTH.FORGOT_PASSWORD, { email });
    return response.data;
  } catch (error) {
    console.error('Error requesting password reset:', error);
    throw error;
  }
};

export const verifyResetToken = async (token) => {
  try {
    const response = await apiClient.get(API.AUTH.VERIFY_TOKEN(token));
    return response.data;
  } catch (error) {
    console.error('Error verifying reset token:', error);
    throw error;
  }
};

export const resetPassword = async (token, newPassword, confirmPassword) => {
  try {
    const response = await apiClient.post(API.AUTH.RESET_PASSWORD, {
      token,
      newPassword,
      confirmPassword
    });
    return response.data;
  } catch (error) {
    console.error('Error resetting password:', error);
    throw error;
  }
};
</file>

<file path="src/api/profileService.js">
// src/api/profileService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

/**
 * Change the user's username
 * @param {string} userId - The user's ID
 * @param {string} newUsername - The new username
 * @returns {Promise} - Resolution of the API call
 */
export const changeUsername = async (userId, newUsername) => {
  try {
    const response = await apiClient.post(API.USER.CHANGE_USERNAME, {
      userId,
      newUsername
    });
    return response.data;
  } catch (error) {
    console.error('Username change error:', error);
    throw new Error(error.response?.data?.error || 'Failed to change username');
  }
};

/**
 * Change the user's email address
 * @param {string} userId - The user's ID
 * @param {string} newEmail - The new email address
 * @returns {Promise} - Resolution of the API call
 */
export const changeEmail = async (userId, newEmail) => {
  try {
    const response = await apiClient.post(API.USER.CHANGE_EMAIL, {
      userId,
      newEmail
    });
    return response.data;
  } catch (error) {
    console.error('Email change error:', error);
    throw new Error(error.response?.data?.error || 'Failed to change email');
  }
};

/**
 * Change the user's password
 * @param {string} userId - The user's ID
 * @param {string} oldPassword - The current password
 * @param {string} newPassword - The new password
 * @param {string} confirmPassword - Confirmation of the new password
 * @returns {Promise} - Resolution of the API call
 */
export const changePassword = async (userId, oldPassword, newPassword, confirmPassword) => {
  try {
    const response = await apiClient.post(API.USER.CHANGE_PASSWORD, {
      userId,
      oldPassword,
      newPassword,
      confirmPassword
    });
    return response.data;
  } catch (error) {
    console.error('Password change error:', error);
    throw new Error(error.response?.data?.error || 'Failed to change password');
  }
};

/**
 * Upload a profile image
 * @param {string} userId - The user's ID
 * @param {object} imageData - The image data to upload
 * @returns {Promise} - Resolution of the API call
 */
export const uploadProfileImage = async (userId, imageData) => {
  try {
    const formData = new FormData();
    formData.append('userId', userId);
    formData.append('profileImage', imageData);
    
    const response = await apiClient.post(API.USER.UPLOAD_PROFILE_IMAGE, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    return response.data;
  } catch (error) {
    console.error('Profile image upload error:', error);
    throw new Error(error.response?.data?.error || 'Failed to upload profile image');
  }
};
</file>

<file path="src/api/ResourcesService.js">
// src/api/ResourcesService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

// This service could be expanded if you need to fetch resources from your backend
// Currently, resources are stored locally in the constants file
export const ResourcesService = {
  // Example API call if you need to fetch resources from backend
  fetchResourceCategories: async () => {
    try {
      const response = await apiClient.get(`${API.RESOURCES.CATEGORIES}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching resource categories:', error);
      throw error;
    }
  },
  
  // Example API call if you need to fetch resources from backend
  fetchResourcesByCategory: async (categoryId) => {
    try {
      const response = await apiClient.get(`${API.RESOURCES.BY_CATEGORY}/${categoryId}`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching resources for category ${categoryId}:`, error);
      throw error;
    }
  },
  
  // Function to track resource clicks if you need analytics
  trackResourceClick: async (resourceId) => {
    try {
      const response = await apiClient.post(`${API.RESOURCES.TRACK_CLICK}`, { resourceId });
      return response.data;
    } catch (error) {
      console.error(`Error tracking resource click ${resourceId}:`, error);
      // Silent fail - don't throw error as this is just analytics
    }
  },
};

export default ResourcesService;
</file>

<file path="src/api/scenarioService.js">
// src/api/scenarioService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

export const streamScenario = async (industry, attackType, skillLevel, threatIntensity) => {
  try {
    const response = await apiClient.post(
      API.SCENARIO.STREAM_SCENARIO,
      {
        industry,
        attack_type: attackType,
        skill_level: skillLevel,
        threat_intensity: threatIntensity
      },
      {
        responseType: 'text',
        onDownloadProgress: progressEvent => {
          const text = progressEvent.currentTarget.response;
          // Process text chunks here
        }
      }
    );
    
    return response.data;
  } catch (error) {
    console.error('Error streaming scenario:', error);
    throw error;
  }
};

export const streamScenarioQuestions = async (scenarioText) => {
  try {
    const response = await apiClient.post(
      API.SCENARIO.STREAM_QUESTIONS,
      { scenario_text: scenarioText },
      {
        responseType: 'json',
        onDownloadProgress: progressEvent => {
          const jsonChunks = progressEvent.currentTarget.response;
          // Process JSON chunks here
        }
      }
    );
    
    return response.data;
  } catch (error) {
    console.error('Error streaming scenario questions:', error);
    throw error;
  }
};
</file>

<file path="src/api/shopService.js">
// src/api/shopService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

// Helper to format image URLs
const formatImageUrl = (url) => {
  if (!url) return null;
  
  // If it's already a complete URL, return it
  if (url.startsWith('http://') || url.startsWith('https://')) {
    return url;
  }
  
  // Fix relative URLs
  if (!url.startsWith('/') && !url.startsWith('./')) {
    url = '/' + url;
  }
  
  return url;
};

/**
 * Fetch all shop items
 * @returns {Promise} Shop items
 */
export const fetchShopItems = async () => {
  try {
    const response = await apiClient.get(API.SHOP.ITEMS);
    
    // Process image URLs to ensure they're properly formatted
    const items = response.data.map(item => {
      if (item.imageUrl) {
        item.imageUrl = formatImageUrl(item.imageUrl);
      }
      return item;
    });
    
    return items;
  } catch (error) {
    console.error('Error fetching shop items:', error);
    // Return an empty array as fallback to prevent undefined errors
    return [];
  }
};

export const getShopItems = fetchShopItems; // Alias for backward compatibility

/**
 * Purchase an item
 * @param {string} userId User ID
 * @param {string} itemId Item ID to purchase
 * @returns {Promise} Purchase result
 */
export const purchaseItem = async (userId, itemId) => {
  try {
    const response = await apiClient.post(API.SHOP.PURCHASE(itemId), { userId });
    return response.data;
  } catch (error) {
    console.error('Error purchasing item:', error);
    throw error;
  }
};

/**
 * Equip an item
 * @param {string} userId User ID
 * @param {string} itemId Item ID to equip
 * @returns {Promise} Equip result
 */
export const equipItem = async (userId, itemId) => {
  try {
    const response = await apiClient.post(API.SHOP.EQUIP, { userId, itemId });
    return response.data;
  } catch (error) {
    console.error('Error equipping item:', error);
    throw error;
  }
};

export default {
  getShopItems,
  fetchShopItems,
  purchaseItem,
  equipItem
};
</file>

<file path="src/api/supportService.js">
// src/api/supportService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

/**
 * Fetch all support threads for the current user
 * @returns {Promise} - Resolution of the API call with threads
 */
export const fetchSupportThreads = async () => {
  try {
    const response = await apiClient.get(API.SUPPORT.THREADS);
    return response.data;
  } catch (error) {
    console.error('Support threads fetch error:', error);
    throw new Error(error.response?.data?.error || 'Failed to fetch support threads');
  }
};

/**
 * Create a new support thread
 * @param {string} subject - The subject of the new thread
 * @returns {Promise} - Resolution of the API call with the new thread data
 */
export const createSupportThread = async (subject) => {
  try {
    const response = await apiClient.post(API.SUPPORT.THREADS, { subject });
    return response.data;
  } catch (error) {
    console.error('Create support thread error:', error);
    throw new Error(error.response?.data?.error || 'Failed to create support thread');
  }
};

/**
 * Fetch a single thread with its messages
 * @param {string} threadId - The ID of the thread to fetch
 * @returns {Promise} - Resolution of the API call with thread data and messages
 */
export const fetchSupportThread = async (threadId) => {
  try {
    const response = await apiClient.get(API.SUPPORT.THREAD(threadId));
    return response.data;
  } catch (error) {
    console.error('Fetch support thread error:', error);
    throw new Error(error.response?.data?.error || 'Failed to fetch support thread');
  }
};

/**
 * Send a message to a support thread
 * @param {string} threadId - The ID of the thread
 * @param {string} content - The message content
 * @returns {Promise} - Resolution of the API call
 */
export const sendSupportMessage = async (threadId, content) => {
  try {
    const response = await apiClient.post(API.SUPPORT.THREAD(threadId), { content });
    return response.data;
  } catch (error) {
    console.error('Send support message error:', error);
    throw new Error(error.response?.data?.error || 'Failed to send message');
  }
};

/**
 * Close a support thread
 * @param {string} threadId - The ID of the thread to close
 * @returns {Promise} - Resolution of the API call
 */
export const closeSupportThread = async (threadId) => {
  try {
    const response = await apiClient.post(API.SUPPORT.CLOSE_THREAD(threadId), {
      content: 'Thread closed by user'
    });
    return response.data;
  } catch (error) {
    console.error('Close support thread error:', error);
    throw new Error(error.response?.data?.error || 'Failed to close thread');
  }
};
</file>

<file path="src/api/testService.js">
// src/api/testService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

/**
 * Fetch tests by category
 * 
 * Note: This mimics the web app approach by generating test objects programmatically
 * rather than fetching from an API endpoint that doesn't exist
 * 
 * @param {string} category - The test category (e.g., 'aplus', 'secplus')
 * @returns {Promise<Array>} - Promise resolving to array of tests
 */
export const fetchTestsByCategory = async (category) => {
  try {
    // Generate 10 test objects for the category, matching web app approach
    return Array.from({ length: 10 }, (_, i) => ({
      testId: i + 1,
      testName: `${category.charAt(0).toUpperCase() + category.slice(1)} Test ${i + 1}`,
      category: category,
      questionCount: 100
    }));
  } catch (error) {
    console.error(`Error creating test objects for ${category}:`, error);
    throw new Error(error.message || 'Error creating test objects');
  }
};

/**
 * Fetch a specific test by ID and category
 * @param {string} category - The test category
 * @param {string|number} testId - The test ID
 * @returns {Promise<Object>} - Promise resolving to the test object
 */
export const fetchTestById = async (category, testId) => {
  try {
    const response = await apiClient.get(API.TESTS.DETAILS(category, testId));
    return response.data;
  } catch (error) {
    console.error(`Error fetching test ${testId}:`, error);
    const errorMsg = error?.response?.data?.error || error.message || 'Network error';
    throw new Error(errorMsg);
  }
};

/**
 * Fetch a test attempt
 * @param {string} userId - The user ID
 * @param {string|number} testId - The test ID
 * @param {string} [status] - Optional status filter ('finished' or 'unfinished')
 * @returns {Promise<Object>} - Promise resolving to attempt data
 */
export const fetchTestAttempt = async (userId, testId, status) => {
  try {
    let url = API.TESTS.ATTEMPT(userId, testId);
    if (status) {
      url += `?status=${status}`;
    }
    const response = await apiClient.get(url);
    return response.data;
  } catch (error) {
    console.error(`Error fetching test attempt:`, error);
    const errorMsg = error?.response?.data?.error || error.message || 'Network error';
    throw new Error(errorMsg);
  }
};

/**
 * Create or update a test attempt
 * @param {string} userId - The user ID
 * @param {string|number} testId - The test ID
 * @param {Object} attemptData - Test attempt data
 * @returns {Promise<Object>} - Promise resolving to response data
 */
export const createOrUpdateAttempt = async (userId, testId, attemptData) => {
  try {
    const response = await apiClient.post(
      API.TESTS.ATTEMPT(userId, testId),
      attemptData
    );
    return response.data;
  } catch (error) {
    console.error(`Error creating/updating test attempt:`, error);
    const errorMsg = error?.response?.data?.error || error.message || 'Network error';
    throw new Error(errorMsg);
  }
};

/**
 * Finish a test attempt
 * @param {string} userId - The user ID
 * @param {string|number} testId - The test ID
 * @param {Object} finishData - Data to send with finish request
 * @returns {Promise<Object>} - Promise resolving to response data
 */
export const finishTestAttempt = async (userId, testId, finishData) => {
  try {
    const response = await apiClient.post(
      API.TESTS.FINISH(userId, testId),
      finishData
    );
    return response.data;
  } catch (error) {
    console.error(`Error finishing test attempt:`, error);
    const errorMsg = error?.response?.data?.error || error.message || 'Network error';
    throw new Error(errorMsg);
  }
};

/**
 * Submit an answer to a question
 * @param {string} userId - The user ID 
 * @param {Object} answerData - Answer data
 * @returns {Promise<Object>} - Promise resolving to response data
 */
export const submitAnswer = async (userId, answerData) => {
  try {
    const response = await apiClient.post(
      API.TESTS.SUBMIT_ANSWER(userId),
      answerData
    );
    return response.data;
  } catch (error) {
    console.error(`Error submitting answer:`, error);
    const errorMsg = error?.response?.data?.error || error.message || 'Network error';
    throw new Error(errorMsg);
  }
};

/**
 * Update a single answer in a test attempt
 * @param {string} userId - The user ID
 * @param {string|number} testId - The test ID 
 * @param {Object} answerData - Answer data to update
 * @returns {Promise<Object>} - Promise resolving to response data
 */
export const updateAnswer = async (userId, testId, answerData) => {
  try {
    const response = await apiClient.post(
      API.TESTS.UPDATE_ANSWER(userId, testId),
      answerData
    );
    return response.data;
  } catch (error) {
    console.error(`Error updating answer:`, error);
    const errorMsg = error?.response?.data?.error || error.message || 'Network error';
    throw new Error(errorMsg);
  }
};

/**
 * Update the current question position in a test attempt
 * @param {string} userId - The user ID
 * @param {string|number} testId - The test ID
 * @param {Object} positionData - Position data
 * @returns {Promise<Object>} - Promise resolving to response data
 */
export const updatePosition = async (userId, testId, positionData) => {
  try {
    const response = await apiClient.post(
      API.TESTS.UPDATE_POSITION(userId, testId),
      positionData
    );
    return response.data;
  } catch (error) {
    console.error(`Error updating position:`, error);
    const errorMsg = error?.response?.data?.error || error.message || 'Network error';
    throw new Error(errorMsg);
  }
};

/**
 * List all test attempts for a user
 * @param {string} userId - The user ID
 * @param {number} [page=1] - Page number
 * @param {number} [pageSize=50] - Number of items per page
 * @returns {Promise<Object>} - Promise resolving to response data
 */
export const listTestAttempts = async (userId, page = 1, pageSize = 50) => {
  try {
    const response = await apiClient.get(
      `${API.TESTS.LIST_ATTEMPTS(userId)}?page=${page}&page_size=${pageSize}`
    );
    return response.data;
  } catch (error) {
    console.error(`Error listing test attempts:`, error);
    const errorMsg = error?.response?.data?.error || error.message || 'Network error';
    throw new Error(errorMsg);
  }
};

const testService = {
  fetchTestsByCategory,
  fetchTestById,
  fetchTestAttempt,
  createOrUpdateAttempt,
  finishTestAttempt,
  submitAnswer,
  updateAnswer,
  updatePosition,
  listTestAttempts,
};

export default testService;
</file>

<file path="src/api/xploitService.js">
// src/api/xploitService.js
import apiClient from './apiClient';
import { API } from './apiConfig';

export const generatePayload = async (vulnerability, evasionTechnique, stream = true) => {
  try {
    const response = await apiClient.post(
      API.XPLOIT.GENERATE_PAYLOAD,
      {
        vulnerability,
        evasion_technique: evasionTechnique,
        stream
      },
      {
        responseType: stream ? 'text' : 'json',
        onDownloadProgress: stream ? (progressEvent => {
          const text = progressEvent.currentTarget.response;
          // Process text chunks here
        }) : undefined
      }
    );
    
    return response.data;
  } catch (error) {
    console.error('Error generating payload:', error);
    throw error;
  }
};
</file>

<file path="src/components/AchievementItem.js">
// src/screens/profile/components/AchievementItem.js
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Platform } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getAchievementIcon, getAchievementColor } from '../constants/achievementConstants';

/**
 * Achievement item component
 * @param {Object} achievement - The achievement object
 * @param {boolean} isUnlocked - Whether the achievement is unlocked
 * @param {Function} onPress - Callback for when the item is pressed
 * @returns {JSX.Element}
 */
const AchievementItem = ({ achievement, isUnlocked, onPress }) => {
  const iconName = getAchievementIcon(achievement.achievementId);
  const iconColor = getAchievementColor(achievement.achievementId);
  
  return (
    <TouchableOpacity 
      style={[
        styles.container,
        isUnlocked ? styles.unlockedContainer : styles.lockedContainer
      ]}
      onPress={() => onPress && onPress(achievement)}
      activeOpacity={0.7}
    >
      <View style={styles.header}>
        <View style={[styles.iconContainer, { backgroundColor: iconColor }]}>
          <Ionicons name={iconName} size={24} color="#FFFFFF" />
        </View>
        
        <View style={styles.infoContainer}>
          <Text style={styles.title}>{achievement.title}</Text>
          <Text style={styles.description} numberOfLines={2}>
            {achievement.description}
          </Text>
        </View>
        
        {isUnlocked ? (
          <View style={styles.unlockedBadge}>
            <Ionicons name="checkmark-circle" size={20} color="#2ebb77" />
          </View>
        ) : (
          <View style={styles.lockedBadge}>
            <Ionicons name="lock-closed" size={20} color="#AAAAAA" />
          </View>
        )}
      </View>
      
      {isUnlocked && (
        <View style={styles.statusContainer}>
          <Text style={styles.statusText}>Unlocked</Text>
        </View>
      )}
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#1E1E1E',
    borderRadius: 12,
    marginBottom: 16,
    overflow: 'hidden',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  unlockedContainer: {
    borderLeftWidth: 4,
    borderLeftColor: '#2ebb77',
  },
  lockedContainer: {
    opacity: 0.7,
  },
  header: {
    flexDirection: 'row',
    padding: 16,
  },
  iconContainer: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 16,
  },
  infoContainer: {
    flex: 1,
    justifyContent: 'center',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 4,
  },
  description: {
    fontSize: 14,
    color: '#AAAAAA',
  },
  unlockedBadge: {
    alignSelf: 'center',
    marginLeft: 8,
  },
  lockedBadge: {
    alignSelf: 'center',
    marginLeft: 8,
  },
  statusContainer: {
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
    padding: 8,
    borderBottomLeftRadius: 12,
    borderBottomRightRadius: 12,
    alignItems: 'center',
  },
  statusText: {
    color: '#2ebb77',
    fontSize: 12,
    fontWeight: 'bold',
  },
});

export default AchievementItem;
</file>

<file path="src/components/FormattedQuestion.js">
// src/components/FormattedQuestion.js
import React, { useMemo } from 'react';
import { View, Text, StyleSheet, ScrollView, Platform } from 'react-native';

/**
 * FormattedQuestion component handles rich text formatting for questions in React Native
 * Supports Markdown-like syntax: code blocks, inline code, tables, and ASCII diagrams
 * Adapted from web version but optimized for mobile
 * 
 * @param {string} questionText - The text of the question to format
 * @returns {JSX.Element} - Formatted question component
 */
const FormattedQuestion = ({ questionText }) => {
  // Process the question text to handle formatting
  const processedContent = useMemo(() => {
    // Return empty array if no question text
    if (!questionText) return [];
    
    // Split the content by code blocks first
    const parts = [];
    let lastIndex = 0;
    
    // Find all code blocks (both triple backtick and single backtick)
    const codeBlockRegex = /```(\w*)\n([\s\S]*?)```|`([^`]+)`/g;
    let match;
    
    while ((match = codeBlockRegex.exec(questionText)) !== null) {
      // Add text before the code block
      if (match.index > lastIndex) {
        parts.push({
          type: 'text',
          content: questionText.substring(lastIndex, match.index)
        });
      }
      
      // Check if this is a triple backtick code block or inline code
      if (match[2]) {
        // Triple backtick code block
        parts.push({
          type: 'code-block',
          language: match[1] || 'plaintext',
          content: match[2]
        });
      } else {
        // Inline code
        parts.push({
          type: 'inline-code',
          content: match[3]
        });
      }
      
      lastIndex = match.index + match[0].length;
    }
    
    // Add any remaining text
    if (lastIndex < questionText.length) {
      parts.push({
        type: 'text',
        content: questionText.substring(lastIndex)
      });
    }
    
    // Process tables in text parts
    const processedParts = parts.map(part => {
      if (part.type !== 'text') return part;
      
      // Check for table patterns
      if (part.content.includes('|') && part.content.includes('\n') &&
          part.content.match(/\|[\s-]+\|/)) {
        return {
          type: 'table',
          content: part.content
        };
      }
      
      // Check for ASCII diagrams (lines with lots of special chars like -│┌┐└┘)
      if (part.content.match(/[│├┤┌┐└┘┬┴┼─|/\\+*=><^v]/g) && 
          part.content.split('\n').some(line => 
            (line.match(/[│├┤┌┐└┘┬┴┼─|/\\+*=><^v]/g) || []).length > 5)) {
        return {
          type: 'ascii-diagram',
          content: part.content
        };
      }
      
      return part;
    });
    
    return processedParts;
  }, [questionText]);

  // Function to parse and render a table
  const renderTable = (tableText) => {
    const lines = tableText.split('\n').filter(line => line.trim());
    if (lines.length < 2) {
      return (
        <Text style={styles.plainText}>{tableText}</Text>
      );
    }

    // Check if the second line contains a separator row (e.g., |------|------|)
    const isMarkdownTable = lines[1].match(/\|[-:\s]+\|/);
    
    if (!isMarkdownTable) {
      // Treat as pre-formatted text if not a markdown table
      return (
        <Text style={styles.preformattedText}>{tableText}</Text>
      );
    }

    // Process markdown table
    const headerRow = lines[0];
    const headerCells = headerRow.split('|')
      .filter(cell => cell.trim())
      .map(cell => cell.trim());
    
    // Skip the separator row and process data rows
    const dataRows = lines.slice(2).map(row => {
      return row.split('|')
        .filter(cell => cell.trim())
        .map(cell => cell.trim());
    });
    
    return (
      <ScrollView horizontal style={styles.tableContainer}>
        <View style={styles.table}>
          {/* Header row */}
          <View style={styles.tableRow}>
            {headerCells.map((cell, i) => (
              <View key={i} style={styles.tableHeaderCell}>
                <Text style={styles.tableHeaderCellText}>{cell}</Text>
              </View>
            ))}
          </View>
          
          {/* Data rows */}
          {dataRows.map((row, i) => (
            <View key={i} style={styles.tableRow}>
              {row.map((cell, j) => (
                <View key={j} style={styles.tableCell}>
                  <Text style={styles.tableCellText}>{cell}</Text>
                </View>
              ))}
            </View>
          ))}
        </View>
      </ScrollView>
    );
  };

  // Early return after hooks are called
  if (!questionText) return null;

  // Render the content based on the processed parts
  return (
    <View style={styles.container}>
      {processedContent.map((part, index) => {
        switch (part.type) {
          case 'code-block':
            return (
              <View key={index} style={styles.codeBlock}>
                <ScrollView horizontal={true}>
                  <Text style={styles.codeText}>
                    {part.content}
                  </Text>
                </ScrollView>
              </View>
            );
          
          case 'inline-code':
            return (
              <Text key={index} style={styles.inlineCode}>
                {part.content}
              </Text>
            );
          
          case 'table':
            return (
              <View key={index} style={styles.tableWrapper}>
                {renderTable(part.content)}
              </View>
            );
          
          case 'ascii-diagram':
            return (
              <ScrollView key={index} horizontal style={styles.asciiDiagramContainer}>
                <Text style={styles.asciiDiagramText}>
                  {part.content}
                </Text>
              </ScrollView>
            );
          
          default:
            // Handle regular text (preserving newlines and formatting)
            return (
              <Text key={index} style={styles.paragraph}>
                {part.content.split('\n').map((line, i, arr) => (
                  <React.Fragment key={i}>
                    {line}
                    {i < arr.length - 1 ? '\n' : ''}
                  </React.Fragment>
                ))}
              </Text>
            );
        }
      })}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  paragraph: {
    color: '#E2E2E2',
    fontSize: 16,
    lineHeight: 24,
    marginBottom: 12,
  },
  plainText: {
    color: '#E2E2E2',
    fontSize: 16,
    lineHeight: 24,
  },
  preformattedText: {
    color: '#E2E2E2',
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
    fontSize: 14,
    marginVertical: 10,
  },
  codeBlock: {
    backgroundColor: '#1E1E2E',
    borderRadius: 6,
    padding: 12,
    marginVertical: 12,
    borderWidth: 1,
    borderColor: '#2D2D3A',
  },
  codeText: {
    color: '#E2E2E2',
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
    fontSize: 14,
  },
  inlineCode: {
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 3,
    paddingHorizontal: 5,
    paddingVertical: 2,
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
    fontSize: 14,
    color: '#E2E2E2',
  },
  // Table styles
  tableWrapper: {
    marginVertical: 10,
  },
  tableContainer: {
    maxHeight: 300, // Limit maximum height
  },
  table: {
    borderWidth: 1,
    borderColor: '#2D2D3A',
    borderRadius: 4,
    overflow: 'hidden',
  },
  tableRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#2D2D3A',
  },
  tableHeaderCell: {
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    padding: 8,
    borderRightWidth: 1,
    borderRightColor: '#2D2D3A',
  },
  tableHeaderCellText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
    fontSize: 14,
  },
  tableCell: {
    padding: 8,
    borderRightWidth: 1,
    borderRightColor: '#2D2D3A',
  },
  tableCellText: {
    color: '#E2E2E2',
    fontSize: 14,
  },
  // ASCII diagram styles
  asciiDiagramContainer: {
    backgroundColor: '#1E1E2E',
    borderRadius: 6,
    padding: 12,
    marginVertical: 10,
    borderWidth: 1,
    borderColor: '#2D2D3A',
  },
  asciiDiagramText: {
    color: '#E2E2E2',
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
    fontSize: 14,
  },
});

export default FormattedQuestion;
</file>

<file path="src/components/ResourceItemComponent.js">
// src/components/ResourceItemComponent.js
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Linking } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const ResourceItemComponent = ({ resource, listMode = false }) => {
  // Function to get the source icon based on URL or name
  const getSourceIcon = () => {
    const { url, name } = resource;
    
    if (url.includes('reddit.com')) return { name: 'logo-reddit', color: '#FF4500' };
    if (url.includes('youtube.com') || url.includes('youtu.be')) return { name: 'logo-youtube', color: '#FF0000' };
    if (url.includes('udemy.com')) return { name: 'school-outline', color: '#A435F0' };
    if (url.includes('linkedin.com')) return { name: 'logo-linkedin', color: '#0077B5' };
    if (url.includes('github.com')) return { name: 'logo-github', color: '#6E5494' };
    if (url.includes('comptia.org') || name.includes('CompTIA') || name.includes('A+') || name.includes('Network+') || name.includes('Security+')) 
      return { name: 'document-text-outline', color: '#C80024' };
    if (name.toLowerCase().includes('pentest') || name.toLowerCase().includes('nmap') || name.toLowerCase().includes('kali'))
      return { name: 'construct-outline', color: '#00B0FF' };
    
    // Default icon
    return { name: 'link-outline', color: '#6543CC' };
  };
  
  const openURL = async () => {
    try {
      const canOpen = await Linking.canOpenURL(resource.url);
      if (canOpen) {
        await Linking.openURL(resource.url);
      } else {
        console.error('Cannot open URL:', resource.url);
      }
    } catch (error) {
      console.error('Error opening URL:', error);
    }
  };
  
  const sourceIcon = getSourceIcon();
  
  // List mode is more compact for narrow displays
  if (listMode) {
    return (
      <TouchableOpacity style={styles.listItem} onPress={openURL}>
        <Ionicons name={sourceIcon.name} size={18} color={sourceIcon.color} style={styles.listIcon} />
        <Text style={styles.listText} numberOfLines={1} ellipsizeMode="tail">
          {resource.name}
        </Text>
        <Ionicons name="chevron-forward" size={16} color="#AAAAAA" />
      </TouchableOpacity>
    );
  }
  
  // Card mode is more visual
  return (
    <TouchableOpacity style={styles.card} onPress={openURL}>
      <View style={styles.cardContent}>
        <View style={[styles.iconContainer, { backgroundColor: `${sourceIcon.color}20` }]}>
          <Ionicons name={sourceIcon.name} size={22} color={sourceIcon.color} />
        </View>
        <View style={styles.textContainer}>
          <Text style={styles.title} numberOfLines={2} ellipsizeMode="tail">
            {resource.name}
          </Text>
        </View>
        <View style={styles.arrowContainer}>
          <Ionicons name="open-outline" size={18} color="#AAAAAA" />
        </View>
      </View>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  // Card mode styles
  card: {
    backgroundColor: '#1E1E1E',
    borderRadius: 10,
    marginBottom: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  cardContent: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  textContainer: {
    flex: 1,
  },
  title: {
    color: '#FFFFFF',
    fontSize: 15,
    fontWeight: '500',
  },
  arrowContainer: {
    width: 30,
    height: 30,
    borderRadius: 15,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 8,
  },
  
  // List mode styles
  listItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 15,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.05)',
  },
  listIcon: {
    marginRight: 12,
  },
  listText: {
    flex: 1,
    color: '#FFFFFF',
    fontSize: 14,
  },
});

export default ResourceItemComponent;
</file>

<file path="src/components/ResourceRandomModal.js">
// src/components/ResourceRandomModal.js
import React, { useEffect } from 'react';
import {
  View,
  Text,
  Modal,
  TouchableOpacity,
  StyleSheet,
  Animated,
  Linking,
  Dimensions
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const ResourceRandomModal = ({ 
  visible, 
  resource, 
  onClose, 
  onGetAnother, 
  isLoading 
}) => {
  // Animations
  const fadeAnim = new Animated.Value(0);
  const slideAnim = new Animated.Value(50);
  
  useEffect(() => {
    if (visible) {
      // Reset animations when modal becomes visible
      fadeAnim.setValue(0);
      slideAnim.setValue(50);
      
      // Start animations
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [visible, resource]);
  
  const handleOpenResource = async () => {
    if (resource && resource.url) {
      try {
        const canOpen = await Linking.canOpenURL(resource.url);
        if (canOpen) {
          await Linking.openURL(resource.url);
        }
      } catch (error) {
        console.error('Error opening URL:', error);
      }
    }
  };
  
  // Animation when closing
  const handleClose = () => {
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 200,
        useNativeDriver: true,
      }),
      Animated.timing(slideAnim, {
        toValue: 50,
        duration: 200,
        useNativeDriver: true,
      }),
    ]).start(() => {
      onClose();
    });
  };
  
  if (!resource) return null;
  
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={handleClose}
    >
      <View style={styles.modalOverlay}>
        <Animated.View 
          style={[
            styles.modalContainer,
            {
              opacity: fadeAnim,
              transform: [{ translateY: slideAnim }]
            }
          ]}
        >
          <TouchableOpacity style={styles.closeButton} onPress={handleClose}>
            <Ionicons name="close" size={22} color="#FFFFFF" />
          </TouchableOpacity>
          
          <View style={styles.modalHeader}>
            <View style={styles.iconContainer}>
              <Ionicons name="bulb-outline" size={24} color="#FFFFFF" />
            </View>
            <Text style={styles.modalTitle}>Resource Spotlight</Text>
          </View>
          
          <View style={styles.modalBody}>
            <Text style={styles.resourceTitle}>{resource.name}</Text>
            
            <Text style={styles.modalDescription}>
              Expand your cybersecurity knowledge with this resource:
            </Text>
            
            <TouchableOpacity 
              style={styles.openButton} 
              onPress={handleOpenResource}
            >
              <Text style={styles.openButtonText}>Open Resource</Text>
              <Ionicons name="open-outline" size={18} color="#FFFFFF" />
            </TouchableOpacity>
            
            <TouchableOpacity 
              style={styles.randomButton}
              onPress={onGetAnother}
              disabled={isLoading}
            >
              {isLoading ? (
                <View style={styles.loadingContainer}>
                  <Ionicons name="sync-outline" size={18} color="#FFFFFF" style={styles.spinIcon} />
                  <Text style={styles.randomButtonText}>Loading...</Text>
                </View>
              ) : (
                <>
                  <Ionicons name="shuffle-outline" size={18} color="#FFFFFF" />
                  <Text style={styles.randomButtonText}>Try Another</Text>
                </>
              )}
            </TouchableOpacity>
          </View>
        </Animated.View>
      </View>
    </Modal>
  );
};

const { width } = Dimensions.get('window');

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContainer: {
    width: width > 400 ? 380 : width - 40,
    backgroundColor: '#1A1A1A',
    borderRadius: 15,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  closeButton: {
    position: 'absolute',
    right: 10,
    top: 10,
    zIndex: 10,
    width: 30,
    height: 30,
    borderRadius: 15,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalHeader: {
    backgroundColor: '#6543CC',
    padding: 20,
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 15,
  },
  modalTitle: {
    color: '#FFFFFF',
    fontSize: 20,
    fontWeight: 'bold',
  },
  modalBody: {
    padding: 20,
  },
  resourceTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 15,
  },
  modalDescription: {
    color: '#AAAAAA',
    marginBottom: 20,
    fontSize: 14,
  },
  openButton: {
    backgroundColor: '#6543CC',
    borderRadius: 10,
    padding: 15,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 15,
  },
  openButtonText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
    marginRight: 8,
    fontSize: 16,
  },
  randomButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 10,
    padding: 15,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.2)',
  },
  randomButtonText: {
    color: '#FFFFFF',
    fontWeight: '500',
    marginLeft: 8,
    fontSize: 15,
  },
  loadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  spinIcon: {
    transform: [{ rotate: '0deg' }],
  },
});

export default ResourceRandomModal;
</file>

<file path="src/components/ResourcesCategoriesComponent.js">
// src/components/ResourcesCategoriesComponent.js
import React from 'react';
import { View, Text, TouchableOpacity, FlatList, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { RESOURCE_CATEGORIES, CERT_CATEGORIES } from '../constants/resourcesConstants';

const ResourcesCategoriesComponent = ({ 
  selectedCategory, 
  onSelectCategory, 
  showCerts = false,
  onToggleCerts,
}) => {
  
  // Determine which categories to display
  const categories = showCerts ? CERT_CATEGORIES : RESOURCE_CATEGORIES;
  
  // Render an individual category button
  const renderCategory = ({ item }) => (
    <TouchableOpacity
      style={[
        styles.categoryButton,
        selectedCategory === item.id && styles.selectedCategory
      ]}
      onPress={() => onSelectCategory(item.id)}
    >
      <Ionicons 
        name={item.iconName} 
        size={20} 
        color={selectedCategory === item.id ? '#FFFFFF' : '#6543CC'} 
      />
      <Text 
        style={[
          styles.categoryName,
          selectedCategory === item.id && styles.selectedCategoryText
        ]}
        numberOfLines={1}
      >
        {item.name}
      </Text>
    </TouchableOpacity>
  );
  
  return (
    <View style={styles.container}>
      <View style={styles.headerContainer}>
        <Text style={styles.header}>Categories</Text>
        <TouchableOpacity 
          style={styles.toggleButton}
          onPress={onToggleCerts}
        >
          <Text style={styles.toggleText}>
            {showCerts ? 'Show Resource Types' : 'Show Certifications'}
          </Text>
        </TouchableOpacity>
      </View>
      
      <FlatList
        data={categories}
        renderItem={renderCategory}
        keyExtractor={(item) => item.id}
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.categoriesList}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginVertical: 10,
  },
  headerContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 15,
    marginBottom: 10,
  },
  header: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  toggleButton: {
    backgroundColor: 'rgba(101, 67, 204, 0.1)',
    paddingVertical: 6,
    paddingHorizontal: 12,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#6543CC',
  },
  toggleText: {
    color: '#6543CC',
    fontSize: 12,
    fontWeight: '500',
  },
  categoriesList: {
    paddingHorizontal: 10,
    paddingBottom: 5,
  },
  categoryButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    paddingVertical: 8,
    paddingHorizontal: 14,
    borderRadius: 20,
    marginRight: 10,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  selectedCategory: {
    backgroundColor: '#6543CC',
    borderColor: '#6543CC',
  },
  categoryName: {
    color: '#FFFFFF',
    marginLeft: 8,
    fontSize: 14,
    fontWeight: '500',
  },
  selectedCategoryText: {
    color: '#FFFFFF',
  },
});

export default ResourcesCategoriesComponent;
</file>

<file path="src/components/TestProgressComponent.js">
// src/components/TestProgressComponent.js
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { useSelector } from 'react-redux';
import testService from '../api/testService';

/**
 * Component to display progress for a test category
 * 
 * @param {Object} props - Component props
 * @param {string} props.category - The test category to show progress for
 * @returns {JSX.Element|null} - The progress component or null if no data
 */
const TestProgressComponent = ({ category }) => {
  const [progress, setProgress] = useState(null);
  const [loading, setLoading] = useState(true);
  const { userId } = useSelector(state => state.user);

  useEffect(() => {
    const fetchProgress = async () => {
      if (!userId || !category) return;
      
      try {
        setLoading(true);
        // Get all attempts for the user
        const attempts = await testService.listTestAttempts(userId);
        
        // Filter attempts for this category
        const categoryAttempts = attempts.attempts.filter(a => a.category === category);
        
        // Count finished attempts by testId
        const finishedTests = new Set();
        categoryAttempts.forEach(attempt => {
          if (attempt.finished) {
            finishedTests.add(attempt.testId);
          }
        });
        
        // Calculate percentages
        const testsCompleted = finishedTests.size;
        const totalTests = 10; // Most categories have 10 tests
        const percentComplete = Math.round((testsCompleted / totalTests) * 100);
        
        setProgress({
          completed: testsCompleted,
          total: totalTests,
          percent: percentComplete
        });
      } catch (err) {
        console.error('Error fetching test progress:', err);
        // Create a fallback progress object
        setProgress({
          completed: 0,
          total: 10,
          percent: 0
        });
      } finally {
        setLoading(false);
      }
    };
    
    fetchProgress();
  }, [userId, category]);
  
  // Don't render if still loading or no progress data
  if (loading || !progress) return null;
  
  return (
    <View style={styles.container}>
      <Text style={styles.progressText}>
        {progress.completed}/{progress.total} Tests Completed ({progress.percent}%)
      </Text>
      <View style={styles.progressBar}>
        <View 
          style={[
            styles.progressFill, 
            { width: `${progress.percent}%` }
          ]} 
        />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    margin: 15,
    marginTop: 5,
    marginBottom: 10,
    backgroundColor: '#1E1E1E',
    padding: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#2A2A2A',
  },
  progressText: {
    fontSize: 14,
    color: '#FFFFFF',
    marginBottom: 8,
    textAlign: 'center',
  },
  progressBar: {
    height: 6,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 3,
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#6543CC',
    borderRadius: 3,
  }
});

export default TestProgressComponent;
</file>

<file path="src/constants/shop/shopConstants.js">
// src/constants/shopConstants.js

// Shop item types
export const ITEM_TYPES = {
  AVATAR: 'avatar',
  XP_BOOST: 'xpBoost',
  NAME_COLOR: 'nameColor',
};

// Shop categories
export const SHOP_CATEGORIES = [
  { id: 'all', label: 'All Items' },
  { id: 'avatar', label: 'Avatars' },
  { id: 'xpBoost', label: 'XP Boosts' },
  { id: 'nameColor', label: 'Name Colors' },
];

// Default shop items (if API fails or for testing)
export const DEFAULT_SHOP_ITEMS = [
  {
    _id: 'avatar1',
    type: 'avatar',
    title: 'Default Avatar',
    description: 'The default avatar for all users.',
    cost: 0,
    imageUrl: '/assets/avatars/default.png',
    unlockLevel: 1,
  },
  {
    _id: 'boost1',
    type: 'xpBoost',
    title: 'Basic XP Boost',
    description: 'Increases your XP gain by 10% for all activities.',
    cost: 500,
    effectValue: 1.1,
    unlockLevel: 5,
  },
  {
    _id: 'color1',
    type: 'nameColor',
    title: 'Purple',
    description: 'Change your name color to royal purple.',
    cost: 1000,
    effectValue: '#6543CC',
    unlockLevel: 10,
  },
];

// Error messages
export const ERROR_MESSAGES = {
  INSUFFICIENT_COINS: 'You do not have enough coins to purchase this item.',
  ALREADY_PURCHASED: 'You already own this item.',
  LEVEL_LOCKED: 'You need to reach a higher level to unlock this item.',
  PURCHASE_FAILED: 'Failed to purchase the item. Please try again later.',
  EQUIP_FAILED: 'Failed to equip the item. Please try again later.',
  FETCH_FAILED: 'Failed to fetch shop items. Please try again later.',
};
</file>

<file path="src/constants/achievementConstants.js">
// src/constants/achievementConstants.js

// Achievement categories
export const ACHIEVEMENT_CATEGORIES = {
  ALL: 'all',
  TEST: 'test',
  SCORE: 'score',
  COINS: 'coins',
  LEVEL: 'level',
  QUESTIONS: 'questions',
};

// Category display names
export const CATEGORY_NAMES = {
  all: 'All Achievements',
  test: 'Test Completion',
  score: 'Score & Accuracy',
  coins: 'Coin Collection',
  level: 'Leveling Up',
  questions: 'Question Mastery',
};

// Icon mappings for achievement types
export const ACHIEVEMENT_ICONS = {
  // Level-related
  level_up_5: 'trophy',
  mid_tier_grinder_25: 'trophy',
  elite_scholar_50: 'trophy',
  ultimate_master_100: 'trophy',
  bronze_grinder: 'trophy',
  silver_scholar: 'medal',
  gold_god: 'medal',
  platinum_pro: 'medal',
  
  // Coin-related
  coin_collector_5000: 'cash',
  coin_hoarder_10000: 'cash',
  coin_tycoon_50000: 'cash',
  
  // Accuracy-related
  accuracy_king: 'checkmark-circle',
  perfectionist_1: 'checkmark-circle',
  double_trouble_2: 'checkmark-circle',
  error404_failure_not_found: 'checkmark-circle',
  redemption_arc: 'fitness',
  
  // Question-related
  answer_machine_1000: 'book',
  knowledge_beast_5000: 'book',
  question_terminator: 'book',
  walking_encyclopedia: 'book',
  
  // Test-related
  test_rookie: 'school',
  test_finisher: 'school',
  
  // Default
  default: 'ribbon',
};

// Color mappings for achievement types
export const ACHIEVEMENT_COLORS = {
  // Level-related
  level_up_5: '#6543CC',
  mid_tier_grinder_25: '#6543CC',
  elite_scholar_50: '#FF4C8B',
  ultimate_master_100: '#FF4C8B',
  bronze_grinder: '#CD7F32',
  silver_scholar: '#C0C0C0',
  gold_god: '#FFD700',
  platinum_pro: '#E5E4E2',
  
  // Coin-related
  coin_collector_5000: '#FFD700',
  coin_hoarder_10000: '#FFD700',
  coin_tycoon_50000: '#FFD700',
  
  // Accuracy-related
  accuracy_king: '#2ebb77',
  perfectionist_1: '#2ebb77',
  double_trouble_2: '#2ebb77',
  error404_failure_not_found: '#2ebb77',
  redemption_arc: '#FF4500',
  
  // Question-related
  answer_machine_1000: '#3498DB',
  knowledge_beast_5000: '#3498DB',
  question_terminator: '#3498DB',
  walking_encyclopedia: '#3498DB',
  
  // Test-related
  test_rookie: '#F39C12',
  test_finisher: '#F39C12',
  
  // Default
  default: '#95A5A6',
};

/**
 * Get the icon for an achievement
 * @param {string} achievementId - The achievement ID
 * @returns {string} - The Ionicons icon name
 */
export const getAchievementIcon = (achievementId) => {
  // Direct match
  if (ACHIEVEMENT_ICONS[achievementId]) {
    return ACHIEVEMENT_ICONS[achievementId];
  }
  
  // Partial matches
  for (const key of Object.keys(ACHIEVEMENT_ICONS)) {
    if (achievementId.includes(key)) {
      return ACHIEVEMENT_ICONS[key];
    }
  }
  
  return ACHIEVEMENT_ICONS.default;
};

/**
 * Get the color for an achievement
 * @param {string} achievementId - The achievement ID
 * @returns {string} - The color hex code
 */
export const getAchievementColor = (achievementId) => {
  // Direct match
  if (ACHIEVEMENT_COLORS[achievementId]) {
    return ACHIEVEMENT_COLORS[achievementId];
  }
  
  // Partial matches
  for (const key of Object.keys(ACHIEVEMENT_COLORS)) {
    if (achievementId.includes(key)) {
      return ACHIEVEMENT_COLORS[key];
    }
  }
  
  return ACHIEVEMENT_COLORS.default;
};

/**
 * Determine the category of an achievement
 * @param {string} achievementId - The achievement ID
 * @returns {string} - The category
 */
export const getAchievementCategory = (achievementId) => {
  if (achievementId.includes('level') || achievementId.includes('grinder') || 
      achievementId.includes('scholar') || achievementId.includes('master')) {
    return ACHIEVEMENT_CATEGORIES.LEVEL;
  } else if (achievementId.includes('coin')) {
    return ACHIEVEMENT_CATEGORIES.COINS;
  } else if (achievementId.includes('accuracy') || achievementId.includes('perfectionist') || 
             achievementId.includes('redemption')) {
    return ACHIEVEMENT_CATEGORIES.SCORE;
  } else if (achievementId.includes('answer') || achievementId.includes('question') || 
             achievementId.includes('encyclopedia')) {
    return ACHIEVEMENT_CATEGORIES.QUESTIONS;
  } else if (achievementId.includes('rookie') || achievementId.includes('test') || 
             achievementId.includes('trouble')) {
    return ACHIEVEMENT_CATEGORIES.TEST;
  }
  return ACHIEVEMENT_CATEGORIES.ALL;
};
</file>

<file path="src/constants/resourcesConstants.js">
// src/constants/resourcesConstants.js
// Contains all resource data for the app

export const CYBERSECURITY_TOOLS = [
  { name: 'Nmap', url: 'https://nmap.org/' },
  { name: 'Burp Suite', url: 'https://portswigger.net/burp' },
  { name: 'Wireshark', url: 'https://www.wireshark.org/' },
  { name: 'Nessus', url: 'https://www.tenable.com/products/nessus' },
  { name: 'Nikto', url: 'https://cirt.net/Nikto2' },
  { name: 'OWASP ZAP', url: 'https://www.zaproxy.org/' },
  { name: 'Metasploit', url: 'https://www.metasploit.com/' },
  { name: 'Hydra', url: 'https://github.com/vanhauser-thc/thc-hydra' },
  { name: 'John the Ripper', url: 'https://www.openwall.com/john/' },
  { name: 'Aircrack-ng', url: 'https://www.aircrack-ng.org/' },
  { name: 'SQLmap', url: 'https://sqlmap.org/' },
  { name: 'Mimikatz', url: 'https://github.com/gentilkiwi/mimikatz' },
  { name: 'Gobuster', url: 'https://github.com/OJ/gobuster' },
  { name: 'Hashcat', url: 'https://hashcat.net/hashcat/' },
  { name: 'Impacket', url: 'https://github.com/fortra/impacket' },
  { name: 'BloodHound', url: 'https://github.com/BloodHoundAD/BloodHound' },
  { name: 'Cuckoo Sandbox', url: 'https://cuckoosandbox.org/' },
  { name: 'Suricata', url: 'https://suricata.io/' },
  { name: 'Wfuzz', url: 'https://github.com/xmendez/wfuzz' },
  { name: 'OSSEC', url: 'https://www.ossec.net/' },
  { name: 'Acunetix', url: 'https://www.acunetix.com/' },
  { name: 'WPScan', url: 'https://wpscan.com/' },
  { name: 'SkipFish', url: 'https://github.com/spinkham/skipfish' },
  { name: 'Ncrack', url: 'https://github.com/nmap/ncrack' },
  { name: 'OWASP D4N155', url: 'https://github.com/OWASP/D4N155' },
  { name: 'Kismet', url: 'https://github.com/kismetwireless/kismet' },
  { name: 'Searchsploit', url: 'https://github.com/dev-angelist/Ethical-Hacking-Tools/blob/main/practical-ethical-hacker-notes/tools/searchsploit.md' },
  { name: 'Maltego', url: 'https://www.maltego.com/' },
  { name: 'legion', url: 'https://github.com/Abacus-Group-RTO/legion' },
  { name: 'recon-ng', url: 'https://github.com/lanmaster53/recon-ng' },
  { name: 'evil-winrm', url: 'https://github.com/Hackplayers/evil-winrm' },
  { name: 'Kali Linux tools', url: 'https://www.kali.org/tools/' },
  { name: 'Social-Engineer Toolkit (SET)', url: 'https://github.com/trustedsec/social-engineer-toolkit' },
  { name: 'Ghidra', url: 'https://ghidra-sre.org/' },
  { name: 'Binwalk', url: 'https://github.com/ReFirmLabs/binwalk' },
  { name: 'Volatility', url: 'https://www.volatilityfoundation.org/' },
  { name: 'Radare2', url: 'https://github.com/radareorg/radare2' },
  { name: 'BeEF (Browser Exploitation Framework)', url: 'https://github.com/beefproject/beef' },
  { name: 'Empire', url: 'https://github.com/EmpireProject/Empire' },
  { name: 'Bettercap', url: 'https://github.com/bettercap/bettercap' },
  { name: 'Responder', url: 'https://github.com/SpiderLabs/Responder' },
  { name: 'CrackMapExec', url: 'https://github.com/Porchetta-Industries/CrackMapExec' },
  { name: 'Fierce', url: 'https://github.com/mschwager/fierce' },
  { name: 'SSLstrip', url: 'https://github.com/moxie0/sslstrip' },
  { name: 'Ettercap', url: 'https://github.com/Ettercap/ettercap' },
  { name: 'Fiddler', url: 'https://www.telerik.com/fiddler' },
  { name: 'theHarvester', url: 'https://github.com/laramies/theHarvester' },
  { name: 'Wapiti', url: 'https://github.com/wapiti-scanner/wapiti' },
  { name: 'Arachni', url: 'https://github.com/Arachni/arachni' },
  { name: 'Shellter', url: 'https://www.shellterproject.com/' },
  { name: 'Yersinia', url: 'https://github.com/tomac/yersinia' },
  { name: 'Amass', url: 'https://github.com/owasp-amass/amass' },
  { name: 'mitmproxy', url: 'https://github.com/mitmproxy/mitmproxy' },
  { name: 'Nuclei', url: 'https://github.com/projectdiscovery/nuclei' },
  { name: 'Sublist3r', url: 'https://github.com/aboul3la/Sublist3r' },
  { name: 'EyeWitness', url: 'https://github.com/FortyNorthSecurity/EyeWitness' },
  { name: 'RouterSploit', url: 'https://github.com/threat9/routersploit' },
];

export const REDDIT_SUBREDDITS = [
  { name: 'r/CompTIA', url: 'https://www.reddit.com/r/CompTIA/' },
  { name: 'r/CyberSecurity', url: 'https://www.reddit.com/r/cybersecurity/' },
  { name: 'r/AskNetsec', url: 'https://www.reddit.com/r/AskNetsec/' },
  { name: 'r/Casp', url: 'https://www.reddit.com/r/casp/' },
  { name: 'r/ITCareerQuestions', url: 'https://www.reddit.com/r/ITCareerQuestions/' },
  { name: 'r/WGU', url: 'https://www.reddit.com/r/WGU/' },
  { name: 'r/CCNA', url: 'https://www.reddit.com/r/ccna/' },
  { name: 'r/sysadmin', url: 'https://www.reddit.com/r/sysadmin/' },
  { name: 'r/linuxquestions/', url: 'https://www.reddit.com/r/linuxquestions/' },
  { name: 'r/netsec', url: 'https://www.reddit.com/r/netsec/' },
  { name: 'r/ReverseEngineering', url: 'https://www.reddit.com/r/ReverseEngineering/' },
  { name: 'r/BlueTeamSec', url: 'https://www.reddit.com/r/BlueTeamSec/' },
  { name: 'r/RedTeam', url: 'https://www.reddit.com/r/RedTeam/' },
  { name: 'r/InformationSecurity', url: 'https://www.reddit.com/r/InformationSecurity/' },
  { name: 'r/ethicalhacking', url: 'https://www.reddit.com/r/ethicalhacking/' },
  { name: 'r/ITsecurity', url: 'https://www.reddit.com/r/ITsecurity/' },
  { name: 'r/netsecstudents', url: 'https://www.reddit.com/r/netsecstudents/' },
];

export const REDDIT_POSTS = [
  { name: 'Master List: I Compiled and Ranked Every Major Studying Resource for A+, Network+, and Security+ Here!', url: 'https://www.reddit.com/r/CompTIA/comments/i7hx4t/master_list_i_compiled_and_ranked_every_major/' },
  { name: 'How a dumdum like me passed sec+', url: 'https://www.reddit.com/r/CompTIA/comments/zkjs1d/how_a_dumdum_like_me_passed_sec/' },
  { name: 'How I passed COMPTIA A+ N+ S+', url: 'https://www.reddit.com/r/CompTIA/comments/1cra3cg/how_i_passed_comptia_a_n_s/' },
  { name: 'ChatGPT explained DHCP to me in gangsta terms', url: 'https://www.reddit.com/r/CompTIA/comments/11ytgbz/chatgpt_explained_dhcp_to_me_in_gangsta_terms/' },
  { name: 'Dont Pay for Udemy Courses, Access them for Free, Legally and Ethically', url: 'https://www.reddit.com/r/CompTIA/comments/12aug8f/dont_pay_for_udemy_courses_access_them_for_free/' },
  { name: 'For Those Of You Wondering if COMPTIA is Worth it; Just Do it', url: 'https://www.reddit.com/r/CompTIA/comments/1f11fbc/for_those_of_you_wondering_if_comptia_is_worth_it/' },
  { name: '[UPDATE] 34 years old, posted a month ago about passing the A+, no IT experience, no college degree -- just got hired today after 2 weeks of sending out resumes. Wanted to share my experience and tips.', url: 'https://www.reddit.com/r/CompTIA/comments/m38lb8/update_34_years_old_posted_a_month_ago_about/' },
  { name: 'Just passed Network+! How I did it...', url: 'https://www.reddit.com/r/CompTIA/comments/1gfmkqf/just_passed_network_how_i_did_it/' },
  { name: 'Just passed Network+, got the trifecta in about 6 months, study tips I learned that I want to share since everyone was so helpful on this sub.', url: 'https://www.reddit.com/r/CompTIA/comments/1fmjb2p/just_passed_network_got_the_trifecta_in_about_6/' },
  { name: 'I passed CASP+ - This is what I did to prepare', url: 'https://www.reddit.com/r/casp/comments/1ft2qjr/i_passed_casp_this_is_what_i_did_to_prepare/' },
  { name: 'PBQs guidance (comments)', url: 'https://www.reddit.com/r/casp/comments/1cuhbmw/pbqs_guidance/' },
  { name: 'Passed Sec+, Pentest+, CYSA+ in 2 months 22 days without prior experience or any other certs. My detailed study path below.', url: 'https://www.reddit.com/r/CompTIA/comments/1f5cofp/passed_sec_pentest_cysa_in_2_months_22_days/' },
  { name: 'General advice from a hiring manager and 23 year industry veteran to newbies', url: 'https://www.reddit.com/r/ITCareerQuestions/comments/ni4vnm/general_advice_from_a_hiring_manager_and_23_year/' },
];

export const YOUTUBE_CHANNELS = [
  { name: 'Professor Messer', url: 'https://www.youtube.com/@professormesser' },
  { name: 'NetworkChuck', url: 'https://www.youtube.com/@NetworkChuck' },
  { name: 'PowerCertAnimatedVideos', url: 'https://www.youtube.com/@PowerCertAnimatedVideos' },
  { name: 'HackerSploit', url: 'https://www.youtube.com/@HackerSploit' },
  { name: 'Cyberkraft', url: 'https://www.youtube.com/@cyberkraft' },
  { name: 'howtonetwork', url: 'https://www.youtube.com/@howtonetworkcom' },
  { name: 'MyCS1', url: 'https://www.youtube.com/@MyCS1/videos' },
  { name: 'CBT Nuggets', url: 'https://www.youtube.com/user/cbtnuggets' },
  { name: 'Eli the Computer Guy', url: 'https://www.youtube.com/user/elithecomputerguy' },
  { name: 'The Cyber Mentor', url: 'https://www.youtube.com/channel/UC0ArlFuFYMpEewyRBzdLHiw' },
  { name: 'ITProTV', url: 'https://www.youtube.com/user/ITProTV' },
  { name: 'freeCodeCamp.org', url: 'https://www.youtube.com/freecodecamp' },
  { name: 'With Sandra', url: 'https://www.youtube.com/@WithSandra' },
  { name: 'Andrew Huberman', url: 'https://www.youtube.com/@hubermanlab' },
  { name: 'The Cyberboy', url: 'https://www.youtube.com/@the_cyb3rb0y' },
  { name: 'Tech with Jono', url: 'https://www.youtube.com/@TechwithJono' },
  { name: 'Whitesec cyber security', url: 'https://www.youtube.com/@whiteseccybersecurity' },
  { name: 'Practical Networking', url: 'https://www.youtube.com/@PracticalNetworking' },
  { name: 'IT k Funde', url: 'https://www.youtube.com/@ITkFunde' },
  { name: 'Mad Hat', url: 'https://www.youtube.com/@madhatistaken' },
  { name: 'SomeOrdinaryGamers', url: 'https://www.youtube.com/@SomeOrdinaryGamers' },
  { name: 'TheBeardedITDad', url: 'https://www.youtube.com/@TheBeardedITDad' },
];

export const YOUTUBE_VIDEOS = [
  { name: 'How to Pass your 220-1101 and 220-1102 A+ Exams - CompTIA A+ 220-1101', url: 'https://www.youtube.com/watch?v=87t6P5ZHTP0&list=PLG49S3nxzAnnOmvg5UGVenB_qQgsh01uC' },
  { name: 'CompTIA A+ Full Course - FREE - [31+ Hours]', url: 'https://www.youtube.com/watch?v=1CZXXNKAY5o&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=5' },
  { name: 'CompTIA A+ Certification Practice Test 2024 (Exam 220-1101) (40 Questions with Explained Answers)', url: 'https://www.youtube.com/watch?v=e16It3eYHgc&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=10' },
  { name: 'How to Pass Your N10-008 Network+ Exam', url: 'https://www.youtube.com/watch?v=As6g6IXcVa4&list=PLG49S3nxzAnlCJiCrOYuRYb6cne864a7G' },
  { name: 'Computer Networking Course - Network Engineering [CompTIA Network+ Exam Prep]', url: 'https://www.youtube.com/watch?v=qiQR5rTSshw&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=6' },
  { name: 'Networking basics (2024) | What is a switch, router, gateway, subnet, gateway, firewall & DMZ', url: 'https://www.youtube.com/watch?v=_IOZ8_cPgu8&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=7' },
  { name: 'How to Pass Your SY0-701 Security+ Exam', url: 'https://www.youtube.com/watch?v=KiEptGbnEBc&list=PLG49S3nxzAnl4QDVqK-hOnoqcSKEIDDuv' },
  { name: 'Security+ Certification SY0-701 50 Practice Questions', url: 'https://www.youtube.com/watch?v=yPqSLJG8Rt0&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=2' },
  { name: 'CompTIA Security+ SY0-701. 50 Exam Practice Question', url: 'https://www.youtube.com/watch?v=2qrPJbL9G6c&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=14' },
  { name: 'CompTIA Security+ SY0-701 - Series Intro & Exam Prep Strategy', url: 'https://www.youtube.com/watch?v=1E7pI7PB4KI&list=PL7XJSuT7Dq_UDJgYoQGIW9viwM5hc4C7n' },
  { name: 'CompTIA CySA+ // 2024 Crash Course // 10+ Hours for FREE', url: 'https://www.youtube.com/watch?v=qP9x0mucwVc&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=9' },
  { name: 'COMPTIA Pentest+ Course Preparation TryHackMe', url: 'https://www.youtube.com/watch?v=cADW_cUJni0&list=PLqM63j87R5p4olmWpzqaXMhEP2zEnQhPD' },
  { name: 'What is Subnetting? - Subnetting Mastery  NOTE: I HIGHLY RECOMMEND!', url: 'https://www.youtube.com/watch?v=BWZ-MHIhqjM&list=PLIFyRwBY_4bQUE4IB5c4VPRyDoLgOdExE' },
  { name: 'IT Security Certifications: CySA+ vs PenTest+ vs CISSP', url: 'https://www.youtube.com/watch?v=YhCvNARSPo4' },
  { name: 'Ethical Hacking in 15 Hours - 2023 Edition - Learn to Hack! (Part 1)', url: 'https://www.youtube.com/watch?v=3FNYvj2U0HM&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=13' },
  { name: 'Paypal - Live bug bounty hunting on Hackerone | Live Recon | part 2', url: 'https://www.youtube.com/watch?v=Dtx4kNXj0OQ&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=11' },
  { name: 'Complete Ethical hacking course 16 hours | ethical hacking full course with practical | Zero to Hero', url: 'https://www.youtube.com/watch?v=w_oxcjPOWos&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=4' },
  { name: 'Full Ethical Hacking Course - Network Penetration Testing for Beginners (2019)', url: 'https://www.youtube.com/watch?v=3Kq1MIfTWCE&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=3' },
  { name: 'How to Get an IT Job Without Experience', url: 'https://www.youtube.com/watch?v=XkTNQCtuRPY&list=PLG49S3nxzAnkUvxTH_ANPYQWGo9wYlz7h' },
  { name: 'Start your IT Career with the CompTIA Trifecta? A+, Net+, Sec+', url: 'https://www.youtube.com/watch?v=IBKW0s20T8o&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=12' },
  { name: 'How I Would Learn Cyber Security if I Could Start Over in 2024 (Beginner Roadmap)', url: 'https://www.youtube.com/watch?v=b12JrM-6DBY&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=15' },
  { name: 'Network Protocols - ARP, FTP, SMTP, HTTP, SSL, TLS, HTTPS, DNS, DHCP - Networking Fundamentals - L6', url: 'https://www.youtube.com/watch?v=E5bSumTAHZE&list=PLejqXniG-4qmFqpxbWd7Oo235uH1ffG2x&index=16' },
  { name: 'Network Devices - Hosts, IP Addresses, Networks - Networking Fundamentals', url: 'https://www.youtube.com/watch?v=bj-Yfakjllc&list=PLIFyRwBY_4bRLmKfP1KnZA6rZbRHtxmXi' },
  { name: 'Python Full Course for free 🐍 (2024)', url: 'https://www.youtube.com/watch?v=ix9cRaBkVe0' },
  { name: 'Optimal Protocols for Studying & Learning', url: 'https://youtu.be/ddq8JIMhz7c?si=qT00KFkFBAwm7LP7' },
  { name: 'How to Study & Learn Using Active Recall | Dr. Cal Newport & Dr. Andrew Huberman', url: 'https://youtu.be/mzexJPoXBCM?si=sv-yeuIoLF9pwDRG' },
  { name: 'How to Learn Faster by Using Failures, Movement & Balance | Huberman Lab Essentials', url: 'https://youtu.be/jwChiek_aRY?si=3kyPbIAVwJWMPfnG' },
  { name: 'Best FREE Beginner Cybersecurity Courses for 2025 | Best Cybersecurity Training for Beginners 2025', url: 'https://youtu.be/SwisCiNA9eI?si=3HlXVljXHWgHhc0F' },
  { name: 'IBM IT Support - Complete Course | IT Support Technician - Full Course', url: 'https://www.youtube.com/watch?v=BNbPsiCGQzw' },
  { name: 'What is the A+ Certification? How You Can Get A+ Certified', url: 'https://www.youtube.com/watch?v=IlKRm_8EmP0' },
  { name: 'CompTIA CASP+ PBQ', url: 'https://www.youtube.com/live/eInvTuYBF3Q?si=Hbe4mWLd3X31AUkA' },
  { name: 'CompTIA Security+ 701 PBQ', url: 'https://youtu.be/zfwxSmL4n6w?si=q5lXlvmViTK6TnSI' },
  { name: 'CompTIA CySa+ PBQ', url: 'https://www.youtube.com/live/0NMffWaxlmA?si=Rm9IBkZ04OAxFJtp' },
  { name: 'CompTIA Network+ PBQ', url: 'https://www.youtube.com/live/9cdL214y-u0?si=lCSxriFy636PbOnR' },
  { name: 'CASP+ course', url: 'https://www.youtube.com/watch?v=vwNjLVpXNzk&list=PLCNmoXT8zexnJtDOdd8Owa8TAdSVVWF-J' },
  { name: 'NMAP Full Guide', url: 'https://www.youtube.com/watch?v=JHAMj2vN2oU&t=33s' },
];

export const UDEMY_COURSES = [
  { name: 'CompTIA Security+ (SY0-701) Complete Course & Exam', url: 'https://www.udemy.com/course/securityplus' },
  { name: 'CompTIA Security+ (SY0-701) Practice Exams Set 1', url: 'https://www.udemy.com/course/comptia-security-sy0-701-practice-exams/' },
  { name: 'CompTIA Security+ (SY0-701) Practice Exams Set 2', url: 'https://www.udemy.com/course/comptia-security-sy0-701-practice-exams-2nd-edition/' },
  { name: 'TOTAL: CompTIA Security+ Certification Course + Exam SY0-701', url: 'https://www.udemy.com/course/total-comptia-security-plus/' },
  { name: 'CompTIA A+ Core 1 (220-1101) Complete Course & Practice Exam', url: 'https://www.udemy.com/course/comptia-a-core-1/' },
  { name: 'CompTIA A+ Core 2 (220-1102) Complete Course & Practice Exam', url: 'https://www.udemy.com/course/comptia-a-core-2/' },
  { name: 'CompTIA A+ (220-1101) Core 1 Practice Exams *New for 2023*', url: 'https://www.udemy.com/course/comptia-a-220-1101-core-1-practice-exams-new-for-2022/' },
  { name: 'CompTIA A+ (220-1102) Core 2 Practice Exams *New for 2023*', url: 'https://www.udemy.com/course/comptia-a-220-1102-core-2-practice-exams-new-for-2022/' },
  { name: 'CompTIA A+ Core 1 & Core 2 - IT Cert Doctor - 2024', url: 'https://www.udemy.com/course/it-cert-doctor-comptia-a-220-1101-1102/' },
  { name: 'TOTAL: CompTIA A+ Core 2 (220-1102) Course + Exam', url: 'https://www.udemy.com/course/comptia-aplus-core-2/' },
  { name: 'TOTAL: CompTIA A+ Core 1 (220-1101) Course + Exam', url: 'https://www.udemy.com/course/comptia-aplus-core-1/' },
  { name: 'CompTIA Network+ (N10-009) Full Course & Practice Exam', url: 'https://www.udemy.com/course/comptia-network-009/' },
  { name: 'CompTIA Network+ (N10-009) 6 Full Practice Exams Set 1', url: 'https://www.udemy.com/course/comptia-network-n10-009-6-practice-exams-and-pbqs-set-1/' },
  { name: 'CompTIA Network+ (N10-009) 6 Full Practice Exams Set 2', url: 'https://www.udemy.com/course/comptia-network-n10-009-6-practice-exams-and-pbqs-set-2/' },
  { name: 'TOTAL: CompTIA Network+ (N10-008) Course + Exam', url: 'https://www.udemy.com/course/comptia-networkplus-certification/' },
  { name: 'CompTIA CySA+ (CS0-003) Complete Course & Practice Exam', url: 'https://www.udemy.com/course/comptia-cysa-003/' },
  { name: 'CompTIA CySA+ (CS0-003) Practice Exams', url: 'https://www.udemy.com/course/comptia-cysa-cs0-003-practice-exams/' },
  { name: 'CompTIA PenTest+ (PT0-003) Full Course & Practice Exam', url: 'https://www.udemy.com/course/pentestplus/' },
  { name: 'CompTIA PenTest+ (PT0-003) 6 Practice Exams', url: 'https://www.udemy.com/course/comptia-pentest-pt0-003-6-practice-exams/' },
  { name: 'CompTIA PenTest+ (PT0-002) Practice Certification Exams', url: 'https://www.udemy.com/course/comptia-pentest-exams-002/' },
  { name: 'CompTIA SecurityX (CAS-005) Complete Course & Practice Exam', url: 'https://www.udemy.com/course/casp-plus/' },
  { name: 'CompTIA SecurityX (CAS-005) Practice Exam Prep *NEW', url: 'https://www.udemy.com/course/comptia-securityx-practice-exam-prep-new/' },
  { name: 'CASP+ (CAS-004) Full-length Practice Certification Exams', url: 'https://www.udemy.com/course/casp-exams-004/' },
  { name: 'CompTIA Linux+ (XK0-005) Complete Course & Exam', url: 'https://www.udemy.com/course/comptia-linux/' },
  { name: 'CompTIA Linux+ (XK0-005) Practice Exams & Simulated PBQs', url: 'https://www.udemy.com/course/comptia-linux-exams/' },
  { name: 'TOTAL: Cloud Computing / CompTIA Cloud+ (CV0-003)', url: 'https://www.udemy.com/course/total-cloud-computing-comptia-cloud-cert-cv0-002/' },
  { name: 'TOTAL: CompTIA Cloud+ (CV0-003): 4 Practice Tests', url: 'https://www.udemy.com/course/total-comptia-cloud-cv0-003-4-practice-tests/' },
  { name: 'CompTIA Cloud+ (CV0-004) Practice Exam Prep *NEW*', url: 'https://www.udemy.com/course/comptia-cloud-plus-practice-exam-prep-course/' },
  { name: 'CompTIA Cloud Essentials+ (CL0-002) Complete Course & Exam', url: 'https://www.udemy.com/course/cloud-essentials-course' },
  { name: 'CompTIA Cloud Essentials+ (CL0-002) Practice Exams', url: 'https://www.udemy.com/course/cloud-essentials-exams/' },
  { name: 'CompTIA Project+ (PK0-005) Practice Exams', url: 'https://www.udemy.com/course/comptia-project-pk0-005-complete-course-practice-exam/' },
  { name: 'CompTIA Data+ (DA0-001) Practice Certification Exams', url: 'https://www.udemy.com/course/comptia-data/' },
  { name: 'CompTIA Server+ | CompTIA Server+ SK0-005 Certification Prep', url: 'https://www.udemy.com/course/comptia-server-comptia-server-sk0-005-certification-prep/' },
  { name: 'TOTAL: CompTIA Server+ (SK0-005): 4 Practice Tests 200 Qs', url: 'https://www.udemy.com/course/total-comptia-server-sk0-005-4-practice-tests-200qs/' },
  { name: 'CompTIA IT Fundamentals (FCO-U61) Complete Course & Exam', url: 'https://www.udemy.com/course/comptia-it-fundamentals-fco-u61-complete-course-exam/' },
  { name: 'CompTIA IT Fundamentals (FCO-U61) Six Practice Exams', url: 'https://www.udemy.com/course/comptia-it-fundamentals-fco-u61-six-practice-exams/' },
  { name: 'TOTAL: CompTIA Tech+ (FC0-U71)', url: 'https://www.udemy.com/course/it-fundamentals-fc0-u61-the-total-course/' },
  { name: 'CompTIA Tech+ (FC0-U71) Complete Course & Exam', url: 'https://www.udemy.com/course/comptia-tech-fc0-u71-complete-course-exam/' },
  { name: 'ISC2 CISSP Full Course & Practice Exam', url: 'https://www.udemy.com/course/isc2-cissp-full-course-practice-exam/' },
  { name: 'ISC2 CISSP 6 Practice Exams', url: 'https://www.udemy.com/course/isc2-cissp-6-practice-exams/' },
  { name: 'The Complete Certified in Cybersecurity CC course ISC2 2024', url: 'https://www.udemy.com/course/certifiedincybersecurity/' },
  { name: 'The Complete Cyber Security Course : Hackers Exposed!', url: 'https://www.udemy.com/course/the-complete-internet-security-privacy-course-volume-1/' },
  { name: 'The Complete Cyber Security Course : Network Security!', url: 'https://www.udemy.com/course/network-security-course/' },
  { name: 'The Complete Cyber Security Course : End Point Protection!', url: 'https://www.udemy.com/course/the-complete-cyber-security-course-end-point-protection/' },
  { name: 'Complete Ethical Hacking & Cyber Security Masterclass Course', url: 'https://www.udemy.com/course/ethicalhackingcourse/' },
  { name: 'Implementing the NIST Cybersecurity Framework (CSF)', url: 'https://www.udemy.com/course/nist-cybersecurity-framework/' },
  { name: 'Notes!! - CompTIA A+, Network+ and Security+ (Mike Meyers)', url: 'https://www.udemy.com/course/comptia-a-1001-1002-study-notes/' },
];

export const LINKEDIN_PEOPLE = [
  { name: 'Mike Chapple', url: 'https://www.linkedin.com/in/mikechapple/' },
  { name: 'Brian Krebs', url: 'https://www.linkedin.com/in/bkrebs/' },
  { name: 'Dale Meredith Jr', url: 'https://www.linkedin.com/in/dalemeredith/' },
  { name: 'Troy Hunt', url: 'https://www.linkedin.com/in/troyhunt/' },
  { name: 'Heath Adams', url: 'https://www.linkedin.com/in/heathadams/' },
  { name: 'Jason Dion', url: 'https://www.linkedin.com/in/jasondion/' },
  { name: 'Naomi Buckwalter', url: 'https://www.linkedin.com/in/naomi-buckwalter/' },
  { name: 'Shira Rubinoff', url: 'https://www.linkedin.com/in/shirarubinoff/' },
  { name: 'OWASP', url: 'https://www.linkedin.com/company/owasp/' },
  { name: 'COMPTIA', url: 'https://www.linkedin.com/company/comptia/posts/?feedView=all' },
  { name: 'SANS', url: 'https://www.linkedin.com/company/sans-institute/' },
  { name: 'ISACA', url: 'https://www.linkedin.com/company/isaca/' },
  { name: 'ISC2', url: 'https://www.linkedin.com/company/isc2/' },
  { name: 'SANS', url: 'https://www.linkedin.com/company/sans-institute/' },
  { name: 'Chuck Brooks', url: 'https://www.linkedin.com/in/chuckbrooks/' },
  { name: 'Steve Morgan', url: 'https://www.linkedin.com/in/cybersecuritysf/' },
];

export const OTHER_RESOURCES = [
  { name: 'CertNova (free practice tests highly recommend)', url: 'https://www.certnova.com/' },
  { name: '*VERY IMPORTANT FOR CASP* -wyzguyscybersecurity blog', url: 'https://wyzguyscybersecurity.com/new-insights-for-the-casp-cas-004-exam/' },
  { name: '50% vouchers for students', url: 'https://academic-store.comptia.org/' },
  { name: 'Official CompTIA Resources', url: 'https://www.comptia.org/resources' },
  { name: 'Cybrary', url: 'https://www.cybrary.it' },
  { name: 'OWASP Official Site', url: 'https://owasp.org' },
  { name: 'Pluralsight', url: 'https://www.pluralsight.com/' },
  { name: 'Krebs on Security', url: 'https://krebsonsecurity.com/' },
  { name: 'Dark Reading', url: 'https://www.darkreading.com/' },
  { name: 'SANS Institute', url: 'https://www.sans.org/' },
  { name: 'InfoSec Institute', url: 'https://www.infosecinstitute.com/' },
  { name: 'Hack The Box', url: 'https://www.hackthebox.com/' },
  { name: 'TryHackMe', url: 'https://tryhackme.com/' },
  { name: 'Infosec Skills', url: 'https://www.infosecinstitute.com/skills/' },
  { name: 'Offensive Security (OffSec)', url: 'https://www.offensive-security.com/' },
  { name: 'Rapid7 Blog', url: 'https://www.rapid7.com/blog/' },
  { name: 'Malwarebytes Labs', url: 'https://blog.malwarebytes.com/' },
  { name: 'nmap.org', url: 'https://nmap.org/' },
  { name: 'Professor Messer Website', url: 'https://www.professormesser.com/' },
  { name: 'linkedin Learning', url: 'https://www.linkedin.com/learning/' },
  { name: 'SYBEX Books', url: 'https://www.amazon.com/s?k=wiley+sybex+comptia' },
  { name: 'Mike Meyers practice tests', url: 'https://www.totalsem.com/total-tester-practice-tests/' },
  { name: 'Quizlet', url: 'https://quizlet.com/' },
  { name: 'CBTnuggets', url: 'https://www.cbtnuggets.com/' },
  { name: 'Free Virtual Machine', url: 'https://www.oracle.com/virtualization/technologies/vm/downloads/virtualbox-downloads.html' },
  { name: 'kali Linux', url: 'https://www.kali.org/' },
  { name: 'Ubuntu', url: 'https://ubuntu.com/' },
  { name: 'Red Hat', url: 'https://www.redhat.com/en' },
  { name: 'Github', url: 'https://github.com/' },
  { name: 'comptia.org', url: 'https://www.comptia.org/' },
  { name: 'ITPRO', url: 'https://www.acilearning.com/itpro/' },
  { name: 'Coursera', url: 'https://www.coursera.org/' },
  { name: 'TestOut', url: 'https://testoutce.com/' },
  { name: 'ExamDigest', url: 'https://examsdigest.com/' },
  { name: 'ExamCompass', url: 'https://www.examcompass.com/' },
];

export const COMPTIA_OBJECTIVES = [
  { name: 'A+ Core 1', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-a-220-1101-exam-objectives-(3-0)' },
  { name: 'A+ Core 2', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-a-220-1102-exam-objectives-(3-0)' },
  { name: 'Network+ (N10-009)', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-network-n10-009-exam-objectives-(4-0)' },
  { name: 'Security+ (701)', url: 'https://certblaster.com/wp-content/uploads/2023/11/CompTIA-Security-SY0-701-Exam-Objectives-1.pdf' },
  { name: 'CySA+ (003)', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-cysa-cs0-003-exam-objectives-2-0.pdf' },
  { name: 'CASP+ (004)', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-casp-cas-004-exam-objectives-(4-0)' },
  { name: 'PenTest+ (002)', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-pentest-pt0-002-exam-objectives-(4-0)' },
  { name: 'Cloud+ (003)', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-cloud-cv0-003-exam-objectives-(1-0)#:~:text=%EE%80%80CompTIA%EE%80%81%20exams%20result%20from%20subject%20matter' },
  { name: 'Cloud Essentials', url: 'https://partners.comptia.org/docs/default-source/resources/cloud-essentials-certification-guide' },
  { name: 'Linux+ (005)', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-linux-xk0-005-exam-objectives-(1-0)' },
  { name: 'Data+ (001)', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-data-da0-001-exam-objectives-(2-0)' },
  { name: 'DataSys+', url: 'https://partners.comptia.org/certifications/datasys' },
  { name: 'DataX+', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-datax-dy0-001-exam-objectives-(5-0)' },
  { name: 'Server+ (005)', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-server-sk0-005-exam-objectives' },
  { name: 'Project+ (005)', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-project-pk0-005-exam-objectives-(2-0)' },
  { name: 'ITF', url: 'https://www.comptia.jp/pdf/CompTIA%20IT%20Fundamentals%20FC0-U61%20Exam%20Objectives.pdf' },
  { name: 'Tech+', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-tech-fc0-u71-exam-objectives-(1-2)' },
  { name: 'SecurityX (CASP 005)', url: 'https://partners.comptia.org/docs/default-source/resources/comptia-securityx-cas-005-exam-objectives-(3-0)' },
];

export const SECURITY_FRAMEWORKS = [
  { name: 'NIST Cybersecurity Framework', url: 'https://www.nist.gov/cyberframework' },
  { name: 'ISO/IEC 27001', url: 'https://www.iso.org/isoiec-27001-information-security.html' },
  { name: 'Lockheed Martin Cyber Kill Chain', url: 'https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html' },
  { name: 'MITRE ATT&CK Framework', url: 'https://attack.mitre.org/' },
  { name: 'OWASP Top 10', url: 'https://owasp.org/www-project-top-ten/' },
  { name: 'COBIT', url: 'https://www.isaca.org/resources/cobit' },
  { name: 'ITIL (Information Technology Infrastructure Library)', url: 'https://www.itlibrary.org/' },
  { name: 'PCI-DSS (Payment Card Industry Data Security Standard)', url: 'https://www.pcisecuritystandards.org/' },
  { name: 'HIPAA Security Rule', url: 'https://www.hhs.gov/hipaa/for-professionals/security/index.html' },
  { name: 'Sarbanes-Oxley (SOX) IT Controls', url: 'https://www.sarbanes-oxley-101.com/sarbanes-oxley-compliance.htm' },
  { name: 'FedRAMP', url: 'https://www.fedramp.gov/' },
  { name: 'CIS Controls', url: 'https://www.cisecurity.org/controls' },
  { name: 'ENISA (European Union Agency for Cybersecurity) Guidelines', url: 'https://www.enisa.europa.eu/' },
  { name: 'SANS Top 20 Critical Controls', url: 'https://www.cm-alliance.com/consultancy/compliance-gap-analysis/sans-top-20-controls/' },
  { name: 'Cybersecurity Maturity Model Certification (CMMC)', url: 'https://www.acq.osd.mil/cmmc/' },
  { name: 'FISMA (Federal Information Security Management Act)', url: 'https://www.cisa.gov/topics/cyber-threats-and-advisories/federal-information-security-modernization-act' },
  { name: 'NERC CIP', url: 'https://www.nerc.com/pa/CI/tpv5impmntnstdy/CIPV5_FAQs_Consolidated_Oct2015_Oct_13_2015.pdf' },
  { name: 'GDPR (General Data Protection Regulation)', url: 'https://gdpr.eu/' },
  { name: 'HITRUST CSF', url: 'https://hitrustalliance.net/' },
  { name: 'ISO/IEC 27002', url: 'https://www.iso.org/standard/73906.html' },
  { name: 'NIST 800-53 Security Controls', url: 'https://csrc.nist.gov/publications/detail/sp/800-53/rev-5/final' },
  { name: 'NIST 800-171', url: 'https://csrc.nist.gov/publications/detail/sp/800-171/rev-2/final' },
  { name: 'Unified Kill Chain', url: 'https://www.unifiedkillchain.com/assets/The-Unified-Kill-Chain.pdf' },
  { name: 'VERIS', url: 'http://veriscommunity.net/' },
  { name: 'Diamond Model of Intrusion Analysis', url: 'https://www.threatintel.academy/wp-content/uploads/2020/07/diamond-model.pdf' },
  { name: 'ATT&CK for ICS', url: 'https://collaborate.mitre.org/attackics/index.php/Main_Page' },
  { name: 'SOC2', url: 'https://www.vanta.com/products/soc-2' },
  { name: 'ISO 22301 (Business Continuity)', url: 'https://www.iso.org/iso-22301-business-continuity.html' },
  { name: 'ISO/IEC 27004 (Information Security Management — Monitoring, Measurement, Analysis, and Evaluation)', url: 'https://www.iso.org/standard/42505.html' },
  { name: 'Zero Trust Architecture', url: 'https://csrc.nist.gov/publications/detail/sp/800-207/final' },
  { name: 'MITRE Shield', url: 'https://shield.mitre.org/' },
  { name: 'MITRE Engage', url: 'https://engage.mitre.org/' },
  { name: 'NIST Cybersecurity Workforce Framework', url: 'https://www.nist.gov/cyberframework/workforce' },
];

// Resource categories for UI display
export const RESOURCE_CATEGORIES = [
  { id: 'all', name: 'All Resources', iconName: 'bookmark-outline' },
  { id: 'reddit', name: 'Reddit', iconName: 'logo-reddit' },
  { id: 'youtube', name: 'YouTube', iconName: 'logo-youtube' },
  { id: 'udemy', name: 'Udemy Courses', iconName: 'school-outline' },
  { id: 'tools', name: 'Security Tools', iconName: 'construct-outline' },
  { id: 'frameworks', name: 'Security Frameworks', iconName: 'shield-outline' },
  { id: 'comptia', name: 'CompTIA Objectives', iconName: 'document-text-outline' },
  { id: 'linkedin', name: 'LinkedIn Pros', iconName: 'logo-linkedin' },
  { id: 'other', name: 'Other Resources', iconName: 'link-outline' },
];

// Certification categories for UI display
export const CERT_CATEGORIES = [
  { id: 'aplus', name: 'A+', iconName: 'laptop-outline' },
  { id: 'nplus', name: 'Network+', iconName: 'git-network-outline' },
  { id: 'secplus', name: 'Security+', iconName: 'lock-closed-outline' },
  { id: 'cysa', name: 'CySA+', iconName: 'shield-checkmark-outline' },
  { id: 'casp', name: 'SecurityX/CASP+', iconName: 'shield-outline' },
  { id: 'pentest', name: 'PenTest+', iconName: 'code-outline' },
  { id: 'cloud', name: 'Cloud+', iconName: 'cloud-outline' },
  { id: 'linux', name: 'Linux+', iconName: 'terminal-outline' },
  { id: 'data', name: 'Data+', iconName: 'bar-chart-outline' },
  { id: 'server', name: 'Server+', iconName: 'server-outline' },
  { id: 'project', name: 'Project+', iconName: 'git-branch-outline' },
  { id: 'itf', name: 'ITF/TECH+', iconName: 'laptop-outline' },
];

// Create resources data structure for the app
export const RESOURCES_DATA = {
  all: [
    ...CYBERSECURITY_TOOLS,
    ...REDDIT_SUBREDDITS,
    ...REDDIT_POSTS,
    ...YOUTUBE_CHANNELS,
    ...YOUTUBE_VIDEOS,
    ...UDEMY_COURSES,
    ...LINKEDIN_PEOPLE,
    ...OTHER_RESOURCES,
    ...COMPTIA_OBJECTIVES,
    ...SECURITY_FRAMEWORKS,
  ],
  reddit: [...REDDIT_SUBREDDITS, ...REDDIT_POSTS],
  youtube: [...YOUTUBE_CHANNELS, ...YOUTUBE_VIDEOS],
  udemy: UDEMY_COURSES,
  tools: CYBERSECURITY_TOOLS,
  frameworks: SECURITY_FRAMEWORKS,
  comptia: COMPTIA_OBJECTIVES,
  linkedin: LINKEDIN_PEOPLE,
  other: OTHER_RESOURCES,
  
  // Cert-specific collections (created by filtering from all resources)
  aplus: [
    ...COMPTIA_OBJECTIVES.filter(obj => obj.name.toLowerCase().includes('a+ core')),
    ...YOUTUBE_VIDEOS.filter(vid => vid.name.toLowerCase().includes('a+') || vid.name.toLowerCase().includes('220-110')),
    ...UDEMY_COURSES.filter(course => course.name.toLowerCase().includes('a+') || course.name.toLowerCase().includes('220-110')),
    // Add more A+ specific resources
  ],
  
  nplus: [
    ...COMPTIA_OBJECTIVES.filter(obj => obj.name.toLowerCase().includes('network+')),
    ...YOUTUBE_VIDEOS.filter(vid => vid.name.toLowerCase().includes('network+') || vid.name.toLowerCase().includes('n10-0')),
    ...UDEMY_COURSES.filter(course => course.name.toLowerCase().includes('network+') || course.name.toLowerCase().includes('n10-0')),
    // Add more Network+ specific resources
  ],
  
  secplus: [
    ...COMPTIA_OBJECTIVES.filter(obj => obj.name.toLowerCase().includes('security+') && !obj.name.toLowerCase().includes('x')),
    ...YOUTUBE_VIDEOS.filter(vid => vid.name.toLowerCase().includes('security+') || vid.name.toLowerCase().includes('sy0-7')),
    ...UDEMY_COURSES.filter(course => course.name.toLowerCase().includes('security+') || course.name.toLowerCase().includes('sy0-7')),
    // Add more Security+ specific resources
  ],
  
  // Additional cert categories follow the same pattern...
  cysa: [
    ...COMPTIA_OBJECTIVES.filter(obj => obj.name.toLowerCase().includes('cysa+')),
    ...YOUTUBE_VIDEOS.filter(vid => vid.name.toLowerCase().includes('cysa') || vid.name.toLowerCase().includes('cs0-0')),
    ...UDEMY_COURSES.filter(course => course.name.toLowerCase().includes('cysa') || course.name.toLowerCase().includes('cs0-0')),
  ],
  
  casp: [
    ...COMPTIA_OBJECTIVES.filter(obj => obj.name.toLowerCase().includes('casp') || obj.name.toLowerCase().includes('securityx')),
    ...YOUTUBE_VIDEOS.filter(vid => vid.name.toLowerCase().includes('casp') || vid.name.toLowerCase().includes('cas-00')),
    ...UDEMY_COURSES.filter(course => course.name.toLowerCase().includes('casp') || course.name.toLowerCase().includes('securityx')),
  ],
  
  pentest: [
    ...COMPTIA_OBJECTIVES.filter(obj => obj.name.toLowerCase().includes('pentest+')),
    ...YOUTUBE_VIDEOS.filter(vid => vid.name.toLowerCase().includes('pentest') || vid.name.toLowerCase().includes('pt0-00')),
    ...UDEMY_COURSES.filter(course => course.name.toLowerCase().includes('pentest') || course.name.toLowerCase().includes('pt0-00')),
    ...CYBERSECURITY_TOOLS.filter(tool => 
      ['nmap', 'burp suite', 'metasploit', 'hydra', 'john the ripper', 'nikto', 'sqlmap', 
       'mimikatz', 'gobuster', 'hashcat', 'impacket', 'aircrack-ng', 'owasp zap'].includes(tool.name.toLowerCase())
    ),
  ],
  
  // Add more categories as needed
};
</file>

<file path="src/constants/supportConstants.js">
// src/constants/supportConstants.js

// Thread status types
export const THREAD_STATUS = {
  OPEN: 'open',
  PENDING: 'pending',
  RESOLVED: 'resolved',
  CLOSED: 'closed',
};

// Status display information
export const STATUS_INFO = {
  open: {
    label: 'Open',
    color: '#2ebb77', // Green
    iconName: 'radio-button-on',
  },
  pending: {
    label: 'Pending',
    color: '#ffc107', // Amber
    iconName: 'hourglass',
  },
  resolved: {
    label: 'Resolved',
    color: '#3498db', // Blue
    iconName: 'checkmark-circle',
  },
  closed: {
    label: 'Closed',
    color: '#9da8b9', // Gray
    iconName: 'lock-closed',
  },
};

// Socket events
export const SOCKET_EVENTS = {
  CONNECT: 'connect',
  DISCONNECT: 'disconnect',
  CONNECT_ERROR: 'connect_error',
  JOIN_THREAD: 'join_thread',
  LEAVE_THREAD: 'leave_thread',
  JOIN_USER_ROOM: 'join_user_room',
  NEW_MESSAGE: 'new_message',
  NEW_THREAD: 'new_thread',
  USER_TYPING: 'user_typing',
  USER_STOP_TYPING: 'user_stop_typing',
  ADMIN_TYPING: 'admin_typing',
  ADMIN_STOP_TYPING: 'admin_stop_typing',
};

// Connection status
export const CONNECTION_STATUS = {
  CONNECTED: 'connected',
  DISCONNECTED: 'disconnected',
  ERROR: 'error',
};

// Error messages
export const ERROR_MESSAGES = {
  FETCH_THREADS: 'Failed to load your conversations. Please try again.',
  CREATE_THREAD: 'Failed to create a new conversation. Please try again.',
  LOAD_MESSAGES: 'Failed to load messages. Please try again.',
  SEND_MESSAGE: 'Failed to send your message. Please try again.',
  CLOSE_THREAD: 'Failed to close the conversation. Please try again.',
  SOCKET_ERROR: 'Connection error. Messages may be delayed.',
  EMPTY_SUBJECT: 'Please enter a subject for your conversation.',
  NO_THREAD_SELECTED: 'Please select a conversation first.',
  EMPTY_MESSAGE: 'Please enter a message.',
};

// Placeholder texts
export const PLACEHOLDERS = {
  NEW_THREAD: 'New conversation subject...',
  MESSAGE_INPUT: 'Type your message here...',
};

// Info texts
export const INFO_TEXTS = {
  RESPONSE_TIME: 'We typically respond within 1-24 hours (average ~3 hours)',
  SUPPORT_SUBTITLE: 'Ask us anything about exams, this website, or technical issues. We\'re here to help!',
};

// Empty state messages
export const EMPTY_STATES = {
  NO_THREADS: {
    title: 'No conversations yet',
    subtitle: 'Create one to get started',
  },
  NO_MESSAGES: {
    title: 'No messages in this conversation yet',
    subtitle: 'Start the conversation by sending a message',
  },
  NO_THREAD_SELECTED: {
    title: 'No conversation selected',
    subtitle: 'Choose a conversation from the list or create a new one',
  },
};
</file>

<file path="src/constants/testConstants.js">
// src/constants/testConstants.js
export const TEST_LENGTHS = [25, 50, 75, 100];

export const TEST_CATEGORIES = [
  { id: 'aplus', name: 'A+ Core 1 (1101)', emoji: '💻', color: '#6543CC' },
  { id: 'aplus2', name: 'A+ Core 2 (1102)', emoji: '🖥️', color: '#FF4C8B' },
  { id: 'nplus', name: 'Network+ (N10-009)', emoji: '📡', color: '#2ECC71' },
  { id: 'secplus', name: 'Security+ (SY0-701)', emoji: '🔐', color: '#3498DB' },
  { id: 'cysa', name: 'CySA+ (CS0-003)', emoji: '🕵️‍♂️', color: '#E67E22' },
  { id: 'penplus', name: 'PenTest+ (PT0-003)', emoji: '🐍', color: '#9B59B6' },
  { id: 'linuxplus', name: 'Linux+ (XK0-005)', emoji: '🐧', color: '#1ABC9C' },
  { id: 'caspplus', name: 'CASP+ (CAS-005)', emoji: '⚔️', color: '#E74C3C' },
  { id: 'cloudplus', name: 'Cloud+ (CV0-004)', emoji: '🌩️', color: '#3498DB' },
  { id: 'dataplus', name: 'Data+ (DA0-001)', emoji: '📋', color: '#1ABC9C' },
  { id: 'serverplus', name: 'Server+ (SK0-005)', emoji: '🧛‍♂️', color: '#9B59B6' },
  { id: 'cissp', name: 'CISSP', emoji: '👾', color: '#34495E' },
  { id: 'awscloud', name: 'AWS Cloud Practitioner', emoji: '🌥️', color: '#F39C12' },
];

export const DIFFICULTY_CATEGORIES = [
  { label: "Normal", color: "#fff9e6", textColor: "#4a4a4a" },
  { label: "Very Easy", color: "#adebad", textColor: "#0b3800" },
  { label: "Easy", color: "#87cefa", textColor: "#000000" },
  { label: "Moderate", color: "#ffc765", textColor: "#4a2700" },
  { label: "Intermediate", color: "#ff5959", textColor: "#ffffff" },
  { label: "Formidable", color: "#dc3545", textColor: "#ffffff" },
  { label: "Challenging", color: "#b108f6", textColor: "#ffffff" },
  { label: "Very Challenging", color: "#4b0082", textColor: "#ffffff" },
  { label: "Ruthless", color: "#370031", textColor: "#ffffff" },
  { label: "Ultra Level", color: "#000000", textColor: "#00ffff" }
];

export const EXAM_MODE_INFO = 
  "Exam Mode simulates a real exam environment:\n\n" +
  "• No immediate feedback on answers\n" +
  "• See results only after completing the test\n" +
  "• Time is tracked for the entire session\n\n" +
  "This is perfect for final exam preparation!";
</file>

<file path="src/hooks/useAchievements.js">
// src/hooks/useAchievements.js
import { useState, useEffect, useCallback } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { fetchAchievements } from '../api/achievementService';
import { fetchUserData } from '../store/slices/userSlice';
import { CATEGORY_NAMES, getAchievementCategory } from '../constants/achievementConstants';

/**
 * Custom hook for achievement functionality
 * @returns {Object} Achievement methods and state
 */
const useAchievements = () => {
  const dispatch = useDispatch();
  const { userId, achievements: userAchievements } = useSelector((state) => state.user);
  
  const [allAchievements, setAllAchievements] = useState([]);
  const [filteredAchievements, setFilteredAchievements] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [activeCategory, setActiveCategory] = useState('all');
  const [error, setError] = useState(null);
  
  // Load achievements data
  const loadAchievements = useCallback(async () => {
    try {
      setLoading(true);
      const achievements = await fetchAchievements();
      setAllAchievements(achievements);
      filterAchievements(achievements, activeCategory);
      setError(null);
    } catch (err) {
      console.error('Achievements fetch error:', err);
      setError('Failed to load achievements. Please try again.');
    } finally {
      setLoading(false);
    }
  }, [activeCategory]);
  
  // Initial load
  useEffect(() => {
    loadAchievements();
  }, [loadAchievements]);
  
  // Filter achievements by category
  const filterAchievements = (achievements, category) => {
    if (category === 'all') {
      setFilteredAchievements(achievements);
    } else {
      setFilteredAchievements(
        achievements.filter(achievement => 
          getAchievementCategory(achievement.achievementId) === category
        )
      );
    }
  };
  
  // Handle category change
  const handleCategoryChange = (category) => {
    setActiveCategory(category);
    filterAchievements(allAchievements, category);
  };
  
  // Handle refresh
  const handleRefresh = async () => {
    setRefreshing(true);
    await Promise.all([
      loadAchievements(),
      dispatch(fetchUserData(userId))
    ]);
    setRefreshing(false);
  };
  
  // Check if achievement is unlocked
  const isAchievementUnlocked = (achievementId) => {
    return userAchievements && userAchievements.includes(achievementId);
  };
  
  // Get achievement details
  const getAchievementDetails = (achievementId) => {
    return allAchievements.find(achievement => achievement.achievementId === achievementId);
  };
  
  // Get achievement completion percentage
  const getCompletionPercentage = () => {
    const totalCount = allAchievements.length;
    const unlockedCount = userAchievements ? userAchievements.length : 0;
    return totalCount > 0 ? Math.round((unlockedCount / totalCount) * 100) : 0;
  };
  
  // Get achievement statistics
  const getAchievementStats = () => {
    const totalCount = allAchievements.length;
    const unlockedCount = userAchievements ? userAchievements.length : 0;
    const completionPercentage = getCompletionPercentage();
    
    return {
      total: totalCount,
      unlocked: unlockedCount,
      locked: totalCount - unlockedCount,
      completionPercentage
    };
  };
  
  return {
    // State
    allAchievements,
    filteredAchievements,
    loading,
    refreshing,
    activeCategory,
    error,
    categories: CATEGORY_NAMES,
    
    // Methods
    loadAchievements,
    handleCategoryChange,
    handleRefresh,
    isAchievementUnlocked,
    getAchievementDetails,
    getCompletionPercentage,
    getAchievementStats,
  };
};

export default useAchievements;
</file>

<file path="src/hooks/useLeaderboard.js">
// src/hooks/useLeaderboard.js
import { useState, useEffect, useCallback } from 'react';
import { useSelector } from 'react-redux';
import { fetchLeaderboard, fetchUserRanking } from '../api/leaderboardService';

/**
 * Custom hook for leaderboard functionality
 * @param {number} pageSize - Number of items per page
 * @returns {Object} Leaderboard methods and state
 */
const useLeaderboard = (pageSize = 20) => {
  const { userId, username } = useSelector((state) => state.user);
  
  const [leaderboardData, setLeaderboardData] = useState([]);
  const [userRank, setUserRank] = useState(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  const [error, setError] = useState(null);
  const [totalEntries, setTotalEntries] = useState(0);
  
  // Load leaderboard data
  const loadLeaderboard = useCallback(async (pageNum = 0, refresh = false) => {
    try {
      if (refresh) {
        setRefreshing(true);
        setPage(0);
        pageNum = 0;
      } else if (pageNum > 0) {
        setLoadingMore(true);
      } else {
        setLoading(true);
      }
      
      const skip = pageNum * pageSize;
      const data = await fetchLeaderboard(skip, pageSize);
      
      if (refresh || pageNum === 0) {
        setLeaderboardData(data.data || []);
      } else {
        setLeaderboardData(prevData => [...prevData, ...(data.data || [])]);
      }
      
      setTotalEntries(data.total || 0);
      setHasMore((data.data || []).length === pageSize);
      setError(null);
    } catch (err) {
      console.error('Leaderboard error:', err);
      setError('Failed to load leaderboard. Please try again.');
    } finally {
      setLoading(false);
      setRefreshing(false);
      setLoadingMore(false);
    }
  }, [pageSize]);
  
  // Load user's ranking
  const loadUserRank = useCallback(async () => {
    if (!userId) return;
    
    try {
      const rankData = await fetchUserRanking(userId);
      setUserRank(rankData);
    } catch (err) {
      console.error('User ranking error:', err);
      // Don't set error state here as this is a supplementary feature
    }
  }, [userId]);
  
  // Initial load
  useEffect(() => {
    Promise.all([
      loadLeaderboard(0),
      loadUserRank()
    ]);
  }, [loadLeaderboard, loadUserRank]);
  
  // Refresh data
  const onRefresh = async () => {
    setRefreshing(true);
    await Promise.all([
      loadLeaderboard(0, true),
      loadUserRank()
    ]);
    setRefreshing(false);
  };
  
  // Load more data
  const loadMoreData = () => {
    if (hasMore && !loadingMore && !refreshing) {
      const nextPage = page + 1;
      setPage(nextPage);
      loadLeaderboard(nextPage);
    }
  };
  
  // Check if the user is in the current visible data
  const isUserVisible = useCallback(() => {
    return leaderboardData.some(item => item.username === username);
  }, [leaderboardData, username]);
  
  return {
    // State
    leaderboardData,
    userRank,
    loading,
    refreshing,
    loadingMore,
    page,
    hasMore,
    error,
    totalEntries,
    
    // Methods
    loadLeaderboard,
    loadUserRank,
    onRefresh,
    loadMoreData,
    isUserVisible,
  };
};

export default useLeaderboard;
</file>

<file path="src/hooks/useResources.js">
// src/hooks/useResources.js
import { useState, useEffect, useCallback } from 'react';
import { RESOURCES_DATA } from '../constants/resourcesConstants';
import ResourcesService from '../api/ResourcesService';

/**
 * Custom hook for managing resources data
 * @param {string} initialCategory - Initial resource category to load
 * @returns {Object} Resources state and methods
 */
const useResources = (initialCategory = 'all') => {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState(initialCategory);
  const [showCertCategories, setShowCertCategories] = useState(false);
  const [resources, setResources] = useState([]);
  const [filteredResources, setFilteredResources] = useState([]);
  const [loading, setLoading] = useState(false);
  const [sortAlphabetically, setSortAlphabetically] = useState(false);
  
  // Random resource state
  const [randomResource, setRandomResource] = useState(null);
  const [loadingRandom, setLoadingRandom] = useState(false);
  
  // Load resources for the selected category
  const loadResources = useCallback((categoryId = selectedCategory) => {
    setLoading(true);
    
    // Since resources are stored locally in constants, we simulate API call
    setTimeout(() => {
      const categoryResources = RESOURCES_DATA[categoryId] || [];
      setResources(categoryResources);
      setLoading(false);
    }, 300);
    
    // If backend API is implemented, use this instead:
    // ResourcesService.fetchResourcesByCategory(categoryId)
    //   .then(data => {
    //     setResources(data);
    //     setLoading(false);
    //   })
    //   .catch(error => {
    //     console.error('Error fetching resources:', error);
    //     setLoading(false);
    //   });
  }, [selectedCategory]);
  
  // Load resources when category changes
  useEffect(() => {
    loadResources(selectedCategory);
  }, [selectedCategory, loadResources]);
  
  // Filter and sort resources when search term, resources, or sort preference changes
  useEffect(() => {
    let filtered = resources;
    
    // Apply search filter
    if (searchTerm.trim()) {
      const term = searchTerm.trim().toLowerCase();
      filtered = resources.filter(
        resource => resource.name.toLowerCase().includes(term)
      );
    }
    
    // Apply sorting
    if (sortAlphabetically) {
      filtered = [...filtered].sort((a, b) => 
        a.name.localeCompare(b.name)
      );
    }
    
    setFilteredResources(filtered);
  }, [resources, searchTerm, sortAlphabetically]);
  
  // Get a random resource
  const getRandomResource = useCallback(() => {
    setLoadingRandom(true);
    
    // Create a slight delay for UX
    setTimeout(() => {
      const availableResources = filteredResources.length > 0 
        ? filteredResources 
        : resources;
      
      if (availableResources.length === 0) {
        setLoadingRandom(false);
        return null;
      }
      
      const randomIndex = Math.floor(Math.random() * availableResources.length);
      const resource = availableResources[randomIndex];
      setRandomResource(resource);
      setLoadingRandom(false);
      return resource;
    }, 400);
  }, [filteredResources, resources]);
  
  // Toggle between resource types and certifications
  const toggleCertCategories = useCallback(() => {
    setShowCertCategories(prev => !prev);
    setSelectedCategory('all'); // Reset selected category
  }, []);
  
  // Toggle sort
  const toggleSort = useCallback(() => {
    setSortAlphabetically(prev => !prev);
  }, []);
  
  // Clear all filters
  const clearFilters = useCallback(() => {
    setSearchTerm('');
    setSelectedCategory('all');
    setSortAlphabetically(false);
  }, []);
  
  return {
    // State
    searchTerm,
    selectedCategory,
    showCertCategories,
    resources,
    filteredResources,
    loading,
    sortAlphabetically,
    randomResource,
    loadingRandom,
    
    // Setters
    setSearchTerm,
    setSelectedCategory,
    
    // Actions
    loadResources,
    getRandomResource,
    toggleCertCategories,
    toggleSort,
    clearFilters,
  };
};

export default useResources;
</file>

<file path="src/hooks/useShop.js">
// src/hooks/useShop.js
import { useState, useEffect, useCallback } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { Alert } from 'react-native';
import { fetchShopItems, purchaseItem, equipItem } from '../api/shopService';
import { fetchUserData } from '../store/slices/userSlice';
import { ERROR_MESSAGES } from '../constants/shopConstants';

/**
 * Custom hook for shop-related functionality
 * @returns {Object} Shop methods and state
 */
const useShop = () => {
  const dispatch = useDispatch();
  const { userId, coins, level, purchasedItems, currentAvatar } = useSelector((state) => state.user);
  
  const [shopItems, setShopItems] = useState([]);
  const [filteredItems, setFilteredItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [activeCategory, setActiveCategory] = useState('all');
  const [error, setError] = useState(null);
  
  // Function to load shop items
  const loadShopItems = useCallback(async () => {
    try {
      setLoading(true);
      const items = await fetchShopItems();
      setShopItems(items);
      filterItems(items, activeCategory);
      setError(null);
    } catch (err) {
      console.error('Shop items fetch error:', err);
      setError(ERROR_MESSAGES.FETCH_FAILED);
    } finally {
      setLoading(false);
    }
  }, [activeCategory]);
  
  // Initial load
  useEffect(() => {
    loadShopItems();
  }, [loadShopItems]);
  
  // Filter items by category
  const filterItems = (items, category) => {
    if (category === 'all') {
      setFilteredItems(items);
    } else {
      setFilteredItems(items.filter(item => item.type === category));
    }
  };
  
  // Handle category change
  const handleCategoryChange = (category) => {
    setActiveCategory(category);
    filterItems(shopItems, category);
  };
  
  // Handle refresh
  const handleRefresh = async () => {
    setRefreshing(true);
    await Promise.all([
      loadShopItems(),
      dispatch(fetchUserData(userId))
    ]);
    setRefreshing(false);
  };
  
  // Check if item is purchasable
  const canPurchaseItem = (item) => {
    if (!item) return false;
    
    // Check if item is already purchased
    if (isItemPurchased(item._id)) {
      return false;
    }
    
    // Check if user has enough coins
    if (coins < item.cost) {
      return false;
    }
    
    // Check if user has required level
    if (level < item.unlockLevel) {
      return false;
    }
    
    return true;
  };
  
  // Handle purchase with confirmation
  const handlePurchase = async (item) => {
    if (!item) return;
    
    // Check if user can purchase
    if (!canPurchaseItem(item)) {
      if (isItemPurchased(item._id)) {
        Alert.alert('Already Purchased', 'You already own this item');
        return;
      }
      
      if (coins < item.cost) {
        Alert.alert('Insufficient Coins', `You need ${item.cost - coins} more coins to purchase this item`);
        return;
      }
      
      if (level < item.unlockLevel) {
        Alert.alert('Level Required', `You need to reach level ${item.unlockLevel} to purchase this item`);
        return;
      }
      
      return;
    }
    
    // Ask for confirmation
    return new Promise((resolve, reject) => {
      Alert.alert(
        'Confirm Purchase',
        `Are you sure you want to purchase ${item.title} for ${item.cost} coins?`,
        [
          {
            text: 'Cancel',
            style: 'cancel',
            onPress: () => resolve(false)
          },
          {
            text: 'Purchase',
            onPress: async () => {
              try {
                setLoading(true);
                await purchaseItem(userId, item._id);
                await dispatch(fetchUserData(userId));
                
                Alert.alert('Success', `You have purchased ${item.title}!`);
                resolve(true);
              } catch (error) {
                console.error('Purchase error:', error);
                Alert.alert('Error', ERROR_MESSAGES.PURCHASE_FAILED);
                resolve(false);
              } finally {
                setLoading(false);
              }
            }
          }
        ]
      );
    });
  };
  
  // Handle equip with confirmation
  const handleEquip = async (item) => {
    if (!item) return;
    
    // Check if item is already equipped
    if (isItemEquipped(item._id)) {
      Alert.alert('Already Equipped', 'This item is already equipped');
      return false;
    }
    
    // Check if item is purchased
    if (!isItemPurchased(item._id)) {
      Alert.alert('Not Purchased', 'You need to purchase this item first');
      return false;
    }
    
    try {
      setLoading(true);
      await equipItem(userId, item._id);
      await dispatch(fetchUserData(userId));
      
      Alert.alert('Success', `You have equipped ${item.title}!`);
      return true;
    } catch (error) {
      console.error('Equip error:', error);
      Alert.alert('Error', ERROR_MESSAGES.EQUIP_FAILED);
      return false;
    } finally {
      setLoading(false);
    }
  };
  
  // Check if item is already purchased
  const isItemPurchased = (itemId) => {
    return purchasedItems && purchasedItems.includes(itemId);
  };
  
  // Check if item is already equipped
  const isItemEquipped = (itemId) => {
    return currentAvatar === itemId;
  };
  
  return {
    // State
    shopItems,
    filteredItems,
    loading,
    refreshing,
    activeCategory,
    error,
    
    // Methods
    loadShopItems,
    handleCategoryChange,
    handleRefresh,
    canPurchaseItem,
    handlePurchase,
    handleEquip,
    isItemPurchased,
    isItemEquipped,
  };
};

export default useShop;
</file>

<file path="src/hooks/useSupport.js">
// src/hooks/useSupport.js
import { useState, useEffect, useCallback, useRef } from 'react';
import { useSelector } from 'react-redux';
import { Alert } from 'react-native';
import { io } from 'socket.io-client';
import { 
  fetchSupportThreads, 
  createSupportThread, 
  fetchSupportThread, 
  sendSupportMessage, 
  closeSupportThread 
} from '../api/supportService';
import { 
  SOCKET_EVENTS, 
  CONNECTION_STATUS, 
  ERROR_MESSAGES 
} from '../constants/supportConstants';
import * as SecureStore from 'expo-secure-store';

// Socket instance (kept outside the hook to ensure singleton)
let socket = null;

/**
 * Custom hook for support functionality
 * @returns {Object} Support methods and state
 */
const useSupport = () => {
  // Get user ID from Redux
  const { userId } = useSelector((state) => state.user);
  
  // Threads and messages
  const [threads, setThreads] = useState([]);
  const [messages, setMessages] = useState([]);
  const [selectedThreadId, setSelectedThreadId] = useState(null);
  const [loadingThreads, setLoadingThreads] = useState(false);
  const [loadingMessages, setLoadingMessages] = useState(false);
  const [error, setError] = useState(null);
  
  // UI States
  const [newThreadSubject, setNewThreadSubject] = useState('');
  const [messageText, setMessageText] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const [adminIsTyping, setAdminIsTyping] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState(CONNECTION_STATUS.DISCONNECTED);
  
  // Refs
  const typingTimeoutRef = useRef(null);
  const messageEndRef = useRef(null);
  const processedMessagesRef = useRef(new Set()); // Track processed messages to prevent duplicates
  
  // Create a message signature for duplicate detection
  const createMessageSignature = useCallback((message) => {
    return `${message.sender}:${message.content}:${message.timestamp}`;
  }, []);
  
  // Initialize or get the Socket.IO instance
  const initializeSocket = useCallback(async () => {
    if (socket) return socket;
    
    // Get the base URL from API configuration (we use the same URL for socket.io)
    const baseUrl = API_URL || 'https://certgames.com'; // Default fallback
    
    console.log('Initializing socket connection to:', baseUrl);
    
    socket = io(baseUrl, {
      path: '/api/socket.io',
      transports: ['websocket'],
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000
    });
    
    return socket;
  }, []);
  
  // Setup socket event listeners
  const setupSocketEvents = useCallback(() => {
    if (!socket) return;
    
    // Connection events
    socket.on(SOCKET_EVENTS.CONNECT, () => {
      console.log('Socket connected:', socket.id);
      setConnectionStatus(CONNECTION_STATUS.CONNECTED);
      
      // Join user's personal room
      socket.emit(SOCKET_EVENTS.JOIN_USER_ROOM, { userId });
      
      // Rejoin current thread if there is one
      if (selectedThreadId) {
        socket.emit(SOCKET_EVENTS.JOIN_THREAD, { threadId: selectedThreadId });
      }
    });
    
    socket.on(SOCKET_EVENTS.DISCONNECT, () => {
      console.log('Socket disconnected');
      setConnectionStatus(CONNECTION_STATUS.DISCONNECTED);
    });
    
    socket.on(SOCKET_EVENTS.CONNECT_ERROR, (err) => {
      console.error('Socket connection error:', err);
      setConnectionStatus(CONNECTION_STATUS.ERROR);
    });
    
    // Support-specific events
    socket.on(SOCKET_EVENTS.NEW_MESSAGE, (payload) => {
      console.log('Received new message:', payload);
      
      const { threadId, message } = payload;
      
      // Add message to current thread if it's selected
      if (threadId === selectedThreadId) {
        const messageSignature = createMessageSignature(message);
        
        // Only add if not a duplicate
        if (!processedMessagesRef.current.has(messageSignature)) {
          processedMessagesRef.current.add(messageSignature);
          
          setMessages((prev) => [...prev, message]);
          
          // Scroll to bottom after a short delay to ensure message is rendered
          setTimeout(() => {
            if (messageEndRef.current) {
              messageEndRef.current.scrollToEnd({ animated: true });
            }
          }, 100);
        }
      }
      
      // Update thread's last updated timestamp
      setThreads((prev) =>
        prev.map((t) => {
          if (t._id === threadId) {
            return { ...t, lastUpdated: new Date().toISOString() };
          }
          return t;
        })
      );
    });
    
    socket.on(SOCKET_EVENTS.NEW_THREAD, (threadData) => {
      console.log('Received new thread:', threadData);
      
      // Add to threads list if not already there
      setThreads((prev) => {
        if (prev.some((t) => t._id === threadData._id)) {
          return prev;
        }
        return [threadData, ...prev];
      });
      
      // Join the thread room
      socket.emit(SOCKET_EVENTS.JOIN_THREAD, { threadId: threadData._id });
    });
    
    socket.on(SOCKET_EVENTS.ADMIN_TYPING, (data) => {
      if (data.threadId === selectedThreadId) {
        setAdminIsTyping(true);
      }
    });
    
    socket.on(SOCKET_EVENTS.ADMIN_STOP_TYPING, (data) => {
      if (data.threadId === selectedThreadId) {
        setAdminIsTyping(false);
      }
    });
    
    // If already connected, handle connection
    if (socket.connected) {
      setConnectionStatus(CONNECTION_STATUS.CONNECTED);
      socket.emit(SOCKET_EVENTS.JOIN_USER_ROOM, { userId });
      if (selectedThreadId) {
        socket.emit(SOCKET_EVENTS.JOIN_THREAD, { threadId: selectedThreadId });
      }
    }
  }, [userId, selectedThreadId, createMessageSignature]);
  
  // Cleanup socket event listeners
  const cleanupSocketEvents = useCallback(() => {
    if (!socket) return;
    
    socket.off(SOCKET_EVENTS.CONNECT);
    socket.off(SOCKET_EVENTS.DISCONNECT);
    socket.off(SOCKET_EVENTS.CONNECT_ERROR);
    socket.off(SOCKET_EVENTS.NEW_MESSAGE);
    socket.off(SOCKET_EVENTS.NEW_THREAD);
    socket.off(SOCKET_EVENTS.ADMIN_TYPING);
    socket.off(SOCKET_EVENTS.ADMIN_STOP_TYPING);
  }, []);
  
  // Initialize socket on mount
  useEffect(() => {
    const initSocket = async () => {
      await initializeSocket();
      setupSocketEvents();
    };
    
    initSocket();
    
    // Cleanup on unmount
    return () => {
      cleanupSocketEvents();
      
      // Clear typing timeout if exists
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
    };
  }, [initializeSocket, setupSocketEvents, cleanupSocketEvents]);
  
  // Load threads
  const loadThreads = useCallback(async () => {
    setLoadingThreads(true);
    setError(null);
    
    try {
      const threadsData = await fetchSupportThreads();
      setThreads(Array.isArray(threadsData) ? threadsData : []);
      
      // Join all thread rooms for real-time updates
      if (socket && socket.connected) {
        threadsData.forEach((thread) => {
          socket.emit(SOCKET_EVENTS.JOIN_THREAD, { threadId: thread._id });
        });
      }
    } catch (err) {
      console.error('Error loading threads:', err);
      setError(ERROR_MESSAGES.FETCH_THREADS);
    } finally {
      setLoadingThreads(false);
    }
  }, []);
  
  // Create a new thread
  const createThread = useCallback(async (subject) => {
    if (!subject || !subject.trim()) {
      setError(ERROR_MESSAGES.EMPTY_SUBJECT);
      return null;
    }
    
    setError(null);
    
    try {
      const newThread = await createSupportThread(subject.trim());
      
      // Add to threads list
      setThreads((prev) => [newThread, ...prev]);
      
      // Clear the subject input
      setNewThreadSubject('');
      
      // Join the thread room
      if (socket && socket.connected) {
        socket.emit(SOCKET_EVENTS.JOIN_THREAD, { threadId: newThread._id });
      }
      
      return newThread;
    } catch (err) {
      console.error('Error creating thread:', err);
      setError(ERROR_MESSAGES.CREATE_THREAD);
      return null;
    }
  }, []);
  
  // Select a thread and load its messages
  const selectThread = useCallback(async (threadId) => {
    // Skip if already selected
    if (threadId === selectedThreadId) return;
    
    // Leave current thread room if any
    if (selectedThreadId && socket && socket.connected) {
      socket.emit(SOCKET_EVENTS.LEAVE_THREAD, { threadId: selectedThreadId });
    }
    
    setSelectedThreadId(threadId);
    setMessages([]);
    setLoadingMessages(true);
    setError(null);
    
    // Clear previously processed messages
    processedMessagesRef.current.clear();
    
    // Join new thread room
    if (socket && socket.connected) {
      socket.emit(SOCKET_EVENTS.JOIN_THREAD, { threadId });
    }
    
    try {
      const threadData = await fetchSupportThread(threadId);
      
      // Add messages to processed set to prevent duplicates
      const loadedMessages = threadData.messages || [];
      loadedMessages.forEach(msg => {
        processedMessagesRef.current.add(createMessageSignature(msg));
      });
      
      setMessages(loadedMessages);
      
      // Scroll to bottom after a short delay
      setTimeout(() => {
        if (messageEndRef.current) {
          messageEndRef.current.scrollToEnd({ animated: true });
        }
      }, 100);
      
      return threadData;
    } catch (err) {
      console.error('Error loading thread messages:', err);
      setError(ERROR_MESSAGES.LOAD_MESSAGES);
      return null;
    } finally {
      setLoadingMessages(false);
    }
  }, [selectedThreadId, createMessageSignature]);
  
  // Send a message
  const sendMessage = useCallback(async (content) => {
    if (!selectedThreadId) {
      setError(ERROR_MESSAGES.NO_THREAD_SELECTED);
      return false;
    }
    
    if (!content || !content.trim()) {
      setError(ERROR_MESSAGES.EMPTY_MESSAGE);
      return false;
    }
    
    setError(null);
    const trimmedContent = content.trim();
    
    // Create optimistic message
    const optimisticMsg = {
      sender: 'user',
      content: trimmedContent,
      timestamp: new Date().toISOString(),
      optimistic: true
    };
    
    // Add to messages for immediate feedback
    setMessages((prev) => [...prev, optimisticMsg]);
    setMessageText('');
    
    // Scroll to bottom after adding message
    setTimeout(() => {
      if (messageEndRef.current) {
        messageEndRef.current.scrollToEnd({ animated: true });
      }
    }, 50);
    
    // Stop typing indication
    if (socket && socket.connected) {
      socket.emit(SOCKET_EVENTS.USER_STOP_TYPING, { threadId: selectedThreadId });
    }
    setIsTyping(false);
    
    try {
      await sendSupportMessage(selectedThreadId, trimmedContent);
      
      // Update thread in list
      setThreads((prev) =>
        prev.map((t) => {
          if (t._id === selectedThreadId) {
            return { ...t, lastUpdated: new Date().toISOString() };
          }
          return t;
        })
      );
      
      // Reload messages to get the confirmed message from server
      // This includes the server-generated timestamp
      await loadMessagesForThread(selectedThreadId);
      return true;
    } catch (err) {
      console.error('Error sending message:', err);
      setError(ERROR_MESSAGES.SEND_MESSAGE);
      
      // Remove the optimistic message
      setMessages((prev) => prev.filter((msg) => !msg.optimistic));
      return false;
    }
  }, [selectedThreadId]);
  
  // Reload messages for the current thread
  const loadMessagesForThread = useCallback(async (threadId) => {
    try {
      const threadData = await fetchSupportThread(threadId);
      
      // Clear previous processed messages when explicitly reloading
      processedMessagesRef.current.clear();
      
      // Add all messages to processed set
      const loadedMessages = threadData.messages || [];
      loadedMessages.forEach(msg => {
        processedMessagesRef.current.add(createMessageSignature(msg));
      });
      
      setMessages(loadedMessages);
      
      // Scroll to bottom
      setTimeout(() => {
        if (messageEndRef.current) {
          messageEndRef.current.scrollToEnd({ animated: true });
        }
      }, 100);
      
      return true;
    } catch (err) {
      console.error('Error reloading messages:', err);
      return false;
    }
  }, [createMessageSignature]);
  
  // Handle typing indication
  const handleTyping = useCallback((text) => {
    setMessageText(text);
    
    // Send typing indicator if connected
    if (socket && socket.connected && selectedThreadId) {
      // If not already typing, send a typing event
      if (!isTyping && text.trim().length > 0) {
        socket.emit(SOCKET_EVENTS.USER_TYPING, { threadId: selectedThreadId });
        setIsTyping(true);
      }
      // If typing and text becomes empty, send a stop typing event
      else if (isTyping && text.trim().length === 0) {
        socket.emit(SOCKET_EVENTS.USER_STOP_TYPING, { threadId: selectedThreadId });
        setIsTyping(false);
      }
      
      // Clear any existing timeout
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
      
      // Set a timeout to stop typing after 2 seconds of inactivity
      typingTimeoutRef.current = setTimeout(() => {
        if (isTyping) {
          socket.emit(SOCKET_EVENTS.USER_STOP_TYPING, { threadId: selectedThreadId });
          setIsTyping(false);
        }
      }, 2000);
    }
  }, [selectedThreadId, isTyping]);
  
  // Close a thread
  const closeThread = useCallback(async () => {
    if (!selectedThreadId) return false;
    
    const confirmed = await new Promise((resolve) => {
      Alert.alert(
        "Close Conversation",
        "Are you sure you want to close this conversation?",
        [
          { text: "Cancel", onPress: () => resolve(false), style: "cancel" },
          { text: "Close", onPress: () => resolve(true), style: "destructive" }
        ]
      );
    });
    
    if (!confirmed) return false;
    
    try {
      await closeSupportThread(selectedThreadId);
      
      // Update thread status in the list
      setThreads((prev) =>
        prev.map((t) => {
          if (t._id === selectedThreadId) {
            return { ...t, status: 'closed' };
          }
          return t;
        })
      );
      
      // Reload messages to show closure message
      await loadMessagesForThread(selectedThreadId);
      return true;
    } catch (err) {
      console.error('Error closing thread:', err);
      setError(ERROR_MESSAGES.CLOSE_THREAD);
      return false;
    }
  }, [selectedThreadId, loadMessagesForThread]);
  
  // Format timestamp for display
  const formatTimestamp = useCallback((timestamp) => {
    if (!timestamp) return '';
    
    const date = new Date(timestamp);
    const now = new Date();
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    
    // Format options for time
    const timeOptions = { hour: '2-digit', minute: '2-digit' };
    
    // If it's today, just show the time
    if (date.toDateString() === now.toDateString()) {
      return `Today, ${date.toLocaleTimeString([], timeOptions)}`;
    }
    
    // If it's yesterday, show "Yesterday, time"
    if (date.toDateString() === yesterday.toDateString()) {
      return `Yesterday, ${date.toLocaleTimeString([], timeOptions)}`;
    }
    
    // Otherwise show the full date
    return date.toLocaleDateString([], { 
      month: 'short', 
      day: 'numeric'
    }) + ', ' + date.toLocaleTimeString([], timeOptions);
  }, []);
  
  // Check if a thread is closed
  const isThreadClosed = useCallback((threadId) => {
    const thread = threads.find(t => t._id === threadId);
    return thread?.status?.toLowerCase() === 'closed';
  }, [threads]);
  
  // Get the selected thread
  const getSelectedThread = useCallback(() => {
    return threads.find(t => t._id === selectedThreadId);
  }, [threads, selectedThreadId]);
  
  return {
    // State
    threads,
    messages,
    selectedThreadId,
    loadingThreads,
    loadingMessages,
    newThreadSubject,
    messageText,
    adminIsTyping,
    connectionStatus,
    error,
    messageEndRef,
    
    // Actions
    setNewThreadSubject,
    loadThreads,
    createThread,
    selectThread,
    sendMessage,
    handleTyping,
    closeThread,
    setError,
    formatTimestamp,
    isThreadClosed,
    getSelectedThread,
  };
};

export default useSupport;
</file>

<file path="src/hooks/useTest.js">
// src/hooks/useTest.js
import { useState, useEffect, useCallback, useMemo } from 'react';
import { useSelector } from 'react-redux';
import * as SecureStore from 'expo-secure-store';
import * as testService from '../api/testService';

/**
 * Custom hook for test-related functionality
 * 
 * @param {Object} options - Hook options
 * @param {string} [options.category] - Test category
 * @param {string|number} [options.testId] - Test ID
 * @param {boolean} [options.initialExamMode] - Initial exam mode state
 * @param {boolean} [options.isReview] - Whether in review mode
 * @returns {Object} Test methods and state
 */
const useTest = ({ 
  category, 
  testId, 
  initialExamMode,
  isReview = false
} = {}) => {
  const { userId, xpBoost } = useSelector(state => state.user);
  
  // Test state
  const [testData, setTestData] = useState(null);
  const [shuffleOrder, setShuffleOrder] = useState([]);
  const [answerOrder, setAnswerOrder] = useState([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [answers, setAnswers] = useState([]);
  const [score, setScore] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [flaggedQuestions, setFlaggedQuestions] = useState([]);
  
  // UI state
  const [isAnswered, setIsAnswered] = useState(false);
  const [selectedOptionIndex, setSelectedOptionIndex] = useState(null);
  const [isFinished, setIsFinished] = useState(false);
  
  // Test configuration
  const [examMode, setExamMode] = useState(initialExamMode || false);
  const [activeTestLength, setActiveTestLength] = useState(100);
  
  // Helper function to shuffle an array
  const shuffleArray = useCallback((arr) => {
    const copy = [...arr];
    for (let i = copy.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy;
  }, []);
  
  // Helper function to generate shuffled indices
  const shuffleIndices = useCallback((length) => {
    const indices = Array.from({ length }, (_, i) => i);
    return shuffleArray(indices);
  }, [shuffleArray]);
  
  // Get the real index based on shuffle order
  const getShuffledIndex = useCallback((index) => {
    if (!shuffleOrder || shuffleOrder.length === 0) return index;
    return shuffleOrder[index];
  }, [shuffleOrder]);
  
  // Current question based on shuffled index
  const currentQuestion = useMemo(() => {
    if (!testData || !testData.questions || testData.questions.length === 0) return null;
    const realIndex = getShuffledIndex(currentQuestionIndex);
    return testData.questions[realIndex];
  }, [testData, currentQuestionIndex, getShuffledIndex]);
  
  // Get current options for display
  const currentOptions = useMemo(() => {
    if (!currentQuestion || !answerOrder[getShuffledIndex(currentQuestionIndex)]) return [];
    
    return answerOrder[getShuffledIndex(currentQuestionIndex)].map(
      optionIdx => currentQuestion.options[optionIdx]
    );
  }, [currentQuestion, answerOrder, getShuffledIndex, currentQuestionIndex]);
  
  // Load test data and attempt
  const loadTest = useCallback(async () => {
    if (!category || !testId || !userId) {
      setLoading(false);
      return;
    }
    
    try {
      setLoading(true);
      
      let attemptDoc = null;
      
      // If reviewing, get finished attempt
      if (isReview) {
        const attemptRes = await testService.fetchTestAttempt(userId, testId, 'finished');
        attemptDoc = attemptRes.attempt;
      } 
      // Otherwise check for unfinished attempt first
      else {
        const unfinishedRes = await testService.fetchTestAttempt(userId, testId, 'unfinished');
        
        if (unfinishedRes.attempt) {
          attemptDoc = unfinishedRes.attempt;
        } else {
          // If no unfinished attempt, check for finished (for resuming)
          const finishedRes = await testService.fetchTestAttempt(userId, testId);
          attemptDoc = finishedRes.attempt;
        }
      }
      
      // Fetch test data
      const testDoc = await testService.fetchTestById(category, testId);
      setTestData(testDoc);
      
      const totalQ = testDoc.questions.length;
      
      // Process attempt if it exists
      if (attemptDoc) {
        setAnswers(attemptDoc.answers || []);
        setScore(attemptDoc.score || 0);
        setIsFinished(attemptDoc.finished === true);
        
        // Use the exam mode from the attempt doc
        const attemptExam = attemptDoc.examMode === true;
        setExamMode(attemptExam);
        
        // Use the chosen length if available
        const chosenLength = attemptDoc.selectedLength || totalQ;
        setActiveTestLength(chosenLength);
        
        // Use saved shuffle order if valid
        if (
          attemptDoc.shuffleOrder &&
          Array.isArray(attemptDoc.shuffleOrder) &&
          attemptDoc.shuffleOrder.length === chosenLength
        ) {
          setShuffleOrder(attemptDoc.shuffleOrder);
        } else {
          // Create new shuffle order
          const newQOrder = shuffleIndices(chosenLength);
          setShuffleOrder(newQOrder);
          
          // Save immediately if not reviewing
          if (!isReview) {
            await testService.createOrUpdateAttempt(userId, testId, {
              category,
              answers: attemptDoc.answers || [],
              score: attemptDoc.score || 0,
              totalQuestions: totalQ,
              selectedLength: chosenLength,
              currentQuestionIndex: attemptDoc.currentQuestionIndex || 0,
              shuffleOrder: newQOrder,
              answerOrder: attemptDoc.answerOrder || [],
              finished: attemptDoc.finished === true,
              examMode: attemptExam
            });
          }
        }
        
        // Use saved answer order if valid
        if (
          attemptDoc.answerOrder &&
          Array.isArray(attemptDoc.answerOrder) &&
          attemptDoc.answerOrder.length === chosenLength
        ) {
          setAnswerOrder(attemptDoc.answerOrder);
        } else {
          // Create new answer order
          const newAnswerOrder = testDoc.questions
            .slice(0, chosenLength)
            .map(q => {
              const numOptions = q.options.length;
              return shuffleArray(Array.from({ length: numOptions }, (_, i) => i));
            });
            
          setAnswerOrder(newAnswerOrder);
          
          // Save immediately if not reviewing
          if (!isReview) {
            await testService.createOrUpdateAttempt(userId, testId, {
              category,
              answers: attemptDoc.answers || [],
              score: attemptDoc.score || 0,
              totalQuestions: totalQ,
              selectedLength: chosenLength,
              currentQuestionIndex: attemptDoc.currentQuestionIndex || 0,
              shuffleOrder: attemptDoc.shuffleOrder || [],
              answerOrder: newAnswerOrder,
              finished: attemptDoc.finished === true,
              examMode: attemptExam
            });
          }
        }
        
        setCurrentQuestionIndex(attemptDoc.currentQuestionIndex || 0);
      } else {
        // No attempt exists - this should be handled by the UI to create a new attempt
        setActiveTestLength(100); // Default
        setError('No test attempt found. Please create a new attempt.');
      }
      
      setError(null);
    } catch (err) {
      console.error('Error loading test:', err);
      setError(err.message || 'Failed to load test data');
    } finally {
      setLoading(false);
    }
  }, [
    userId, 
    testId, 
    category, 
    isReview, 
    shuffleIndices, 
    shuffleArray
  ]);
  
  // Load test when params change
  useEffect(() => {
    if (userId && testId && category) {
      loadTest();
    }
  }, [loadTest, userId, testId, category]);
  
  // Create a new test attempt with selected length
  const createNewAttempt = useCallback(async (selectedLength) => {
    if (!userId || !testId || !category || !testData) {
      return { success: false, message: 'Missing required data' };
    }
    
    try {
      const totalQ = testData.questions.length;
      
      // Generate shuffle orders
      const newQOrder = shuffleIndices(selectedLength);
      const newAnswerOrder = testData.questions
        .slice(0, selectedLength)
        .map(q => {
          const numOptions = q.options.length;
          return shuffleArray(Array.from({ length: numOptions }, (_, i) => i));
        });
        
      // Update state
      setShuffleOrder(newQOrder);
      setAnswerOrder(newAnswerOrder);
      setActiveTestLength(selectedLength);
      setScore(0);
      setAnswers([]);
      setCurrentQuestionIndex(0);
      setSelectedOptionIndex(null);
      setIsAnswered(false);
      setIsFinished(false);
      
      // Create attempt on server
      await testService.createOrUpdateAttempt(userId, testId, {
        category,
        answers: [],
        score: 0,
        totalQuestions: totalQ,
        selectedLength,
        currentQuestionIndex: 0,
        shuffleOrder: newQOrder,
        answerOrder: newAnswerOrder,
        finished: false,
        examMode
      });
      
      return { success: true };
    } catch (error) {
      console.error('Failed to create new attempt:', error);
      setError('Failed to create new attempt');
      return { success: false, message: error.message || 'Failed to create attempt' };
    }
  }, [userId, testId, category, testData, examMode, shuffleIndices, shuffleArray]);
  
  // Restart the test with the same length
  const restartTest = useCallback(async () => {
    return await createNewAttempt(activeTestLength);
  }, [createNewAttempt, activeTestLength]);
  
  // Update the server with current progress
  const updateProgress = useCallback(async (updatedAnswers, updatedScore, finished = false, singleAnswer = null) => {
    if (!userId || !testId) return null;
    
    try {
      let result = null;
      
      if (singleAnswer) {
        result = await testService.submitAnswer(userId, {
          testId,
          questionId: singleAnswer.questionId,
          correctAnswerIndex: singleAnswer.correctAnswerIndex,
          selectedIndex: singleAnswer.userAnswerIndex,
          xpPerCorrect: (testData?.xpPerCorrect || 10) * xpBoost,
          coinsPerCorrect: 5
        });
        
        // For exam mode, also update the full attempt
        if (examMode) {
          await testService.createOrUpdateAttempt(userId, testId, {
            category,
            answers: updatedAnswers,
            score: updatedScore,
            totalQuestions: testData?.questions?.length || 0,
            selectedLength: activeTestLength,
            currentQuestionIndex,
            shuffleOrder,
            answerOrder,
            finished,
            examMode
          });
        }
      } else {
        // Update position data
        await testService.updatePosition(userId, testId, {
          currentQuestionIndex,
          finished
        });
        
        // Update full attempt data
        await testService.createOrUpdateAttempt(userId, testId, {
          category,
          answers: updatedAnswers,
          score: updatedScore,
          totalQuestions: testData?.questions?.length || 0,
          selectedLength: activeTestLength,
          currentQuestionIndex,
          shuffleOrder,
          answerOrder,
          finished,
          examMode
        });
      }
      
      return result;
    } catch (error) {
      console.error('Failed to update progress:', error);
      return null;
    }
  }, [
    userId, 
    testId, 
    examMode, 
    testData, 
    xpBoost, 
    category, 
    activeTestLength, 
    currentQuestionIndex, 
    shuffleOrder, 
    answerOrder
  ]);
  
  // Handle option selection
  const selectOption = useCallback(async (displayOptionIndex) => {
    if (!currentQuestion) return { success: false, message: 'No current question' };
    if (!examMode && isAnswered) return { success: false, message: 'Already answered' };
    
    const realIndex = getShuffledIndex(currentQuestionIndex);
    const actualAnswerIndex = answerOrder[realIndex][displayOptionIndex];
    
    setSelectedOptionIndex(displayOptionIndex);
    setIsAnswered(true);
    
    try {
      const newAnswerObj = {
        questionId: currentQuestion.id,
        userAnswerIndex: actualAnswerIndex,
        correctAnswerIndex: currentQuestion.correctAnswerIndex
      };
      
      const updatedAnswers = [...answers];
      const idx = updatedAnswers.findIndex(a => a.questionId === currentQuestion.id);
      
      if (idx >= 0) {
        updatedAnswers[idx] = newAnswerObj;
      } else {
        updatedAnswers.push(newAnswerObj);
      }
      
      setAnswers(updatedAnswers);
      
      // Update progress on server
      const result = await updateProgress(updatedAnswers, score, false, newAnswerObj);
      
      // Update score for non-exam mode
      if (!examMode && result && result.examMode === false) {
        if (result.isCorrect) {
          setScore(prev => prev + 1);
        }
        
        return { 
          success: true, 
          isCorrect: result.isCorrect, 
          alreadyCorrect: result.alreadyCorrect,
          awardedXP: result.awardedXP,
          awardedCoins: result.awardedCoins
        };
      }
      
      return { success: true, examMode: true };
    } catch (error) {
      console.error('Error selecting option:', error);
      return { success: false, message: error.message };
    }
  }, [
    currentQuestion, 
    examMode, 
    isAnswered, 
    getShuffledIndex, 
    currentQuestionIndex, 
    answerOrder, 
    answers, 
    score, 
    updateProgress
  ]);
  
  // Skip the current question
  const skipQuestion = useCallback(async () => {
    if (!currentQuestion) return false;
    
    const updatedAnswers = [...answers];
    const idx = updatedAnswers.findIndex(a => a.questionId === currentQuestion.id);
    
    const skipObj = {
      questionId: currentQuestion.id,
      userAnswerIndex: null,
      correctAnswerIndex: currentQuestion.correctAnswerIndex
    };
    
    if (idx >= 0) {
      updatedAnswers[idx] = skipObj;
    } else {
      updatedAnswers.push(skipObj);
    }
    
    setAnswers(updatedAnswers);
    setIsAnswered(false);
    setSelectedOptionIndex(null);
    
    await updateProgress(updatedAnswers, score, false, skipObj);
    
    // If this is the last question, finish the test
    if (currentQuestionIndex === activeTestLength - 1) {
      return await finishTest();
    }
    
    // Move to next question
    setCurrentQuestionIndex(prev => prev + 1);
    return true;
  }, [
    currentQuestion, 
    answers, 
    score, 
    updateProgress, 
    currentQuestionIndex, 
    activeTestLength
  ]);
  
  // Navigate to the next question
  const nextQuestion = useCallback(async () => {
    if (!isAnswered && !examMode) {
      return { success: false, message: 'Please answer or skip the question' };
    }
    
    // If this is the last question, finish the test
    if (currentQuestionIndex === activeTestLength - 1) {
      return await finishTest();
    }
    
    // Move to next question
    setCurrentQuestionIndex(prev => prev + 1);
    await updateProgress(answers, score, false);
    return { success: true };
  }, [
    isAnswered, 
    examMode, 
    currentQuestionIndex, 
    activeTestLength, 
    answers, 
    score, 
    updateProgress
  ]);
  
  // Navigate to the previous question
  const previousQuestion = useCallback(async () => {
    if (currentQuestionIndex > 0) {
      setCurrentQuestionIndex(prev => prev - 1);
      await updateProgress(answers, score, false);
      return true;
    }
    return false;
  }, [currentQuestionIndex, answers, score, updateProgress]);
  
  // Toggle flag on the current question
  const toggleFlag = useCallback(() => {
    if (!currentQuestion) return;
    
    const qId = currentQuestion.id;
    if (flaggedQuestions.includes(qId)) {
      setFlaggedQuestions(prev => prev.filter(id => id !== qId));
    } else {
      setFlaggedQuestions(prev => [...prev, qId]);
    }
  }, [currentQuestion, flaggedQuestions]);
  
  // Finish the test
  const finishTest = useCallback(async () => {
    // Calculate final score
    let finalScore = 0;
    answers.forEach(ans => {
      if (ans.userAnswerIndex === ans.correctAnswerIndex) {
        finalScore++;
      }
    });
    
    setScore(finalScore);
    setIsFinished(true);
    
    try {
      const result = await testService.finishTestAttempt(userId, testId, {
        score: finalScore,
        totalQuestions: activeTestLength,
        testId,
        category
      });
      
      return {
        success: true,
        score: finalScore,
        totalQuestions: activeTestLength,
        percentage: Math.round((finalScore / activeTestLength) * 100),
        newlyUnlocked: result.newlyUnlocked || [],
        newXP: result.newXP,
        newCoins: result.newCoins
      };
    } catch (error) {
      console.error('Error finishing test:', error);
      return { success: false, message: error.message };
    }
  }, [userId, testId, answers, activeTestLength, category]);
  
  // Set exam mode (and save to storage)
  const setExamModeWithSave = useCallback(async (value) => {
    setExamMode(value);
    await SecureStore.setItemAsync('examMode', value ? 'true' : 'false');
  }, []);
  
  // Load exam mode from storage
  const loadExamMode = useCallback(async () => {
    try {
      const storedMode = await SecureStore.getItemAsync('examMode');
      setExamMode(storedMode === 'true');
    } catch (err) {
      console.error('Error loading exam mode:', err);
    }
  }, []);
  
  return {
    // State
    testData,
    currentQuestion,
    currentOptions,
    shuffleOrder,
    answerOrder,
    currentQuestionIndex,
    answers,
    score,
    loading,
    error,
    flaggedQuestions,
    isAnswered,
    selectedOptionIndex,
    isFinished,
    examMode,
    activeTestLength,
    
    // Derived values
    effectiveTotal: activeTestLength || (testData?.questions?.length || 0),
    progressPercentage: activeTestLength ? Math.round(((currentQuestionIndex + 1) / activeTestLength) * 100) : 0,
    
    // Methods
    loadTest,
    createNewAttempt,
    restartTest,
    selectOption,
    skipQuestion,
    nextQuestion,
    previousQuestion,
    toggleFlag,
    finishTest,
    setExamMode: setExamModeWithSave,
    loadExamMode,
    getShuffledIndex
  };
};

export default useTest;
</file>

<file path="src/navigation/AppNavigator.js">
// src/navigation/AppNavigator.js
import React, { useEffect, useState } from 'react';
import { NavigationContainer, DefaultTheme } from '@react-navigation/native';
import { useSelector, useDispatch } from 'react-redux';
import * as SecureStore from 'expo-secure-store';
import * as SplashScreen from 'expo-splash-screen';

// Import navigators
import AuthNavigator from './AuthNavigator';
import MainNavigator from './MainNavigator';

// Import actions
import { fetchUserData } from '../store/slices/userSlice';

// Keep the splash screen visible while we fetch resources
SplashScreen.preventAutoHideAsync();

// Custom theme
const MyTheme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    background: '#121212',
    text: '#FFFFFF',
    primary: '#6543CC',
    card: '#1E1E1E',
    border: '#333333',
  },
};

const AppNavigator = () => {
  const dispatch = useDispatch();
  const { userId, status } = useSelector((state) => state.user);
  const [appIsReady, setAppIsReady] = useState(false);

  useEffect(() => {
    async function prepare() {
      try {
        // Check if user is already logged in
        const storedUserId = await SecureStore.getItemAsync('userId');
        
        if (storedUserId) {
          // Fetch user data
          await dispatch(fetchUserData(storedUserId));
        }
      } catch (e) {
        console.warn('Error preparing app:', e);
      } finally {
        // Tell the application to render
        setAppIsReady(true);
        await SplashScreen.hideAsync();
      }
    }

    prepare();
  }, [dispatch]);

  if (!appIsReady) {
    return null;
  }

  return (
    <NavigationContainer theme={MyTheme}>
      {userId ? <MainNavigator /> : <AuthNavigator />}
    </NavigationContainer>
  );
};

export default AppNavigator;
</file>

<file path="src/navigation/AuthNavigator.js">
// src/navigation/AuthNavigator.js
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';

// Import auth screens
import LoginScreen from '../screens/auth/LoginScreen';
import RegisterScreen from '../screens/auth/RegisterScreen';
import ForgotPasswordScreen from '../screens/auth/ForgotPasswordScreen';
import CreateUsernameScreen from '../screens/auth/CreateUsernameScreen';

const Stack = createStackNavigator();

const AuthNavigator = () => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
        cardStyle: { backgroundColor: '#121212' }
      }}
    >
      <Stack.Screen name="Login" component={LoginScreen} />
      <Stack.Screen name="Register" component={RegisterScreen} />
      <Stack.Screen name="ForgotPassword" component={ForgotPasswordScreen} />
      <Stack.Screen name="CreateUsername" component={CreateUsernameScreen} />
    </Stack.Navigator>
  );
};

export default AuthNavigator;
</file>

<file path="src/navigation/MainNavigator.js">
// src/navigation/MainNavigator.js
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { createStackNavigator } from '@react-navigation/stack';
import { Ionicons } from '@expo/vector-icons';

// Import screens
import HomeScreen from '../screens/HomeScreen';
import ProfileScreen from '../screens/profile/ProfileScreen';
import LeaderboardScreen from '../screens/LeaderboardScreen';
import ShopScreen from '../screens/shop/ShopScreen';
import TestListScreen from '../screens/tests/TestListScreen';
import TestScreen from '../screens/tests/TestScreen';
import AnalogyHubScreen from '../screens/tools/AnalogyHubScreen';
import ScenarioSphereScreen from '../screens/tools/ScenarioSphereScreen';
import GRCScreen from '../screens/tools/GRCScreen';
import AchievementsScreen from '../screens/profile/AchievementsScreen';
import SupportScreen from '../screens/profile/SupportScreen';
import XploitCraftScreen from '../screens/tools/XploitCraftScreen';
import DailyStationScreen from '../screens/tools/DailyStationScreen';
import NewsletterScreen from '../screens/tools/NewsletterScreen';
import ResourcesScreen from '../screens/tools/ResourcesScreen';

// Import test navigator
import TestNavigator from './TestNavigator';

const Tab = createBottomTabNavigator();
const HomeStack = createStackNavigator();
const ProfileStack = createStackNavigator();
const LeaderboardStack = createStackNavigator();
const ShopStack = createStackNavigator();

// Home Stack
const HomeStackNavigator = () => (
  <HomeStack.Navigator
    screenOptions={{
      headerStyle: {
        backgroundColor: '#1E1E1E',
        elevation: 0, // Android
        shadowOpacity: 0, // iOS
      },
      headerTintColor: '#FFFFFF',
      headerTitleStyle: {
        fontWeight: 'bold',
      },
    }}
  >
    <HomeStack.Screen 
      name="HomeScreen" 
      component={HomeScreen} 
      options={{ title: 'Dashboard' }}
    />
    <HomeStack.Screen 
      name="TestList" 
      component={TestListScreen} 
      options={({ route }) => ({ title: route.params?.title || 'Practice Tests' })}
    />
    <HomeStack.Screen 
      name="Test" 
      component={TestScreen} 
      options={({ route }) => ({ title: route.params?.title || 'Test' })}
    />
    <HomeStack.Screen 
      name="AnalogyHub" 
      component={AnalogyHubScreen} 
      options={{ title: 'Analogy Hub' }}
    />
    <HomeStack.Screen 
      name="ScenarioSphere" 
      component={ScenarioSphereScreen} 
      options={{ title: 'Scenario Sphere' }}
    />
    <HomeStack.Screen 
      name="GRC" 
      component={GRCScreen} 
      options={{ title: 'GRC Questions' }}
    />
    <HomeStack.Screen 
      name="XploitCraft" 
      component={XploitCraftScreen} 
      options={{ title: 'XploitCraft' }}
    />
    <HomeStack.Screen 
      name="DailyStation" 
      component={DailyStationScreen} 
      options={{ title: 'Daily Station' }}
    />
    <HomeStack.Screen 
      name="Newsletter" 
      component={NewsletterScreen} 
      options={{ title: 'Daily Cyber Brief' }}
    /> 
    <HomeStack.Screen 
      name="Resources" 
      component={ResourcesScreen} 
      options={{ title: 'Resources Hub' }}
    />
    <HomeStack.Screen 
      name="Tests" 
      component={TestNavigator} 
      options={{ headerShown: false }}
    />
  </HomeStack.Navigator>
);

// Profile Stack
const ProfileStackNavigator = () => (
  <ProfileStack.Navigator
    screenOptions={{
      headerStyle: {
        backgroundColor: '#1E1E1E',
        elevation: 0,
        shadowOpacity: 0,
      },
      headerTintColor: '#FFFFFF',
      headerTitleStyle: {
        fontWeight: 'bold',
      },
    }}
  >
    <ProfileStack.Screen 
      name="ProfileScreen" 
      component={ProfileScreen} 
      options={{ title: 'My Profile' }}
    />
    <ProfileStack.Screen 
      name="Achievements" 
      component={AchievementsScreen} 
      options={{ title: 'Achievements' }}
    />
    <ProfileStack.Screen 
      name="Support" 
      component={SupportScreen} 
      options={{ title: 'Support' }}
    />
    {/* Access daily station and newsletter from profile as well */}
    <ProfileStack.Screen 
      name="DailyStation" 
      component={DailyStationScreen} 
      options={{ title: 'Daily Station' }}
    />
    <ProfileStack.Screen 
      name="Newsletter" 
      component={NewsletterScreen} 
      options={{ title: 'Daily Cyber Brief' }}
    />
    <ProfileStack.Screen 
      name="Resources" 
      component={ResourcesScreen} 
      options={{ title: 'Resources Hub' }}
    />
  </ProfileStack.Navigator>
);

// Leaderboard Stack
const LeaderboardStackNavigator = () => (
  <LeaderboardStack.Navigator
    screenOptions={{
      headerStyle: {
        backgroundColor: '#1E1E1E',
        elevation: 0,
        shadowOpacity: 0,
      },
      headerTintColor: '#FFFFFF',
      headerTitleStyle: {
        fontWeight: 'bold',
      },
    }}
  >
    <LeaderboardStack.Screen 
      name="LeaderboardScreen" 
      component={LeaderboardScreen} 
      options={{ title: 'Leaderboard' }}
    />
  </LeaderboardStack.Navigator>
);

// Shop Stack
const ShopStackNavigator = () => (
  <ShopStack.Navigator
    screenOptions={{
      headerStyle: {
        backgroundColor: '#1E1E1E',
        elevation: 0,
        shadowOpacity: 0,
      },
      headerTintColor: '#FFFFFF',
      headerTitleStyle: {
        fontWeight: 'bold',
      },
    }}
  >
    <ShopStack.Screen 
      name="ShopScreen" 
      component={ShopScreen} 
      options={{ title: 'Shop' }}
    />
  </ShopStack.Navigator>
);

// Main Tab Navigator
const MainNavigator = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName;

          if (route.name === 'Home') {
            iconName = focused ? 'home' : 'home-outline';
          } else if (route.name === 'Profile') {
            iconName = focused ? 'person' : 'person-outline';
          } else if (route.name === 'Leaderboard') {
            iconName = focused ? 'trophy' : 'trophy-outline';
          } else if (route.name === 'Shop') {
            iconName = focused ? 'cart' : 'cart-outline';
          }

          return <Ionicons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: '#6543CC',
        tabBarInactiveTintColor: 'gray',
        tabBarStyle: {
          backgroundColor: '#1A1A1A',
          borderTopColor: '#333333',
        },
        headerShown: false,
      })}
    >
      <Tab.Screen name="Home" component={HomeStackNavigator} />
      <Tab.Screen name="Leaderboard" component={LeaderboardStackNavigator} />
      <Tab.Screen name="Shop" component={ShopStackNavigator} />
      <Tab.Screen name="Profile" component={ProfileStackNavigator} />
    </Tab.Navigator>
  );
};

export default MainNavigator;
</file>

<file path="src/navigation/TestNavigator.js">
// src/navigation/TestNavigator.js
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import TestListScreen from '../screens/tests/TestListScreen';
import TestScreen from '../screens/tests/TestScreen';

// Category screens
import APlusScreen from '../screens/tests/categories/APlusScreen';
import APlus2Screen from '../screens/tests/categories/APlus2Screen';
import NetworkPlusScreen from '../screens/tests/categories/NetworkPlusScreen';
import SecurityPlusScreen from '../screens/tests/categories/SecurityPlusScreen';
import CySAPlusScreen from '../screens/tests/categories/CySAPlusScreen';
import PenPlusScreen from '../screens/tests/categories/PenPlusScreen';
import CaspPlusScreen from '../screens/tests/categories/CaspPlusScreen';
import LinuxPlusScreen from '../screens/tests/categories/LinuxPlusScreen';
import CloudPlusScreen from '../screens/tests/categories/CloudPlusScreen';
import DataPlusScreen from '../screens/tests/categories/DataPlusScreen';
import ServerPlusScreen from '../screens/tests/categories/ServerPlusScreen';
import CisspScreen from '../screens/tests/categories/CisspScreen';
import AWSCloudScreen from '../screens/tests/categories/AWSCloudScreen';

const Stack = createStackNavigator();

const TestNavigator = () => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: '#1E1E1E',
          elevation: 0,
          shadowOpacity: 0,
        },
        headerTintColor: '#FFFFFF',
        headerTitleStyle: { fontWeight: 'bold' },
        cardStyle: { backgroundColor: '#121212' },
      }}
    >
      {/* Generic TestList - rarely used if you always go to category screens */}
      <Stack.Screen
        name="TestList"
        component={TestListScreen}
        options={({ route }) => ({
          title: route.params?.title || 'Practice Tests',
          headerBackTitleVisible: false,
        })}
      />

      {/* Individual test screen */}
      <Stack.Screen
        name="Test"
        component={TestScreen}
        options={({ route }) => ({
          title: route.params?.title || 'Test',
          headerBackTitleVisible: false,
          headerLeft: null,
          gestureEnabled: false,
        })}
      />

      {/* Category specific */}
      <Stack.Screen
        name="APlusTests"
        component={APlusScreen}
        options={{ title: 'A+ Core 1 (1101)', headerBackTitleVisible: false }}
        initialParams={{ category: 'aplus', title: 'CompTIA A+ Core 1 (1101)' }}
      />
      <Stack.Screen
        name="APlus2Tests"
        component={APlus2Screen}
        options={{ title: 'A+ Core 2 (1102)', headerBackTitleVisible: false }}
        initialParams={{ category: 'aplus2', title: 'CompTIA A+ Core 2 (1102)' }}
      />
      <Stack.Screen
        name="NetworkPlusTests"
        component={NetworkPlusScreen}
        options={{ title: 'Network+ (N10-009)', headerBackTitleVisible: false }}
        initialParams={{ category: 'nplus', title: 'Network+ (N10-009)' }}
      />
      <Stack.Screen
        name="SecurityPlusTests"
        component={SecurityPlusScreen}
        options={{ title: 'Security+ (SY0-701)', headerBackTitleVisible: false }}
        initialParams={{ category: 'secplus', title: 'Security+ (SY0-701)' }}
      />
      <Stack.Screen
        name="CySAPlusTests"
        component={CySAPlusScreen}
        options={{ title: 'CySA+ (CS0-003)', headerBackTitleVisible: false }}
        initialParams={{ category: 'cysa', title: 'CySA+ (CS0-003)' }}
      />
      <Stack.Screen
        name="PenPlusTests"
        component={PenPlusScreen}
        options={{ title: 'PenTest+ (PT0-003)', headerBackTitleVisible: false }}
        initialParams={{ category: 'penplus', title: 'PenTest+ (PT0-003)' }}
      />
      <Stack.Screen
        name="CaspPlusTests"
        component={CaspPlusScreen}
        options={{ title: 'CASP+ (CAS-005)', headerBackTitleVisible: false }}
        initialParams={{ category: 'caspplus', title: 'CASP+ (CAS-005)' }}
      />
      <Stack.Screen
        name="LinuxPlusTests"
        component={LinuxPlusScreen}
        options={{ title: 'Linux+ (XK0-005)', headerBackTitleVisible: false }}
        initialParams={{ category: 'linuxplus', title: 'Linux+ (XK0-005)' }}
      />
      <Stack.Screen
        name="CloudPlusTests"
        component={CloudPlusScreen}
        options={{ title: 'Cloud+ (CV0-004)', headerBackTitleVisible: false }}
        initialParams={{ category: 'cloudplus', title: 'Cloud+ (CV0-004)' }}
      />
      <Stack.Screen
        name="DataPlusTests"
        component={DataPlusScreen}
        options={{ title: 'Data+ (DA0-001)', headerBackTitleVisible: false }}
        initialParams={{ category: 'dataplus', title: 'Data+ (DA0-001)' }}
      />
      <Stack.Screen
        name="ServerPlusTests"
        component={ServerPlusScreen}
        options={{ title: 'Server+ (SK0-005)', headerBackTitleVisible: false }}
        initialParams={{ category: 'serverplus', title: 'Server+ (SK0-005)' }}
      />
      <Stack.Screen
        name="CisspTests"
        component={CisspScreen}
        options={{ title: 'CISSP', headerBackTitleVisible: false }}
        initialParams={{ category: 'cissp', title: 'CISSP' }}
      />
      <Stack.Screen
        name="AWSCloudTests"
        component={AWSCloudScreen}
        options={{ title: 'AWS Cloud Practitioner', headerBackTitleVisible: false }}
        initialParams={{ category: 'awscloud', title: 'AWS Cloud Practitioner' }}
      />
    </Stack.Navigator>
  );
};

export default TestNavigator;
</file>

<file path="src/screens/auth/CreateUsernameScreen.js">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  Image,
  ScrollView,
  SafeAreaView
} from 'react-native';
import { useDispatch, useSelector } from 'react-redux';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { useNavigation, useRoute } from '@react-navigation/native';
import { fetchUserData } from '../../store/slices/userSlice';
import * as SecureStore from 'expo-secure-store';

const CreateUsernameScreen = () => {
  const [username, setUsername] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [submitted, setSubmitted] = useState(false);
  
  const dispatch = useDispatch();
  const navigation = useNavigation();
  const route = useRoute();
  
  // Get userId and provider from route params
  const userId = route.params?.userId;
  const provider = route.params?.provider || 'oauth';
  
  useEffect(() => {
    if (!userId) {
      // If no userId, redirect to login
      navigation.navigate('Login');
    }
  }, [userId, navigation]);
  
  const validateUsername = (username) => {
    // Basic frontend validation
    if (!username || username.length < 3) {
      return "Username must be at least 3 characters long";
    }
    
    if (username.length > 30) {
      return "Username must be no more than 30 characters long";
    }
    
    // Letters, numbers, underscores, dots, and dashes only
    if (!/^[A-Za-z0-9._-]+$/.test(username)) {
      return "Username can only contain letters, numbers, dots, underscores, and dashes";
    }
    
    // No leading/trailing dots, underscores, or dashes
    if (/^[._-]|[._-]$/.test(username)) {
      return "Username cannot start or end with dots, underscores, or dashes";
    }
    
    // No triple repeats
    if (/(.)\1{2,}/.test(username)) {
      return "Username cannot contain three identical consecutive characters";
    }
    
    return null; // No errors
  };
  
  const handleSubmit = async () => {
    // Validate username
    const validationError = validateUsername(username);
    if (validationError) {
      setError(validationError);
      return;
    }
    
    setLoading(true);
    setError('');
    
    try {
      // Update username via API
      const response = await fetch('/api/test/user/change-username', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          userId: userId,
          newUsername: username,
        }),
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Failed to set username');
      }
      
      // Success! Mark as submitted
      setSubmitted(true);
      
      // Save userId to secure storage
      await SecureStore.setItemAsync('userId', userId);
      
      // Fetch the updated user data
      await dispatch(fetchUserData(userId));
      
      // Navigate to profile page after a brief delay (to show success message)
      setTimeout(() => {
        navigation.navigate('Home', {
          message: `Welcome! You've successfully created your account with ${
            provider.charAt(0).toUpperCase() + provider.slice(1)
          }`
        });
      }, 1500);
    } catch (err) {
      console.error('Error setting username:', err);
      setError(err.message || 'Failed to set username. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView 
          contentContainerStyle={styles.scrollContainer}
          keyboardShouldPersistTaps="handled"
        >
          <LinearGradient
            colors={['#121212', '#1a1a2e']}
            style={styles.gradientBackground}
          />
          
          <View style={styles.card}>
            <View style={styles.cardAccent} />
            
            <View style={styles.header}>
              <View style={styles.logoContainer}>
                <LinearGradient
                  colors={['#6543CC', '#8A58FC']}
                  style={styles.logoBackground}
                >
                  <Ionicons name="game-controller" size={30} color="#FFFFFF" style={styles.logoIconSecondary} />
                  <View style={styles.logoIconPrimaryContainer}>
                    <Ionicons name="shield" size={18} color="#FFFFFF" />
                  </View>
                </LinearGradient>
              </View>
              <Text style={styles.headerTitle}>Choose Your Gamer Tag</Text>
              <Text style={styles.subtitle}>
                Pick a unique username for your journey
              </Text>
            </View>
            
            {error && (
              <View style={styles.errorContainer}>
                <Ionicons name="alert-circle" size={20} color="#FF4C8B" />
                <Text style={styles.errorText}>{error}</Text>
              </View>
            )}
            
            {submitted ? (
              <View style={styles.successContainer}>
                <View style={styles.successIcon}>
                  <Ionicons name="checkmark" size={40} color="#FFFFFF" />
                </View>
                <Text style={styles.successTitle}>Username Set Successfully!</Text>
                <Text style={styles.successText}>Preparing your dashboard...</Text>
                <View style={styles.progressContainer}>
                  <View style={styles.progressBar}>
                    <View style={styles.progressFill} />
                  </View>
                </View>
              </View>
            ) : (
              <View style={styles.form}>
                <View style={styles.inputGroup}>
                  <View style={styles.labelContainer}>
                    <Text style={styles.label}>Username</Text>
                    <View style={styles.labelBadge}>
                      <Text style={styles.labelBadgeText}>Required</Text>
                    </View>
                  </View>
                  
                  <View style={styles.inputContainer}>
                    <Ionicons name="person" size={20} color="#AAAAAA" style={styles.inputIcon} />
                    <TextInput
                      style={styles.input}
                      placeholder="Choose a unique username"
                      placeholderTextColor="#AAAAAA"
                      value={username}
                      onChangeText={setUsername}
                      autoCapitalize="none"
                      returnKeyType="done"
                      editable={!loading}
                      autoFocus
                    />
                    {username && !validateUsername(username) && (
                      <Ionicons name="checkmark" size={20} color="#2ebb77" style={styles.validIcon} />
                    )}
                  </View>
                  
                  <View style={styles.inputHint}>
                    <Ionicons name="information-circle" size={16} color="#AAAAAA" />
                    <Text style={styles.hintText}>
                      3-30 characters, letters, numbers, dots, underscores, dashes
                    </Text>
                  </View>
                </View>
                
                <TouchableOpacity 
                  style={[styles.submitButton, loading && styles.disabledButton]}
                  onPress={handleSubmit}
                  disabled={loading}
                >
                  {loading ? (
                    <View style={styles.buttonContent}>
                      <ActivityIndicator color="#FFFFFF" />
                      <Text style={styles.buttonText}>Setting Username...</Text>
                    </View>
                  ) : (
                    <View style={styles.buttonContent}>
                      <Ionicons name="trophy" size={20} color="#FFFFFF" />
                      <Text style={styles.buttonText}>Set Username & Continue</Text>
                    </View>
                  )}
                </TouchableOpacity>
                
                <View style={styles.noteContainer}>
                  <Ionicons name="information-circle" size={18} color="#AAAAAA" />
                  <Text style={styles.noteText}>
                    You can change your username later from your profile settings
                  </Text>
                </View>
              </View>
            )}
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0b0c15',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContainer: {
    flexGrow: 1,
    justifyContent: 'center',
    padding: 20,
  },
  gradientBackground: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
  },
  card: {
    backgroundColor: '#171a23',
    borderRadius: 16,
    padding: 30,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.4,
    shadowRadius: 24,
    elevation: 5,
    position: 'relative',
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: '#2a2c3d',
  },
  cardAccent: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: 4,
    background: 'linear-gradient(135deg, #6543cc, #8a58fc)',
    backgroundColor: '#6543cc',
    zIndex: 1,
  },
  header: {
    alignItems: 'center',
    marginBottom: 25,
  },
  logoContainer: {
    marginBottom: 20,
    position: 'relative',
  },
  logoBackground: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#6543CC',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.5,
    shadowRadius: 15,
    elevation: 10,
    position: 'relative',
  },
  logoIconSecondary: {
    fontSize: 40,
  },
  logoIconPrimaryContainer: {
    position: 'absolute',
    top: -10,
    right: -10,
    backgroundColor: '#ff4c8b',
    width: 30,
    height: 30,
    borderRadius: 15,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 3,
    borderColor: '#171a23',
    shadowColor: '#ff4c8b',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.5,
    shadowRadius: 5,
    elevation: 5,
  },
  headerTitle: {
    fontSize: 26,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 10,
    textShadowColor: '#6543cc',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 10,
  },
  subtitle: {
    color: '#9da8b9',
    fontSize: 16,
    textAlign: 'center',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 76, 139, 0.1)',
    padding: 12,
    borderRadius: 8,
    marginBottom: 20,
    borderLeftWidth: 4,
    borderLeftColor: '#ff4e4e',
  },
  errorText: {
    color: '#FF4C8B',
    marginLeft: 10,
    flex: 1,
  },
  form: {
    width: '100%',
  },
  inputGroup: {
    marginBottom: 25,
  },
  labelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
  },
  labelBadge: {
    backgroundColor: '#6543cc',
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
  },
  labelBadgeText: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: 'bold',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0f101a',
    borderRadius: 8,
    height: 55,
    borderWidth: 1,
    borderColor: '#2a2c3d',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 12,
    elevation: 4,
  },
  inputIcon: {
    marginHorizontal: 15,
    fontSize: 20,
  },
  input: {
    flex: 1,
    height: 55,
    color: '#FFFFFF',
    fontSize: 16,
  },
  validIcon: {
    marginRight: 15,
  },
  inputHint: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 8,
    paddingLeft: 5,
  },
  hintText: {
    color: '#9da8b9',
    fontSize: 12,
    marginLeft: 5,
  },
  submitButton: {
    backgroundColor: '#6543cc',
    borderRadius: 30,
    height: 55,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: 'rgba(101, 67, 204, 0.4)',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.4,
    shadowRadius: 15,
    elevation: 8,
    position: 'relative',
    overflow: 'hidden',
  },
  disabledButton: {
    backgroundColor: 'rgba(101, 67, 204, 0.7)',
    opacity: 0.7,
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  noteContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    padding: 12,
    borderRadius: 8,
    marginTop: 20,
  },
  noteText: {
    color: '#9da8b9',
    fontSize: 13,
    marginLeft: 10,
    flex: 1,
  },
  successContainer: {
    alignItems: 'center',
    padding: 20,
  },
  successIcon: {
    width: 70,
    height: 70,
    borderRadius: 35,
    backgroundColor: '#2ebb77',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
    shadowColor: 'rgba(46, 187, 119, 0.4)',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.5,
    shadowRadius: 15,
    elevation: 10,
    animation: 'pulse 1.5s ease-in-out infinite',
  },
  successTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 10,
  },
  successText: {
    fontSize: 16,
    color: '#9da8b9',
    marginBottom: 20,
  },
  progressContainer: {
    width: '100%',
    height: 6,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 3,
    overflow: 'hidden',
  },
  progressBar: {
    height: '100%',
    width: '100%',
    borderRadius: 3,
    overflow: 'hidden',
    position: 'relative',
  },
  progressFill: {
    position: 'absolute',
    top: 0,
    left: 0,
    bottom: 0,
    width: '100%',
    backgroundImage: 'linear-gradient(90deg, #6543cc, #8a58fc, #6543cc)',
    backgroundSize: '200% 100%',
    animation: 'progress 1.5s linear infinite',
    transform: [{ translateX: '-100%' }],
  },
});

export default CreateUsernameScreen;
</file>

<file path="src/screens/auth/ForgotPasswordScreen.js">
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  Image,
  ScrollView,
  SafeAreaView
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { useNavigation } from '@react-navigation/native';
import { requestPasswordReset } from '../../api/passwordResetService';

const ForgotPasswordScreen = () => {
  const [email, setEmail] = useState('');
  const [sent, setSent] = useState(false);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  
  const navigation = useNavigation();
  
  const handleSubmit = async () => {
    if (!email) {
      setError('Please enter your email address.');
      return;
    }
    
    setLoading(true);
    setError('');
    
    try {
      const response = await requestPasswordReset(email);
      
      // Always show success even if email doesn't exist (security best practice)
      setSent(true);
    } catch (err) {
      setError(err.message || 'Failed to send reset link. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView contentContainerStyle={styles.scrollContainer}>
          <LinearGradient
            colors={['#121212', '#1a1a2e']}
            style={styles.gradientBackground}
          />
          
          <TouchableOpacity 
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={22} color="#AAAAAA" />
            <Text style={styles.backButtonText}>Back to Login</Text>
          </TouchableOpacity>
          
          <View style={styles.header}>
            <View style={styles.logoContainer}>
              <LinearGradient
                colors={['#6543CC', '#8A58FC']}
                style={styles.logoBackground}
              >
                <Ionicons name="key" size={30} color="#FFFFFF" />
              </LinearGradient>
            </View>
            <Text style={styles.headerTitle}>Reset Password</Text>
            <Text style={styles.subtitle}>
              Enter your email address to receive a password reset link
            </Text>
          </View>
          
          {sent ? (
            <View style={styles.successMessage}>
              <View style={styles.successIcon}>
                <Ionicons name="checkmark" size={40} color="#FFFFFF" />
              </View>
              <Text style={styles.successTitle}>Reset Link Sent!</Text>
              <Text style={styles.successText}>
                We've sent instructions to reset your password to <Text style={styles.emailHighlight}>{email}</Text>. 
                Please check your inbox and follow the link to complete the process.
              </Text>
              <Text style={styles.noteText}>
                If you don't see the email, please check your spam folder.
              </Text>
              
              <TouchableOpacity 
                style={styles.backToLoginButton}
                onPress={() => navigation.navigate('Login')}
              >
                <Text style={styles.backToLoginText}>Back to Login</Text>
              </TouchableOpacity>
            </View>
          ) : (
            <>
              {error && (
                <View style={styles.errorContainer}>
                  <Ionicons name="alert-circle" size={20} color="#FF4C8B" />
                  <Text style={styles.errorText}>{error}</Text>
                </View>
              )}
              
              <View style={styles.form}>
                <View style={styles.inputContainer}>
                  <Ionicons name="mail-outline" size={20} color="#AAAAAA" style={styles.inputIcon} />
                  <TextInput
                    style={styles.input}
                    placeholder="Enter your registered email"
                    placeholderTextColor="#AAAAAA"
                    value={email}
                    onChangeText={setEmail}
                    autoCapitalize="none"
                    keyboardType="email-address"
                    returnKeyType="done"
                    editable={!loading}
                  />
                </View>
                
                <TouchableOpacity 
                  style={[styles.resetButton, loading && styles.disabledButton]}
                  onPress={handleSubmit}
                  disabled={loading}
                >
                  {loading ? (
                    <View style={styles.buttonContent}>
                      <ActivityIndicator color="#FFFFFF" />
                      <Text style={styles.buttonText}>Sending...</Text>
                    </View>
                  ) : (
                    <View style={styles.buttonContent}>
                      <Text style={styles.buttonText}>Send Reset Link</Text>
                      <Ionicons name="chevron-forward" size={18} color="#FFFFFF" />
                    </View>
                  )}
                </TouchableOpacity>
              </View>
            </>
          )}
          
          <View style={styles.linksContainer}>
            <Text style={styles.linkText}>Remember your password?</Text>
            <TouchableOpacity onPress={() => navigation.navigate('Login')}>
              <Text style={styles.linkButton}>Sign In</Text>
            </TouchableOpacity>
          </View>
          
          <View style={styles.registerContainer}>
            <Text style={styles.linkText}>Don't have an account?</Text>
            <TouchableOpacity onPress={() => navigation.navigate('Register')}>
              <Text style={styles.linkButton}>Create Account</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContainer: {
    flexGrow: 1,
    padding: 20,
  },
  gradientBackground: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
  },
  backButton: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 20,
  },
  backButtonText: {
    color: '#AAAAAA',
    marginLeft: 8,
    fontSize: 16,
  },
  header: {
    alignItems: 'center',
    marginBottom: 30,
  },
  logoContainer: {
    marginBottom: 20,
  },
  logoBackground: {
    width: 70,
    height: 70,
    borderRadius: 35,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#6543CC',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.5,
    shadowRadius: 15,
    elevation: 10,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#AAAAAA',
    textAlign: 'center',
    maxWidth: '80%',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 76, 139, 0.1)',
    padding: 10,
    borderRadius: 8,
    marginBottom: 20,
  },
  errorText: {
    color: '#FF4C8B',
    marginLeft: 10,
    flex: 1,
  },
  form: {
    width: '100%',
    marginBottom: 20,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#2A2A2A',
    borderRadius: 8,
    marginBottom: 20,
    height: 50,
  },
  inputIcon: {
    marginHorizontal: 15,
  },
  input: {
    flex: 1,
    height: 50,
    color: '#FFFFFF',
    paddingRight: 15,
  },
  resetButton: {
    backgroundColor: '#6543CC',
    height: 50,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  disabledButton: {
    backgroundColor: '#4F4F4F',
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  successMessage: {
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
    borderRadius: 12,
    padding: 20,
    alignItems: 'center',
    marginBottom: 20,
    borderLeftWidth: 3,
    borderLeftColor: '#2ebb77',
  },
  successIcon: {
    width: 64,
    height: 64,
    borderRadius: 32,
    backgroundColor: '#2ebb77',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
  },
  successTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 15,
  },
  successText: {
    fontSize: 15,
    color: '#AAAAAA',
    textAlign: 'center',
    marginBottom: 10,
    lineHeight: 22,
  },
  emailHighlight: {
    color: '#FFFFFF',
    fontWeight: '500',
  },
  noteText: {
    fontSize: 14,
    color: '#AAAAAA',
    fontStyle: 'italic',
    marginBottom: 20,
  },
  backToLoginButton: {
    backgroundColor: 'rgba(101, 67, 204, 0.2)',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#6543CC',
  },
  backToLoginText: {
    color: '#6543CC',
    fontWeight: 'bold',
    fontSize: 16,
  },
  linksContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 20,
  },
  linkText: {
    color: '#AAAAAA',
  },
  linkButton: {
    color: '#6543CC',
    fontWeight: 'bold',
    marginLeft: 6,
  },
  registerContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 15,
    paddingTop: 15,
    borderTopWidth: 1,
    borderTopColor: 'rgba(170, 170, 170, 0.2)',
  },
});

export default ForgotPasswordScreen;
</file>

<file path="src/screens/auth/LoginScreen.js">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  Image,
  ScrollView,
  SafeAreaView
} from 'react-native';
import { useDispatch, useSelector } from 'react-redux';
import { loginUser, clearAuthErrors } from '../../store/slices/userSlice';
import * as SecureStore from 'expo-secure-store';
import * as LocalAuthentication from 'expo-local-authentication';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import * as AppleAuthentication from 'expo-apple-authentication';
import * as WebBrowser from 'expo-web-browser';
import * as Linking from 'expo-linking';
import { API } from '../../api/apiConfig';
import { useNavigation } from '@react-navigation/native';

WebBrowser.maybeCompleteAuthSession();

const LoginScreen = () => {
  const [usernameOrEmail, setUsernameOrEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [isBiometricAvailable, setIsBiometricAvailable] = useState(false);
  const [savedCredentials, setSavedCredentials] = useState(null);
  const [appleAuthAvailable, setAppleAuthAvailable] = useState(false);
  
  const dispatch = useDispatch();
  const navigation = useNavigation();
  const { loading, error } = useSelector((state) => state.user);
  
  // URL for OAuth redirect
  const redirectUri = Linking.createURL('/oauth-callback');

  useEffect(() => {
    // Clear any auth errors when component mounts
    dispatch(clearAuthErrors());
    
    // Check for biometric availability
    checkBiometricAvailability();
    
    // Check for saved credentials
    checkForSavedCredentials();
    
    // Check for Apple Authentication availability
    checkAppleAuthAvailability();
    
    // Set up deep linking handler for OAuth redirects
    const subscription = Linking.addEventListener('url', handleRedirect);
    
    return () => {
      subscription.remove();
    };
  }, []);

  const checkBiometricAvailability = async () => {
    const available = await LocalAuthentication.hasHardwareAsync();
    const isEnrolled = await LocalAuthentication.isEnrolledAsync();
    setIsBiometricAvailable(available && isEnrolled);
  };
  
  const checkAppleAuthAvailability = async () => {
    const available = await AppleAuthentication.isAvailableAsync();
    setAppleAuthAvailable(available);
  };
  
  const checkForSavedCredentials = async () => {
    try {
      const credentials = await SecureStore.getItemAsync('userCredentials');
      if (credentials) {
        const parsed = JSON.parse(credentials);
        setSavedCredentials(parsed);
      }
    } catch (error) {
      console.error('Error retrieving saved credentials:', error);
    }
  };
  
  const handleBiometricAuth = async () => {
    if (!savedCredentials) {
      Alert.alert('No Saved Credentials', 'Please log in with your username and password first.');
      return;
    }
    
    try {
      const result = await LocalAuthentication.authenticateAsync({
        promptMessage: 'Authenticate to login',
        fallbackLabel: 'Use password'
      });
      
      if (result.success) {
        // If biometric auth succeeded, use saved credentials to log in
        dispatch(loginUser({
          usernameOrEmail: savedCredentials.usernameOrEmail,
          password: savedCredentials.password
        }));
      }
    } catch (error) {
      console.error('Biometric authentication error:', error);
      Alert.alert('Authentication Failed', 'Please try again or use your password.');
    }
  };

  const handleLogin = async () => {
    if (!usernameOrEmail || !password) {
      Alert.alert('Error', 'Please enter both username/email and password');
      return;
    }
    
    try {
      await dispatch(loginUser({ usernameOrEmail, password })).unwrap();
      
      // If login successful, save credentials for biometric login
      await SecureStore.setItemAsync('userCredentials', JSON.stringify({
        usernameOrEmail,
        password
      }));
      
      // Navigation is handled by the app navigator once user is set in Redux
    } catch (err) {
      // Error is already handled in the reducer
    }
  };
  
  const handleGoogleLogin = async () => {
    try {
      // Launch web browser for Google OAuth
      const result = await WebBrowser.openAuthSessionAsync(
        `${API.AUTH.OAUTH_GOOGLE}?redirect_uri=${encodeURIComponent(redirectUri)}`,
        redirectUri
      );
      
      if (result.type === 'success') {
        // Handle success, parsing any query params if needed
        // This might be handled by the deep link handler instead
      }
    } catch (error) {
      console.error('Google login error:', error);
      Alert.alert('Login Failed', 'Google sign-in could not be completed.');
    }
  };
  
  const handleAppleLogin = async () => {
    try {
      const credential = await AppleAuthentication.signInAsync({
        requestedScopes: [
          AppleAuthentication.AppleAuthenticationScope.FULL_NAME,
          AppleAuthentication.AppleAuthenticationScope.EMAIL,
        ],
      });
      
      // Send the credential to your backend
      const response = await fetch(`${API.AUTH.OAUTH_APPLE}/mobile`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          identityToken: credential.identityToken,
          fullName: credential.fullName,
          email: credential.email,
        }),
      });
      
      const data = await response.json();
      
      if (response.ok) {
        // Handle success, user ID would be in data.userId
        await SecureStore.setItemAsync('userId', data.userId);
        dispatch({ type: 'user/setCurrentUserId', payload: data.userId });
        
        // If the user needs to set a username (new user), navigate to that screen
        if (data.needsUsername) {
          navigation.navigate('CreateUsername', { 
            userId: data.userId, 
            provider: 'apple' 
          });
        }
      } else {
        throw new Error(data.error || 'Apple sign-in failed');
      }
    } catch (error) {
      console.error('Apple login error:', error);
      Alert.alert('Login Failed', error.message || 'Apple sign-in could not be completed.');
    }
  };
  
  const handleRedirect = (event) => {
    // Extract userId and other params from the URL
    const { url } = event;
    const params = Linking.parse(url).queryParams;
    
    if (params.userId) {
      // Store user ID and set in Redux
      SecureStore.setItemAsync('userId', params.userId);
      dispatch({ type: 'user/setCurrentUserId', payload: params.userId });
      
      // If the user needs to set a username, navigate to that screen
      if (params.needsUsername === 'true') {
        navigation.navigate('CreateUsername', { 
          userId: params.userId, 
          provider: params.provider 
        });
      }
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView contentContainerStyle={styles.scrollContainer}>
          <LinearGradient
            colors={['#121212', '#1a1a2e']}
            style={styles.gradientBackground}
          />
          
          <View style={styles.logoContainer}>
            <Image 
              source={require('../../../assets/logo.png')} 
              style={styles.logo}
              resizeMode="contain"
            />
            <Text style={styles.appName}>CertGames</Text>
          </View>
          
          <Text style={styles.welcomeText}>Welcome Back</Text>
          <Text style={styles.subtitleText}>Sign in to continue your certification journey</Text>
          
          {error && (
            <View style={styles.errorContainer}>
              <Ionicons name="alert-circle" size={20} color="#FF4C8B" />
              <Text style={styles.errorText}>{error}</Text>
            </View>
          )}
          
          <View style={styles.form}>
            <View style={styles.inputContainer}>
              <Ionicons name="person-outline" size={20} color="#AAAAAA" style={styles.inputIcon} />
              <TextInput
                style={styles.input}
                placeholder="Username or Email"
                placeholderTextColor="#AAAAAA"
                value={usernameOrEmail}
                onChangeText={setUsernameOrEmail}
                autoCapitalize="none"
                keyboardType="email-address"
                returnKeyType="next"
                editable={!loading}
              />
            </View>
            
            <View style={styles.inputContainer}>
              <Ionicons name="lock-closed-outline" size={20} color="#AAAAAA" style={styles.inputIcon} />
              <TextInput
                style={styles.input}
                placeholder="Password"
                placeholderTextColor="#AAAAAA"
                value={password}
                onChangeText={setPassword}
                secureTextEntry={!showPassword}
                autoCapitalize="none"
                returnKeyType="done"
                editable={!loading}
              />
              <TouchableOpacity 
                style={styles.passwordToggle}
                onPress={() => setShowPassword(!showPassword)}
              >
                <Ionicons 
                  name={showPassword ? "eye-off-outline" : "eye-outline"} 
                  size={20} 
                  color="#AAAAAA" 
                />
              </TouchableOpacity>
            </View>
            
            <TouchableOpacity 
              style={styles.forgotPasswordContainer}
              onPress={() => navigation.navigate('ForgotPassword')}
            >
              <Text style={styles.forgotPasswordText}>Forgot Password?</Text>
            </TouchableOpacity>
            
            <TouchableOpacity 
              style={[styles.loginButton, loading && styles.disabledButton]}
              onPress={handleLogin}
              disabled={loading}
            >
              {loading ? (
                <ActivityIndicator color="#FFFFFF" />
              ) : (
                <Text style={styles.loginButtonText}>Sign In</Text>
              )}
            </TouchableOpacity>
            
            {isBiometricAvailable && savedCredentials && (
              <TouchableOpacity 
                style={styles.biometricButton}
                onPress={handleBiometricAuth}
              >
                <Ionicons 
                  name={Platform.OS === 'ios' ? "ios-face-id" : "ios-finger-print"} 
                  size={24} 
                  color="#6543CC" 
                />
                <Text style={styles.biometricText}>
                  Sign in with {Platform.OS === 'ios' ? 'Face ID' : 'Touch ID'}
                </Text>
              </TouchableOpacity>
            )}
            
            <View style={styles.dividerContainer}>
              <View style={styles.divider} />
              <Text style={styles.dividerText}>OR</Text>
              <View style={styles.divider} />
            </View>
            
            <View style={styles.socialButtonsContainer}>
              <TouchableOpacity 
                style={styles.socialButton}
                onPress={handleGoogleLogin}
                disabled={loading}
              >
                <Ionicons name="logo-google" size={20} color="#FFFFFF" />
                <Text style={styles.socialButtonText}>Google</Text>
              </TouchableOpacity>
              
              {appleAuthAvailable && (
                <TouchableOpacity 
                  style={styles.socialButton}
                  onPress={handleAppleLogin}
                  disabled={loading}
                >
                  <Ionicons name="logo-apple" size={20} color="#FFFFFF" />
                  <Text style={styles.socialButtonText}>Apple</Text>
                </TouchableOpacity>
              )}
            </View>
            
            <View style={styles.registerContainer}>
              <Text style={styles.registerText}>Don't have an account? </Text>
              <TouchableOpacity onPress={() => navigation.navigate('Register')}>
                <Text style={styles.registerLink}>Create Account</Text>
              </TouchableOpacity>
            </View>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContainer: {
    flexGrow: 1,
    justifyContent: 'center',
    padding: 20,
  },
  gradientBackground: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 40,
  },
  logo: {
    width: 100,
    height: 100,
  },
  appName: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginTop: 10,
  },
  welcomeText: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#FFFFFF',
    textAlign: 'center',
  },
  subtitleText: {
    fontSize: 16,
    color: '#AAAAAA',
    textAlign: 'center',
    marginBottom: 30,
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 76, 139, 0.1)',
    padding: 10,
    borderRadius: 8,
    marginBottom: 20,
  },
  errorText: {
    color: '#FF4C8B',
    marginLeft: 10,
    flex: 1,
  },
  form: {
    width: '100%',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#2A2A2A',
    borderRadius: 8,
    marginBottom: 16,
    height: 50,
  },
  inputIcon: {
    marginHorizontal: 15,
  },
  input: {
    flex: 1,
    height: 50,
    color: '#FFFFFF',
    paddingRight: 15,
  },
  passwordToggle: {
    padding: 15,
  },
  forgotPasswordContainer: {
    alignSelf: 'flex-end',
    marginBottom: 20,
  },
  forgotPasswordText: {
    color: '#6543CC',
    fontSize: 14,
  },
  loginButton: {
    backgroundColor: '#6543CC',
    height: 50,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  disabledButton: {
    backgroundColor: '#4F4F4F',
  },
  loginButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  biometricButton: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(101, 67, 204, 0.1)',
    borderWidth: 1,
    borderColor: '#6543CC',
    borderRadius: 8,
    padding: 12,
    marginTop: 15,
  },
  biometricText: {
    color: '#6543CC',
    marginLeft: 10,
    fontSize: 14,
    fontWeight: '500',
  },
  dividerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 20,
  },
  divider: {
    flex: 1,
    height: 1,
    backgroundColor: '#333333',
  },
  dividerText: {
    color: '#AAAAAA',
    paddingHorizontal: 10,
    fontSize: 14,
  },
  socialButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 20,
    gap: 15,
  },
  socialButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#2A2A2A',
    height: 50,
    borderRadius: 8,
    gap: 10,
  },
  socialButtonText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  registerContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 20,
  },
  registerText: {
    color: '#AAAAAA',
  },
  registerLink: {
    color: '#6543CC',
    fontWeight: 'bold',
  },
});

export default LoginScreen;
</file>

<file path="src/screens/auth/RegisterScreen.js">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  Image,
  ScrollView,
  SafeAreaView
} from 'react-native';
import { useDispatch, useSelector } from 'react-redux';
import { registerUser, clearAuthErrors } from '../../store/slices/userSlice';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import * as WebBrowser from 'expo-web-browser';
import * as Linking from 'expo-linking';
import * as AppleAuthentication from 'expo-apple-authentication';
import { API } from '../../api/apiConfig';
import { useNavigation } from '@react-navigation/native';

WebBrowser.maybeCompleteAuthSession();

const RegisterScreen = () => {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [agreeTerms, setAgreeTerms] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [formError, setFormError] = useState('');
  const [showPasswordRequirements, setShowPasswordRequirements] = useState(false);
  const [appleAuthAvailable, setAppleAuthAvailable] = useState(false);
  const [passwordValidation, setPasswordValidation] = useState({
    hasMinimumLength: false,
    hasUpperCase: false,
    hasLowerCase: false,
    hasNumber: false,
    hasSpecialChar: false
  });
  
  const dispatch = useDispatch();
  const navigation = useNavigation();
  
  const { loading, error } = useSelector((state) => state.user);
  
  // URL for OAuth redirect
  const redirectUri = Linking.createURL('/oauth-callback');

  // Clear errors when component mounts or unmounts
  useEffect(() => {
    dispatch(clearAuthErrors());
    checkAppleAuthAvailability();
    
    // Set up deep linking handler for OAuth redirects
    const subscription = Linking.addEventListener('url', handleRedirect);
    
    return () => {
      subscription.remove();
      dispatch(clearAuthErrors());
    };
  }, [dispatch]);
  
  // Check Apple Authentication availability
  const checkAppleAuthAvailability = async () => {
    const available = await AppleAuthentication.isAvailableAsync();
    setAppleAuthAvailable(available);
  };
  
  // Update password validation whenever password changes
  useEffect(() => {
    setPasswordValidation({
      hasMinimumLength: password.length >= 6,
      hasUpperCase: /[A-Z]/.test(password),
      hasLowerCase: /[a-z]/.test(password),
      hasNumber: /[0-9]/.test(password),
      hasSpecialChar: /[!@#$%^&*()\-_=+[\]{}|;:'",<.>/?`~\\]/.test(password)
    });
  }, [password]);

  const passwordIsValid = () => {
    return Object.values(passwordValidation).every(val => val === true);
  };
  
  const validateForm = () => {
    // Check if all fields are filled
    if (!username || !email || !password || !confirmPassword) {
      setFormError('All fields are required');
      return false;
    }
    
    // Check if password meets requirements
    if (!passwordIsValid()) {
      setFormError('Password does not meet all requirements');
      setShowPasswordRequirements(true);
      return false;
    }
    
    // Check if passwords match
    if (password !== confirmPassword) {
      setFormError('Passwords do not match');
      return false;
    }
    
    // Check if terms are agreed to
    if (!agreeTerms) {
      setFormError('You must agree to the Terms and Conditions');
      return false;
    }
    
    return true;
  };
  
  const handleSubmit = async () => {
    setFormError('');
    
    if (!validateForm()) {
      return;
    }
    
    try {
      const resultAction = await dispatch(registerUser({
        username,
        email,
        password,
        confirmPassword: confirmPassword
      })).unwrap();
      
      // Registration successful, now navigate to login
      Alert.alert(
        'Registration Successful', 
        'Your account has been created. Please log in.',
        [{ text: 'OK', onPress: () => navigation.navigate('Login') }]
      );
    } catch (err) {
      // Error is handled by the reducer and/or local formError
      if (err.includes("Email is already taken") || 
          err.includes("Username or email is already taken") ||
          err.includes("already taken")) {
        setFormError('Email address is already registered. Please use a different email or login.');
      } else {
        setFormError(err || 'Registration failed. Please try again.');
      }
    }
  };
  
  const handleGoogleSignUp = async () => {
    try {
      // Launch web browser for Google OAuth
      const result = await WebBrowser.openAuthSessionAsync(
        `${API.AUTH.OAUTH_GOOGLE}?redirect_uri=${encodeURIComponent(redirectUri)}`,
        redirectUri
      );
      
      if (result.type === 'success') {
        // Handle success, parsing any query params if needed
        // This might be handled by the deep link handler instead
      }
    } catch (error) {
      console.error('Google sign up error:', error);
      Alert.alert('Sign Up Failed', 'Google sign up could not be completed.');
    }
  };
  
  const handleAppleSignUp = async () => {
    try {
      const credential = await AppleAuthentication.signInAsync({
        requestedScopes: [
          AppleAuthentication.AppleAuthenticationScope.FULL_NAME,
          AppleAuthentication.AppleAuthenticationScope.EMAIL,
        ],
      });
      
      // Send the credential to your backend
      const response = await fetch(`${API.AUTH.OAUTH_APPLE}/mobile`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          identityToken: credential.identityToken,
          fullName: credential.fullName,
          email: credential.email,
        }),
      });
      
      const data = await response.json();
      
      if (response.ok) {
        // Handle success, user ID would be in data.userId
        await SecureStore.setItemAsync('userId', data.userId);
        dispatch({ type: 'user/setCurrentUserId', payload: data.userId });
        
        // New user from OAuth always needs to set a username
        navigation.navigate('CreateUsername', { 
          userId: data.userId, 
          provider: 'apple' 
        });
      } else {
        throw new Error(data.error || 'Apple sign-in failed');
      }
    } catch (error) {
      console.error('Apple sign up error:', error);
      Alert.alert('Sign Up Failed', error.message || 'Apple sign up could not be completed.');
    }
  };
  
  const handleRedirect = (event) => {
    // Extract userId and other params from the URL
    const { url } = event;
    const params = Linking.parse(url).queryParams;
    
    if (params.userId) {
      // Store user ID and set in Redux
      SecureStore.setItemAsync('userId', params.userId);
      dispatch({ type: 'user/setCurrentUserId', payload: params.userId });
      
      // New user from OAuth always needs to set a username
      navigation.navigate('CreateUsername', { 
        userId: params.userId, 
        provider: params.provider || 'google'
      });
    }
  };

  const openTermsAndConditions = () => {
    navigation.navigate('Terms');
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView contentContainerStyle={styles.scrollContainer}>
          <LinearGradient
            colors={['#121212', '#1a1a2e']}
            style={styles.gradientBackground}
          />
          
          <View style={styles.header}>
            <Image 
              source={require('../../../assets/logo.png')} 
              style={styles.logo}
              resizeMode="contain"
            />
            <Text style={styles.headerTitle}>Create Account</Text>
            <Text style={styles.subtitle}>Join and start your certification journey</Text>
          </View>
          
          {(formError || error) && (
            <View style={styles.errorContainer}>
              <Ionicons name="alert-circle" size={20} color="#FF4C8B" />
              <Text style={styles.errorText}>{formError || error}</Text>
            </View>
          )}
          
          <View style={styles.form}>
            <View style={styles.inputContainer}>
              <Ionicons name="person-outline" size={20} color="#AAAAAA" style={styles.inputIcon} />
              <TextInput
                style={styles.input}
                placeholder="Choose a unique username"
                placeholderTextColor="#AAAAAA"
                value={username}
                onChangeText={setUsername}
                autoCapitalize="none"
                returnKeyType="next"
                editable={!loading}
              />
            </View>
            
            <View style={styles.inputHint}>
              <Ionicons name="information-circle-outline" size={16} color="#AAAAAA" />
              <Text style={styles.hintText}>3-30 characters, letters, numbers, dots, underscores, dashes</Text>
            </View>
            
            <View style={styles.inputContainer}>
              <Ionicons name="mail-outline" size={20} color="#AAAAAA" style={styles.inputIcon} />
              <TextInput
                style={styles.input}
                placeholder="Enter your email address"
                placeholderTextColor="#AAAAAA"
                value={email}
                onChangeText={setEmail}
                autoCapitalize="none"
                keyboardType="email-address"
                returnKeyType="next"
                editable={!loading}
              />
            </View>
            
            <View style={styles.inputContainer}>
              <Ionicons name="lock-closed-outline" size={20} color="#AAAAAA" style={styles.inputIcon} />
              <TextInput
                style={styles.input}
                placeholder="Create a strong password"
                placeholderTextColor="#AAAAAA"
                value={password}
                onChangeText={setPassword}
                secureTextEntry={!showPassword}
                autoCapitalize="none"
                returnKeyType="next"
                editable={!loading}
                onFocus={() => setShowPasswordRequirements(true)}
                onBlur={() => {
                  // Keep requirements visible if there's text or error
                  if (!password) {
                    setShowPasswordRequirements(false);
                  }
                }}
              />
              <TouchableOpacity 
                style={styles.passwordToggle}
                onPress={() => setShowPassword(!showPassword)}
              >
                <Ionicons 
                  name={showPassword ? "eye-off-outline" : "eye-outline"} 
                  size={20} 
                  color="#AAAAAA" 
                />
              </TouchableOpacity>
            </View>
            
            {showPasswordRequirements && (
              <View style={styles.requirementsContainer}>
                <View style={styles.requirementsHeader}>
                  <Text style={styles.requirementsTitle}>Password Requirements:</Text>
                  {passwordIsValid() ? (
                    <View style={styles.validStatus}>
                      <Ionicons name="checkmark" size={14} color="#2ebb77" />
                      <Text style={styles.validText}>Valid</Text>
                    </View>
                  ) : (
                    <View style={styles.invalidStatus}>
                      <Ionicons name="close" size={14} color="#ff4e4e" />
                      <Text style={styles.invalidText}>Invalid</Text>
                    </View>
                  )}
                </View>
                
                <View style={styles.requirementsList}>
                  <View style={styles.requirementItem}>
                    <Ionicons 
                      name={passwordValidation.hasMinimumLength ? "checkmark-circle" : "close-circle"} 
                      size={16} 
                      color={passwordValidation.hasMinimumLength ? "#2ebb77" : "#ff4e4e"} 
                    />
                    <Text style={[
                      styles.requirementText,
                      passwordValidation.hasMinimumLength ? styles.validRequirement : styles.invalidRequirement
                    ]}>
                      At least 6 characters long
                    </Text>
                  </View>
                  
                  <View style={styles.requirementItem}>
                    <Ionicons 
                      name={passwordValidation.hasUpperCase ? "checkmark-circle" : "close-circle"} 
                      size={16} 
                      color={passwordValidation.hasUpperCase ? "#2ebb77" : "#ff4e4e"} 
                    />
                    <Text style={[
                      styles.requirementText,
                      passwordValidation.hasUpperCase ? styles.validRequirement : styles.invalidRequirement
                    ]}>
                      At least one uppercase letter
                    </Text>
                  </View>
                  
                  <View style={styles.requirementItem}>
                    <Ionicons 
                      name={passwordValidation.hasLowerCase ? "checkmark-circle" : "close-circle"} 
                      size={16} 
                      color={passwordValidation.hasLowerCase ? "#2ebb77" : "#ff4e4e"} 
                    />
                    <Text style={[
                      styles.requirementText,
                      passwordValidation.hasLowerCase ? styles.validRequirement : styles.invalidRequirement
                    ]}>
                      At least one lowercase letter
                    </Text>
                  </View>
                  
                  <View style={styles.requirementItem}>
                    <Ionicons 
                      name={passwordValidation.hasNumber ? "checkmark-circle" : "close-circle"} 
                      size={16} 
                      color={passwordValidation.hasNumber ? "#2ebb77" : "#ff4e4e"} 
                    />
                    <Text style={[
                      styles.requirementText,
                      passwordValidation.hasNumber ? styles.validRequirement : styles.invalidRequirement
                    ]}>
                      At least one number
                    </Text>
                  </View>
                  
                  <View style={styles.requirementItem}>
                    <Ionicons 
                      name={passwordValidation.hasSpecialChar ? "checkmark-circle" : "close-circle"} 
                      size={16} 
                      color={passwordValidation.hasSpecialChar ? "#2ebb77" : "#ff4e4e"} 
                    />
                    <Text style={[
                      styles.requirementText,
                      passwordValidation.hasSpecialChar ? styles.validRequirement : styles.invalidRequirement
                    ]}>
                      At least one special character
                    </Text>
                  </View>
                </View>
              </View>
            )}
            
            <View style={styles.inputContainer}>
              <Ionicons name="lock-closed-outline" size={20} color="#AAAAAA" style={styles.inputIcon} />
              <TextInput
                style={styles.input}
                placeholder="Confirm your password"
                placeholderTextColor="#AAAAAA"
                value={confirmPassword}
                onChangeText={setConfirmPassword}
                secureTextEntry={!showConfirmPassword}
                autoCapitalize="none"
                returnKeyType="done"
                editable={!loading}
              />
              <TouchableOpacity 
                style={styles.passwordToggle}
                onPress={() => setShowConfirmPassword(!showConfirmPassword)}
              >
                <Ionicons 
                  name={showConfirmPassword ? "eye-off-outline" : "eye-outline"} 
                  size={20} 
                  color="#AAAAAA" 
                />
              </TouchableOpacity>
            </View>
            
            {password && confirmPassword && (
              <View style={[
                styles.passwordMatch,
                password === confirmPassword ? styles.matchSuccess : styles.matchError
              ]}>
                <Ionicons 
                  name={password === confirmPassword ? "checkmark-circle" : "close-circle"} 
                  size={16} 
                  color={password === confirmPassword ? "#2ebb77" : "#ff4e4e"} 
                />
                <Text style={[
                  styles.matchText,
                  password === confirmPassword ? styles.matchSuccessText : styles.matchErrorText
                ]}>
                  {password === confirmPassword ? "Passwords match" : "Passwords don't match"}
                </Text>
              </View>
            )}
            
            <View style={styles.termsContainer}>
              <TouchableOpacity 
                style={styles.checkbox} 
                onPress={() => setAgreeTerms(!agreeTerms)}
              >
                {agreeTerms ? (
                  <Ionicons name="checkbox" size={24} color="#6543CC" />
                ) : (
                  <Ionicons name="square-outline" size={24} color="#AAAAAA" />
                )}
              </TouchableOpacity>
              <View style={styles.termsTextContainer}>
                <Text style={styles.termsText}>
                  I agree to the {' '}
                  <Text style={styles.termsLink} onPress={openTermsAndConditions}>
                    Terms and Conditions
                  </Text>
                </Text>
              </View>
            </View>
            
            <TouchableOpacity 
              style={[styles.registerButton, loading && styles.disabledButton]}
              onPress={handleSubmit}
              disabled={loading}
            >
              {loading ? (
                <View style={styles.buttonContent}>
                  <ActivityIndicator color="#FFFFFF" />
                  <Text style={styles.buttonText}>Creating Account...</Text>
                </View>
              ) : (
                <View style={styles.buttonContent}>
                  <Text style={styles.buttonText}>Create Account</Text>
                  <Ionicons name="chevron-forward" size={18} color="#FFFFFF" />
                </View>
              )}
            </TouchableOpacity>
          </View>
          
          <View style={styles.dividerContainer}>
            <View style={styles.divider} />
            <Text style={styles.dividerText}>or sign up with</Text>
            <View style={styles.divider} />
          </View>
          
          <View style={styles.socialButtonsContainer}>
            <TouchableOpacity 
              style={styles.socialButton}
              onPress={handleGoogleSignUp}
              disabled={loading}
            >
              <Ionicons name="logo-google" size={20} color="#FFFFFF" />
              <Text style={styles.socialButtonText}>Google</Text>
            </TouchableOpacity>
            
            {appleAuthAvailable && (
              <TouchableOpacity 
                style={styles.socialButton}
                onPress={handleAppleSignUp}
                disabled={loading}
              >
                <Ionicons name="logo-apple" size={20} color="#FFFFFF" />
                <Text style={styles.socialButtonText}>Apple</Text>
              </TouchableOpacity>
            )}
          </View>
          
          <View style={styles.loginContainer}>
            <Text style={styles.loginText}>Already have an account? </Text>
            <TouchableOpacity onPress={() => navigation.navigate('Login')}>
              <Text style={styles.loginLink}>Sign In</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContainer: {
    flexGrow: 1,
    padding: 20,
  },
  gradientBackground: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  logo: {
    width: 70,
    height: 70,
    marginBottom: 10,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  subtitle: {
    fontSize: 16,
    color: '#AAAAAA',
    marginTop: 5,
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 76, 139, 0.1)',
    padding: 10,
    borderRadius: 8,
    marginBottom: 20,
  },
  errorText: {
    color: '#FF4C8B',
    marginLeft: 10,
    flex: 1,
  },
  form: {
    width: '100%',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#2A2A2A',
    borderRadius: 8,
    marginBottom: 10,
    height: 50,
  },
  inputIcon: {
    marginHorizontal: 15,
  },
  input: {
    flex: 1,
    height: 50,
    color: '#FFFFFF',
    paddingRight: 15,
  },
  passwordToggle: {
    padding: 15,
  },
  inputHint: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 15,
    paddingLeft: 5,
  },
  hintText: {
    color: '#AAAAAA',
    fontSize: 12,
    marginLeft: 5,
  },
  requirementsContainer: {
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 8,
    padding: 12,
    marginBottom: 15,
  },
  requirementsHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  requirementsTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#FFFFFF',
  },
  validStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  invalidStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 78, 78, 0.1)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  validText: {
    color: '#2ebb77',
    fontSize: 12,
    marginLeft: 4,
    fontWeight: '500',
  },
  invalidText: {
    color: '#ff4e4e',
    fontSize: 12,
    marginLeft: 4,
    fontWeight: '500',
  },
  requirementsList: {
    marginTop: 5,
  },
  requirementItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  requirementText: {
    fontSize: 13,
    marginLeft: 8,
  },
  validRequirement: {
    color: '#2ebb77',
  },
  invalidRequirement: {
    color: '#AAAAAA',
  },
  passwordMatch: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 15,
    paddingLeft: 5,
  },
  matchSuccess: {
    color: '#2ebb77',
  },
  matchError: {
    color: '#ff4e4e',
  },
  matchText: {
    marginLeft: 8,
    fontSize: 13,
  },
  matchSuccessText: {
    color: '#2ebb77',
  },
  matchErrorText: {
    color: '#ff4e4e',
  },
  termsContainer: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: 20,
  },
  checkbox: {
    marginRight: 10,
    marginTop: -2,
  },
  termsTextContainer: {
    flex: 1,
  },
  termsText: {
    color: '#AAAAAA',
    fontSize: 14,
    lineHeight: 20,
  },
  termsLink: {
    color: '#6543CC',
    fontWeight: '500',
  },
  registerButton: {
    backgroundColor: '#6543CC',
    height: 50,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  disabledButton: {
    backgroundColor: '#4F4F4F',
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  dividerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 20,
  },
  divider: {
    flex: 1,
    height: 1,
    backgroundColor: '#333333',
  },
  dividerText: {
    color: '#AAAAAA',
    paddingHorizontal: 10,
    fontSize: 14,
  },
  socialButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 15,
  },
  socialButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#2A2A2A',
    height: 50,
    borderRadius: 8,
    gap: 10,
  },
  socialButtonText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  loginContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 20,
    marginBottom: 40,
  },
  loginText: {
    color: '#AAAAAA',
  },
  loginLink: {
    color: '#6543CC',
    fontWeight: 'bold',
  },
});

export default RegisterScreen;
</file>

<file path="src/screens/auth/ResetPasswordScreen.js">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  ScrollView,
  SafeAreaView
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { useNavigation, useRoute } from '@react-navigation/native';
import { verifyResetToken, resetPassword } from '../../api/passwordResetService';

const ResetPasswordScreen = () => {
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showNewPassword, setShowNewPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [showRequirements, setShowRequirements] = useState(false);
  const [tokenValid, setTokenValid] = useState(null);
  const [loading, setLoading] = useState(false);
  const [verifyLoading, setVerifyLoading] = useState(true);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState(false);
  const [passwordValidation, setPasswordValidation] = useState({
    hasMinimumLength: false,
    hasUpperCase: false,
    hasLowerCase: false,
    hasNumber: false,
    hasSpecialChar: false
  });
  
  const navigation = useNavigation();
  const route = useRoute();
  const token = route.params?.token;
  
  // Verify token on component mount
  useEffect(() => {
    const verifyToken = async () => {
      if (!token) {
        setTokenValid(false);
        setError('No reset token provided');
        setVerifyLoading(false);
        return;
      }
      
      setVerifyLoading(true);
      
      try {
        const response = await verifyResetToken(token);
        if (response && response.valid) {
          setTokenValid(true);
        } else {
          setTokenValid(false);
          setError(response?.error || 'Invalid or expired token');
        }
      } catch (err) {
        console.error('Error verifying token:', err);
        setTokenValid(false);
        setError('Failed to verify reset token. Please try again.');
      } finally {
        setVerifyLoading(false);
      }
    };
    
    verifyToken();
  }, [token]);
  
  // Update password validation whenever password changes
  useEffect(() => {
    setPasswordValidation({
      hasMinimumLength: newPassword.length >= 6,
      hasUpperCase: /[A-Z]/.test(newPassword),
      hasLowerCase: /[a-z]/.test(newPassword),
      hasNumber: /[0-9]/.test(newPassword),
      hasSpecialChar: /[!@#$%^&*()\-_=+[\]{}|;:'",<.>/?`~\\]/.test(newPassword)
    });
  }, [newPassword]);
  
  const passwordIsValid = () => {
    return Object.values(passwordValidation).every(val => val === true);
  };
  
  const handleSubmit = async () => {
    setError('');
    
    // Basic validation
    if (!newPassword || !confirmPassword) {
      setError('Both fields are required');
      return;
    }
    
    if (!passwordIsValid()) {
      setError('Password does not meet all requirements');
      setShowRequirements(true);
      return;
    }
    
    if (newPassword !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }
    
    setLoading(true);
    
    try {
      const response = await resetPassword(token, newPassword, confirmPassword);
      setSuccess(true);
      
      // Redirect to login page after showing success message
      setTimeout(() => {
        navigation.navigate('Login');
      }, 5000);
    } catch (err) {
      console.error("Password reset error:", err);
      setError(err.message || 'Failed to reset password. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Show loading state while verifying token
  if (verifyLoading) {
    return (
      <SafeAreaView style={styles.container}>
        <LinearGradient
          colors={['#121212', '#1a1a2e']}
          style={styles.gradientBackground}
        />
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#6543CC" />
          <Text style={styles.loadingText}>Verifying reset token...</Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView contentContainerStyle={styles.scrollContainer}>
          <LinearGradient
            colors={['#121212', '#1a1a2e']}
            style={styles.gradientBackground}
          />
          
          <TouchableOpacity 
            style={styles.backButton}
            onPress={() => navigation.navigate('Login')}
          >
            <Ionicons name="arrow-back" size={22} color="#AAAAAA" />
            <Text style={styles.backButtonText}>Back to Login</Text>
          </TouchableOpacity>
          
          <View style={styles.header}>
            <View style={styles.logoContainer}>
              <LinearGradient
                colors={['#6543CC', '#8A58FC']}
                style={styles.logoBackground}
              >
                <Ionicons name="key" size={30} color="#FFFFFF" />
              </LinearGradient>
            </View>
            <Text style={styles.headerTitle}>Reset Your Password</Text>
            <Text style={styles.subtitle}>
              Create a new, strong password for your account
            </Text>
          </View>
          
          {!tokenValid ? (
            <View style={styles.errorState}>
              <Ionicons name="close-circle" size={60} color="#ff4e4e" style={styles.errorIcon} />
              <Text style={styles.errorTitle}>Invalid or Expired Link</Text>
              <Text style={styles.errorMessage}>
                This password reset link is invalid or has expired. 
                Please request a new password reset link.
              </Text>
              <TouchableOpacity 
                style={styles.requestNewButton}
                onPress={() => navigation.navigate('ForgotPassword')}
              >
                <Text style={styles.requestNewText}>Request New Reset Link</Text>
              </TouchableOpacity>
            </View>
          ) : success ? (
            <View style={styles.successMessage}>
              <View style={styles.successIcon}>
                <Ionicons name="checkmark" size={40} color="#FFFFFF" />
              </View>
              <Text style={styles.successTitle}>Password Reset Successfully!</Text>
              <Text style={styles.successText}>
                Your password has been updated. You can now log in with your new password.
              </Text>
              <Text style={styles.redirectText}>
                Redirecting to login page in a few seconds...
              </Text>
            </View>
          ) : (
            <>
              {error && (
                <View style={styles.errorContainer}>
                  <Ionicons name="alert-circle" size={20} color="#FF4C8B" />
                  <Text style={styles.errorText}>{error}</Text>
                </View>
              )}
              
              <View style={styles.form}>
                <View style={styles.inputContainer}>
                  <Ionicons name="lock-closed-outline" size={20} color="#AAAAAA" style={styles.inputIcon} />
                  <TextInput
                    style={styles.input}
                    placeholder="Enter your new password"
                    placeholderTextColor="#AAAAAA"
                    value={newPassword}
                    onChangeText={setNewPassword}
                    secureTextEntry={!showNewPassword}
                    autoCapitalize="none"
                    returnKeyType="next"
                    editable={!loading}
                    onFocus={() => setShowRequirements(true)}
                  />
                  <TouchableOpacity 
                    style={styles.passwordToggle}
                    onPress={() => setShowNewPassword(!showNewPassword)}
                  >
                    <Ionicons 
                      name={showNewPassword ? "eye-off-outline" : "eye-outline"} 
                      size={20} 
                      color="#AAAAAA" 
                    />
                  </TouchableOpacity>
                </View>
                
                {showRequirements && (
                  <View style={styles.requirementsContainer}>
                    <View style={styles.requirementsHeader}>
                      <Text style={styles.requirementsTitle}>Password Requirements:</Text>
                      {passwordIsValid() ? (
                        <View style={styles.validStatus}>
                          <Ionicons name="checkmark" size={14} color="#2ebb77" />
                          <Text style={styles.validText}>Valid</Text>
                        </View>
                      ) : (
                        <View style={styles.invalidStatus}>
                          <Ionicons name="close" size={14} color="#ff4e4e" />
                          <Text style={styles.invalidText}>Invalid</Text>
                        </View>
                      )}
                    </View>
                    
                    <View style={styles.requirementsList}>
                      <View style={styles.requirementItem}>
                        <Ionicons 
                          name={passwordValidation.hasMinimumLength ? "checkmark-circle" : "close-circle"} 
                          size={16} 
                          color={passwordValidation.hasMinimumLength ? "#2ebb77" : "#ff4e4e"} 
                        />
                        <Text style={[
                          styles.requirementText,
                          passwordValidation.hasMinimumLength ? styles.validRequirement : styles.invalidRequirement
                        ]}>
                          At least 6 characters long
                        </Text>
                      </View>
                      
                      <View style={styles.requirementItem}>
                        <Ionicons 
                          name={passwordValidation.hasUpperCase ? "checkmark-circle" : "close-circle"} 
                          size={16} 
                          color={passwordValidation.hasUpperCase ? "#2ebb77" : "#ff4e4e"} 
                        />
                        <Text style={[
                          styles.requirementText,
                          passwordValidation.hasUpperCase ? styles.validRequirement : styles.invalidRequirement
                        ]}>
                          At least one uppercase letter
                        </Text>
                      </View>
                      
                      <View style={styles.requirementItem}>
                        <Ionicons 
                          name={passwordValidation.hasLowerCase ? "checkmark-circle" : "close-circle"} 
                          size={16} 
                          color={passwordValidation.hasLowerCase ? "#2ebb77" : "#ff4e4e"} 
                        />
                        <Text style={[
                          styles.requirementText,
                          passwordValidation.hasLowerCase ? styles.validRequirement : styles.invalidRequirement
                        ]}>
                          At least one lowercase letter
                        </Text>
                      </View>
                      
                      <View style={styles.requirementItem}>
                        <Ionicons 
                          name={passwordValidation.hasNumber ? "checkmark-circle" : "close-circle"} 
                          size={16} 
                          color={passwordValidation.hasNumber ? "#2ebb77" : "#ff4e4e"} 
                        />
                        <Text style={[
                          styles.requirementText,
                          passwordValidation.hasNumber ? styles.validRequirement : styles.invalidRequirement
                        ]}>
                          At least one number
                        </Text>
                      </View>
                      
                      <View style={styles.requirementItem}>
                        <Ionicons 
                          name={passwordValidation.hasSpecialChar ? "checkmark-circle" : "close-circle"} 
                          size={16} 
                          color={passwordValidation.hasSpecialChar ? "#2ebb77" : "#ff4e4e"} 
                        />
                        <Text style={[
                          styles.requirementText,
                          passwordValidation.hasSpecialChar ? styles.validRequirement : styles.invalidRequirement
                        ]}>
                          At least one special character
                        </Text>
                      </View>
                    </View>
                  </View>
                )}
                
                <View style={styles.inputContainer}>
                  <Ionicons name="lock-closed-outline" size={20} color="#AAAAAA" style={styles.inputIcon} />
                  <TextInput
                    style={styles.input}
                    placeholder="Confirm your new password"
                    placeholderTextColor="#AAAAAA"
                    value={confirmPassword}
                    onChangeText={setConfirmPassword}
                    secureTextEntry={!showConfirmPassword}
                    autoCapitalize="none"
                    returnKeyType="done"
                    editable={!loading}
                  />
                  <TouchableOpacity 
                    style={styles.passwordToggle}
                    onPress={() => setShowConfirmPassword(!showConfirmPassword)}
                  >
                    <Ionicons 
                      name={showConfirmPassword ? "eye-off-outline" : "eye-outline"} 
                      size={20} 
                      color="#AAAAAA" 
                    />
                  </TouchableOpacity>
                </View>
                
                {newPassword && confirmPassword && (
                  <View style={[
                    styles.passwordMatch,
                    newPassword === confirmPassword ? styles.matchSuccess : styles.matchError
                  ]}>
                    <Ionicons 
                      name={newPassword === confirmPassword ? "checkmark-circle" : "close-circle"} 
                      size={16} 
                      color={newPassword === confirmPassword ? "#2ebb77" : "#ff4e4e"} 
                    />
                    <Text style={[
                      styles.matchText,
                      newPassword === confirmPassword ? styles.matchSuccessText : styles.matchErrorText
                    ]}>
                      {newPassword === confirmPassword ? "Passwords match" : "Passwords don't match"}
                    </Text>
                  </View>
                )}
                
                <TouchableOpacity 
                  style={[styles.resetButton, loading && styles.disabledButton]}
                  onPress={handleSubmit}
                  disabled={loading}
                >
                  {loading ? (
                    <View style={styles.buttonContent}>
                      <ActivityIndicator color="#FFFFFF" />
                      <Text style={styles.buttonText}>Resetting Password...</Text>
                    </View>
                  ) : (
                    <View style={styles.buttonContent}>
                      <Text style={styles.buttonText}>Reset Password</Text>
                      <Ionicons name="chevron-forward" size={18} color="#FFFFFF" />
                    </View>
                  )}
                </TouchableOpacity>
              </View>
            </>
          )}
          
          <View style={styles.linksContainer}>
            <Text style={styles.linkText}>Remember your password?</Text>
            <TouchableOpacity onPress={() => navigation.navigate('Login')}>
              <Text style={styles.linkButton}>Sign In</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  keyboardView: {
    flex: 1,
  },
  scrollContainer: {
    flexGrow: 1,
    padding: 20,
  },
  gradientBackground: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    color: '#AAAAAA',
    marginTop: 20,
    fontSize: 16,
  },
  backButton: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 20,
  },
  backButtonText: {
    color: '#AAAAAA',
    marginLeft: 8,
    fontSize: 16,
  },
  header: {
    alignItems: 'center',
    marginBottom: 30,
  },
  logoContainer: {
    marginBottom: 20,
  },
  logoBackground: {
    width: 70,
    height: 70,
    borderRadius: 35,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#6543CC',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.5,
    shadowRadius: 15,
    elevation: 10,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#AAAAAA',
    textAlign: 'center',
    maxWidth: '80%',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 76, 139, 0.1)',
    padding: 10,
    borderRadius: 8,
    marginBottom: 20,
  },
  errorText: {
    color: '#FF4C8B',
    marginLeft: 10,
    flex: 1,
  },
  form: {
    width: '100%',
    marginBottom: 20,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#2A2A2A',
    borderRadius: 8,
    marginBottom: 15,
    height: 50,
  },
  inputIcon: {
    marginHorizontal: 15,
  },
  input: {
    flex: 1,
    height: 50,
    color: '#FFFFFF',
    paddingRight: 15,
  },
  passwordToggle: {
    padding: 15,
  },
  requirementsContainer: {
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 8,
    padding: 12,
    marginBottom: 15,
  },
  requirementsHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  requirementsTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#FFFFFF',
  },
  validStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  invalidStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 78, 78, 0.1)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  validText: {
    color: '#2ebb77',
    fontSize: 12,
    marginLeft: 4,
    fontWeight: '500',
  },
  invalidText: {
    color: '#ff4e4e',
    fontSize: 12,
    marginLeft: 4,
    fontWeight: '500',
  },
  requirementsList: {
    marginTop: 5,
  },
  requirementItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  requirementText: {
    fontSize: 13,
    marginLeft: 8,
  },
  validRequirement: {
    color: '#2ebb77',
  },
  invalidRequirement: {
    color: '#AAAAAA',
  },
  passwordMatch: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 15,
    paddingLeft: 5,
  },
  matchText: {
    marginLeft: 8,
    fontSize: 13,
  },
  matchSuccess: {
    color: '#2ebb77',
  },
  matchError: {
    color: '#ff4e4e',
  },
  matchSuccessText: {
    color: '#2ebb77',
  },
  matchErrorText: {
    color: '#ff4e4e',
  },
  resetButton: {
    backgroundColor: '#6543CC',
    height: 50,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  disabledButton: {
    backgroundColor: '#4F4F4F',
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  linksContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 20,
  },
  linkText: {
    color: '#AAAAAA',
  },
  linkButton: {
    color: '#6543CC',
    fontWeight: 'bold',
    marginLeft: 6,
  },
  errorState: {
    backgroundColor: 'rgba(255, 78, 78, 0.05)',
    borderRadius: 12,
    padding: 20,
    alignItems: 'center',
    marginBottom: 20,
  },
  errorIcon: {
    marginBottom: 15,
  },
  errorTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 10,
  },
  errorMessage: {
    fontSize: 15,
    color: '#AAAAAA',
    textAlign: 'center',
    marginBottom: 20,
    lineHeight: 22,
  },
  requestNewButton: {
    backgroundColor: '#6543CC',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  requestNewText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
    fontSize: 16,
  },
  successMessage: {
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
    borderRadius: 12,
    padding: 20,
    alignItems: 'center',
    marginBottom: 20,
    borderLeftWidth: 3,
    borderLeftColor: '#2ebb77',
  },
  successIcon: {
    width: 64,
    height: 64,
    borderRadius: 32,
    backgroundColor: '#2ebb77',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
  },
  successTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 15,
  },
  successText: {
    fontSize: 15,
    color: '#AAAAAA',
    textAlign: 'center',
    marginBottom: 10,
    lineHeight: 22,
  },
  redirectText: {
    fontSize: 14,
    color: '#AAAAAA',
    fontStyle: 'italic',
  },
});

export default ResetPasswordScreen;
</file>

<file path="src/screens/profile/AchievementsScreen.js">
// src/screens/profile/AchievementsScreen.js
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
  RefreshControl,
  SafeAreaView,
  Platform,
  Modal
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import useAchievements from '../../hooks/useAchievements';
import AchievementItem from '../../components/AchievementItem';

const AchievementsScreen = () => {
  const {
    allAchievements,
    filteredAchievements,
    loading,
    refreshing,
    activeCategory,
    error,
    categories,
    handleCategoryChange,
    handleRefresh,
    isAchievementUnlocked,
    getAchievementStats
  } = useAchievements();
  
  const [selectedAchievement, setSelectedAchievement] = useState(null);
  const [modalVisible, setModalVisible] = useState(false);
  
  const { total, unlocked, completionPercentage } = getAchievementStats();
  
  // Handle achievement item press
  const handleAchievementPress = (achievement) => {
    setSelectedAchievement(achievement);
    setModalVisible(true);
  };
  
  // Render category tabs
  const renderCategoryTabs = () => {
    return (
      <ScrollableTabs
        tabs={Object.entries(categories).map(([id, label]) => ({ id, label }))}
        activeTab={activeCategory}
        onTabChange={handleCategoryChange}
      />
    );
  };
  
  // Render empty state
  const renderEmpty = () => {
    if (loading) return null;
    
    return (
      <View style={styles.emptyContainer}>
        <Ionicons name="trophy-outline" size={60} color="#AAAAAA" />
        <Text style={styles.emptyText}>
          {error || 'No achievements found in this category'}
        </Text>
        
        {error && (
          <TouchableOpacity style={styles.retryButton} onPress={handleRefresh}>
            <Text style={styles.retryText}>Retry</Text>
          </TouchableOpacity>
        )}
      </View>
    );
  };
  
  // Render achievement details modal
  const renderModal = () => {
    if (!selectedAchievement) return null;
    
    const isUnlocked = isAchievementUnlocked(selectedAchievement.achievementId);
    
    return (
      <Modal
        visible={modalVisible}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setModalVisible(false)}
            >
              <Ionicons name="close" size={24} color="#FFFFFF" />
            </TouchableOpacity>
            
            <Text style={styles.modalTitle}>{selectedAchievement.title}</Text>
            
            <View style={styles.modalContent}>
              <View style={styles.modalIconContainer}>
                <Ionicons 
                  name={isUnlocked ? "trophy" : "lock-closed"} 
                  size={40} 
                  color={isUnlocked ? "#FFD700" : "#AAAAAA"} 
                />
              </View>
              
              <Text style={styles.modalDescription}>
                {selectedAchievement.description}
              </Text>
              
              <View style={styles.modalStatus}>
                <Text style={[
                  styles.modalStatusText,
                  isUnlocked ? styles.unlockedText : styles.lockedText
                ]}>
                  {isUnlocked ? "Achievement Unlocked" : "Achievement Locked"}
                </Text>
              </View>
            </View>
          </View>
        </View>
      </Modal>
    );
  };
  
  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Achievements</Text>
        <Text style={styles.subtitle}>
          Track your progress and unlock achievements
        </Text>
      </View>
      
      <View style={styles.statsContainer}>
        <View style={styles.statCard}>
          <Ionicons name="trophy" size={28} color="#6543CC" />
          <Text style={styles.statValue}>{unlocked} / {total}</Text>
          <Text style={styles.statLabel}>Achievements</Text>
        </View>
        
        <View style={styles.statCard}>
          <Ionicons name="ribbon" size={28} color="#FF4C8B" />
          <Text style={styles.statValue}>{completionPercentage}%</Text>
          <Text style={styles.statLabel}>Completed</Text>
        </View>
      </View>
      
      <View style={styles.tabsContainer}>
        {renderCategoryTabs()}
      </View>
      
      <FlatList
        data={filteredAchievements}
        renderItem={({ item }) => (
          <AchievementItem
            achievement={item}
            isUnlocked={isAchievementUnlocked(item.achievementId)}
            onPress={handleAchievementPress}
          />
        )}
        keyExtractor={(item) => item.achievementId}
        contentContainerStyle={styles.listContent}
        showsVerticalScrollIndicator={false}
        ListEmptyComponent={renderEmpty}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={['#6543CC']}
            tintColor="#6543CC"
          />
        }
      />
      
      {loading && !refreshing && (
        <View style={styles.loadingOverlay}>
          <ActivityIndicator size="large" color="#6543CC" />
        </View>
      )}
      
      {renderModal()}
    </SafeAreaView>
  );
};

// ScrollableTabs component
const ScrollableTabs = ({ tabs, activeTab, onTabChange }) => {
  return (
    <FlatList
      data={tabs}
      horizontal
      showsHorizontalScrollIndicator={false}
      keyExtractor={(item) => item.id}
      contentContainerStyle={styles.tabsScrollContainer}
      renderItem={({ item }) => (
        <TouchableOpacity
          style={[
            styles.tabButton,
            activeTab === item.id && styles.activeTabButton
          ]}
          onPress={() => onTabChange(item.id)}
        >
          <Text style={[
            styles.tabButtonText,
            activeTab === item.id && styles.activeTabButtonText
          ]}>
            {item.label}
          </Text>
        </TouchableOpacity>
      )}
    />
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  header: {
    padding: 20,
    backgroundColor: '#1E1E1E',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 6,
  },
  subtitle: {
    fontSize: 16,
    color: '#AAAAAA',
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    padding: 16,
  },
  statCard: {
    backgroundColor: '#1E1E1E',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
    minWidth: '45%',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  statValue: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginTop: 8,
  },
  statLabel: {
    fontSize: 14,
    color: '#AAAAAA',
    marginTop: 4,
  },
  tabsContainer: {
    backgroundColor: '#1A1A1A',
    paddingVertical: 10,
  },
  tabsScrollContainer: {
    paddingHorizontal: 16,
  },
  tabButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    marginRight: 8,
    backgroundColor: '#2A2A2A',
  },
  activeTabButton: {
    backgroundColor: '#6543CC',
  },
  tabButtonText: {
    color: '#AAAAAA',
    fontWeight: '500',
  },
  activeTabButtonText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  listContent: {
    padding: 16,
    paddingBottom: 30,
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyText: {
    fontSize: 16,
    color: '#AAAAAA',
    textAlign: 'center',
    marginTop: 10,
    marginBottom: 20,
  },
  retryButton: {
    backgroundColor: '#6543CC',
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  retryText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  loadingOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.4)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '80%',
    backgroundColor: '#1E1E1E',
    borderRadius: 16,
    padding: 20,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.3,
        shadowRadius: 8,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  closeButton: {
    position: 'absolute',
    top: 12,
    right: 12,
    zIndex: 1,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 16,
    textAlign: 'center',
  },
  modalContent: {
    alignItems: 'center',
  },
  modalIconContainer: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
  },
  modalDescription: {
    fontSize: 14,
    color: '#FFFFFF',
    textAlign: 'center',
    marginBottom: 20,
  },
  modalStatus: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
  },
  modalStatusText: {
    fontWeight: 'bold',
  },
  unlockedText: {
    color: '#2ebb77',
  },
  lockedText: {
    color: '#AAAAAA',
  },
});

export default AchievementsScreen;
</file>

<file path="src/screens/profile/ProfileScreen.js">
// src/screens/profile/ProfileScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Image,
  TextInput,
  ActivityIndicator,
  Alert,
  Modal,
  SafeAreaView,
  Platform
} from 'react-native';
import { useDispatch, useSelector } from 'react-redux';
import { fetchUserData, logout } from '../../store/slices/userSlice';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import * as SecureStore from 'expo-secure-store';

// Import profile service to handle API calls
import { changeUsername, changeEmail, changePassword } from '../../api/profileService';

const ProfileScreen = ({ navigation }) => {
  const dispatch = useDispatch();
  
  // Get user data from Redux store
  const {
    userId,
    username,
    email,
    xp,
    level,
    coins,
    achievements = [],
    currentAvatar,
    nameColor,
    purchasedItems,
    subscriptionActive,
    status
  } = useSelector((state) => state.user);
  
  // Local state
  const [activeTab, setActiveTab] = useState('overview');
  const [refreshing, setRefreshing] = useState(false);
  
  // Form state
  const [showChangeUsername, setShowChangeUsername] = useState(false);
  const [newUsername, setNewUsername] = useState('');
  const [usernameLoading, setUsernameLoading] = useState(false);
  
  const [showChangeEmail, setShowChangeEmail] = useState(false);
  const [newEmail, setNewEmail] = useState('');
  const [emailLoading, setEmailLoading] = useState(false);
  
  const [showChangePassword, setShowChangePassword] = useState(false);
  const [oldPassword, setOldPassword] = useState('');
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showOldPassword, setShowOldPassword] = useState(false);
  const [showNewPassword, setShowNewPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [passwordLoading, setPasswordLoading] = useState(false);
  
  // Status message
  const [statusMessage, setStatusMessage] = useState('');
  const [statusType, setStatusType] = useState(''); // 'success', 'error'
  const [showStatusModal, setShowStatusModal] = useState(false);
  
  // Calculate XP to next level
  const calculateXpPercentage = () => {
    return calculateXpToNextLevel();
  };
  
  // Calculate XP required for a given level
  const xpRequiredForLevel = (level) => {
    if (level < 1) return 0;
    if (level === 1) return 0;
    
    if (level <= 30) {
      return 500 * (level - 1);
    } else if (level <= 60) {
      const base = 500 * 29; // XP for levels up to 30
      return base + 750 * (level - 30);
    } else if (level <= 100) {
      const base = 500 * 29 + 750 * 30; // XP for levels up to 60
      return base + 1000 * (level - 60);
    } else {
      const base = 500 * 29 + 750 * 30 + 1000 * 40; // XP for levels up to 100
      return base + 1500 * (level - 100);
    }
  };
  
  // Calculate percentage to next level
  const calculateXpToNextLevel = () => {
    // Get XP required for current level and next level
    const currentLevelXp = xpRequiredForLevel(level);
    const nextLevelXp = xpRequiredForLevel(level + 1);
    
    // Calculate how much XP we've earned in the current level
    const xpInCurrentLevel = xp - currentLevelXp;
    
    // Calculate how much XP is needed to reach the next level
    const xpRequiredForNextLevel = nextLevelXp - currentLevelXp;
    
    // Calculate percentage (capped at 100%)
    return Math.min(100, (xpInCurrentLevel / xpRequiredForNextLevel) * 100);
  };
  
  const xpPercentage = calculateXpPercentage();

  // Get user avatar from purchased items
  const profilePicUrl = currentAvatar 
    ? `/avatars/${currentAvatar}.png` 
    : require('../../../assets/default-avatar.png');
  
  // Fetch user data
  useEffect(() => {
    if (userId) {
      dispatch(fetchUserData(userId));
    }
  }, [dispatch, userId]);
  
  // Handle refresh
  const handleRefresh = () => {
    setRefreshing(true);
    dispatch(fetchUserData(userId)).then(() => {
      setRefreshing(false);
    });
  };
  
  // Handle logout
  const handleLogout = async () => {
    Alert.alert(
      'Confirm Logout',
      'Are you sure you want to logout?',
      [
        {
          text: 'Cancel',
          style: 'cancel'
        },
        {
          text: 'Logout',
          onPress: async () => {
            await SecureStore.deleteItemAsync('userId');
            dispatch(logout());
            navigation.navigate('Login');
          },
          style: 'destructive'
        }
      ]
    );
  };
  
  // Show status message
  const showStatusMessage = (message, type = 'success') => {
    setStatusMessage(message);
    setStatusType(type);
    setShowStatusModal(true);
    
    // Hide after 3 seconds
    setTimeout(() => {
      setShowStatusModal(false);
      setStatusMessage('');
      setStatusType('');
    }, 3000);
  };
  
  // Handle username change
  const handleChangeUsername = async () => {
    if (!newUsername) {
      showStatusMessage('Please enter a new username', 'error');
      return;
    }
    
    // Basic validation
    if (newUsername.length < 3 || newUsername.length > 30) {
      showStatusMessage('Username must be between 3 and 30 characters', 'error');
      return;
    }
    
    // More comprehensive validation can be added here
    
    setUsernameLoading(true);
    
    try {
      await changeUsername(userId, newUsername);
      
      showStatusMessage('Username updated successfully!');
      setShowChangeUsername(false);
      setNewUsername('');
      
      // Refresh user data
      dispatch(fetchUserData(userId));
    } catch (error) {
      console.error('Error changing username:', error);
      showStatusMessage(error.message || 'Failed to update username. Please try again.', 'error');
    } finally {
      setUsernameLoading(false);
    }
  };
  
  // Handle email change
  const handleChangeEmail = async () => {
    if (!newEmail) {
      showStatusMessage('Please enter a new email', 'error');
      return;
    }
    
    // Basic validation
    if (!/\S+@\S+\.\S+/.test(newEmail)) {
      showStatusMessage('Please enter a valid email address', 'error');
      return;
    }
    
    setEmailLoading(true);
    
    try {
      await changeEmail(userId, newEmail);
      
      showStatusMessage('Email updated successfully!');
      setShowChangeEmail(false);
      setNewEmail('');
      
      // Refresh user data
      dispatch(fetchUserData(userId));
    } catch (error) {
      console.error('Error changing email:', error);
      showStatusMessage(error.message || 'Failed to update email. Please try again.', 'error');
    } finally {
      setEmailLoading(false);
    }
  };
  
  // Handle password change
  const handleChangePassword = async () => {
    if (!oldPassword || !newPassword || !confirmPassword) {
      showStatusMessage('All password fields are required', 'error');
      return;
    }
    
    if (newPassword !== confirmPassword) {
      showStatusMessage('New passwords do not match', 'error');
      return;
    }
    
    // Password strength validation
    if (newPassword.length < 6) {
      showStatusMessage('Password must be at least 6 characters long', 'error');
      return;
    }
    
    // Check for uppercase, lowercase, number and special character
    const hasUpperCase = /[A-Z]/.test(newPassword);
    const hasLowerCase = /[a-z]/.test(newPassword);
    const hasNumber = /\d/.test(newPassword);
    const hasSpecialChar = /[!@#$%^&*()\-_=+\[\]{}|;:'",<.>/?`~\\]/.test(newPassword);
    
    if (!hasUpperCase || !hasLowerCase || !hasNumber || !hasSpecialChar) {
      showStatusMessage('Password must include uppercase, lowercase, number and special character', 'error');
      return;
    }
    
    setPasswordLoading(true);
    
    try {
      await changePassword(userId, oldPassword, newPassword, confirmPassword);
      
      showStatusMessage('Password updated successfully!');
      setShowChangePassword(false);
      setOldPassword('');
      setNewPassword('');
      setConfirmPassword('');
      
    } catch (error) {
      console.error('Error changing password:', error);
      showStatusMessage(error.message || 'Failed to update password. Please try again.', 'error');
    } finally {
      setPasswordLoading(false);
    }
  };
  
  // Navigate to Achievements screen
  const goToAchievements = () => {
    navigation.navigate('Achievements');
  };
  
  // Navigate to Shop
  const goToShop = () => {
    navigation.navigate('Shop');
  };
  
  // Navigate to Support
  const goToSupport = () => {
    navigation.navigate('Support');
  };
  
  return (
    <SafeAreaView style={styles.container}>
      <StatusModal 
        visible={showStatusModal}
        message={statusMessage}
        type={statusType}
        onClose={() => setShowStatusModal(false)}
      />
      
      <ScrollView 
        style={styles.scrollView}
        contentContainerStyle={styles.scrollViewContent}
        refreshing={refreshing}
        onRefresh={handleRefresh}
      >
        {/* Profile Header */}
        <View style={styles.header}>
          <View style={styles.avatarContainer}>
            <Image 
              source={typeof profilePicUrl === 'string' ? { uri: profilePicUrl } : profilePicUrl} 
              style={styles.avatar}
            />
          </View>
          
          <View style={styles.userInfo}>
            <Text style={styles.username}>{username}</Text>
            
            <View style={styles.levelContainer}>
              <View style={styles.levelBadge}>
                <Text style={styles.levelText}>{level}</Text>
              </View>
              
              <View style={styles.xpContainer}>
                <View style={styles.xpBar}>
                  <View style={[styles.xpProgress, { width: `${xpPercentage}%` }]} />
                </View>
                <Text style={styles.xpText}>{xp} XP</Text>
              </View>
            </View>
            
            <View style={styles.statsRow}>
              <View style={styles.statItem}>
                <Ionicons name="wallet-outline" size={18} color="#FFD700" />
                <Text style={styles.statText}>{coins}</Text>
              </View>
              
              <View style={styles.statItem}>
                <Ionicons name="trophy-outline" size={18} color="#FFD700" />
                <Text style={styles.statText}>{achievements.length}</Text>
              </View>
              
              <View style={styles.statItem}>
                <Ionicons name="star-outline" size={18} color="#FFD700" />
                <Text style={styles.statText}>{purchasedItems.length}</Text>
              </View>
            </View>
          </View>
        </View>
        
        {/* Tabs Navigation */}
        <View style={styles.tabsContainer}>
          <TouchableOpacity 
            style={[styles.tab, activeTab === 'overview' && styles.activeTab]}
            onPress={() => setActiveTab('overview')}
          >
            <Text style={[styles.tabText, activeTab === 'overview' && styles.activeTabText]}>Overview</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={[styles.tab, activeTab === 'account' && styles.activeTab]}
            onPress={() => setActiveTab('account')}
          >
            <Text style={[styles.tabText, activeTab === 'account' && styles.activeTabText]}>Account</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={[styles.tab, activeTab === 'achievements' && styles.activeTab]}
            onPress={() => setActiveTab('achievements')}
          >
            <Text style={[styles.tabText, activeTab === 'achievements' && styles.activeTabText]}>Achievements</Text>
          </TouchableOpacity>
        </View>
        
        {/* Tab Content */}
        {activeTab === 'overview' && (
          <View style={styles.tabContent}>
            <View style={styles.card}>
              <View style={styles.cardHeader}>
                <Ionicons name="person-outline" size={20} color="#6543CC" />
                <Text style={styles.cardTitle}>User Profile</Text>
              </View>
              
              <View style={styles.cardBody}>
                <View style={styles.profileDetail}>
                  <Text style={styles.detailLabel}>Username:</Text>
                  <Text style={styles.detailValue}>{username}</Text>
                </View>
                
                <View style={styles.profileDetail}>
                  <Text style={styles.detailLabel}>Email:</Text>
                  <Text style={styles.detailValue}>{email}</Text>
                </View>
                
                <View style={styles.profileDetail}>
                  <Text style={styles.detailLabel}>Level:</Text>
                  <Text style={styles.detailValue}>{level}</Text>
                </View>
                
                <View style={styles.profileDetail}>
                  <Text style={styles.detailLabel}>XP:</Text>
                  <Text style={styles.detailValue}>{xp}</Text>
                </View>
                
                <View style={styles.profileDetail}>
                  <Text style={styles.detailLabel}>Coins:</Text>
                  <Text style={styles.detailValue}>{coins}</Text>
                </View>
                
                <View style={styles.profileDetail}>
                  <Text style={styles.detailLabel}>Subscription:</Text>
                  <Text style={[
                    styles.detailValue, 
                    subscriptionActive ? styles.activeSubscription : styles.inactiveSubscription
                  ]}>
                    {subscriptionActive ? 'Active' : 'Inactive'}
                  </Text>
                </View>
              </View>
            </View>
            
            <View style={styles.card}>
              <View style={styles.cardHeader}>
                <Ionicons name="trophy-outline" size={20} color="#6543CC" />
                <Text style={styles.cardTitle}>Achievements</Text>
              </View>
              
              <View style={styles.cardBody}>
                {achievements.length > 0 ? (
                  <>
                    <Text style={styles.achievementsText}>
                      You have unlocked {achievements.length} achievements!
                    </Text>
                    <TouchableOpacity style={styles.viewMoreButton} onPress={goToAchievements}>
                      <Text style={styles.viewMoreText}>View All Achievements</Text>
                      <Ionicons name="chevron-forward" size={16} color="#6543CC" />
                    </TouchableOpacity>
                  </>
                ) : (
                  <Text style={styles.emptyStateText}>
                    Complete quizzes and challenges to earn achievements!
                  </Text>
                )}
              </View>
            </View>
            
            <View style={styles.card}>
              <View style={styles.cardHeader}>
                <Ionicons name="cart-outline" size={20} color="#6543CC" />
                <Text style={styles.cardTitle}>Shop Items</Text>
              </View>
              
              <View style={styles.cardBody}>
                {purchasedItems.length > 0 ? (
                  <>
                    <Text style={styles.itemsText}>
                      You have purchased {purchasedItems.length} items from the shop!
                    </Text>
                    <TouchableOpacity style={styles.viewMoreButton} onPress={goToShop}>
                      <Text style={styles.viewMoreText}>Visit Shop</Text>
                      <Ionicons name="chevron-forward" size={16} color="#6543CC" />
                    </TouchableOpacity>
                  </>
                ) : (
                  <Text style={styles.emptyStateText}>
                    Visit the shop to purchase avatars and other items!
                  </Text>
                )}
              </View>
            </View>
            
            <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
              <Ionicons name="log-out-outline" size={20} color="#FFFFFF" />
              <Text style={styles.logoutText}>Logout</Text>
            </TouchableOpacity>
          </View>
        )}
        
        {activeTab === 'account' && (
          <View style={styles.tabContent}>
            <View style={styles.card}>
              <View style={styles.cardHeader}>
                <Ionicons name="person-outline" size={20} color="#6543CC" />
                <Text style={styles.cardTitle}>Account Settings</Text>
              </View>
              
              <View style={styles.cardBody}>
                {/* Change Username */}
                <View style={styles.settingSection}>
                  <View style={styles.settingHeader}>
                    <Text style={styles.settingTitle}>Username</Text>
                    <Text style={styles.settingValue}>{username}</Text>
                  </View>
                  
                  {showChangeUsername ? (
                    <View style={styles.changeForm}>
                      <TextInput
                        style={styles.input}
                        placeholder="New username"
                        placeholderTextColor="#AAAAAA"
                        value={newUsername}
                        onChangeText={setNewUsername}
                        autoCapitalize="none"
                        editable={!usernameLoading}
                      />
                      
                      <View style={styles.formButtons}>
                        <TouchableOpacity 
                          style={styles.saveButton}
                          onPress={handleChangeUsername}
                          disabled={usernameLoading}
                        >
                          {usernameLoading ? (
                            <ActivityIndicator color="#FFFFFF" size="small" />
                          ) : (
                            <Text style={styles.buttonText}>Save</Text>
                          )}
                        </TouchableOpacity>
                        
                        <TouchableOpacity 
                          style={styles.cancelButton}
                          onPress={() => {
                            setShowChangeUsername(false);
                            setNewUsername('');
                          }}
                          disabled={usernameLoading}
                        >
                          <Text style={styles.cancelText}>Cancel</Text>
                        </TouchableOpacity>
                      </View>
                    </View>
                  ) : (
                    <TouchableOpacity 
                      style={styles.changeButton}
                      onPress={() => setShowChangeUsername(true)}
                    >
                      <Ionicons name="create-outline" size={16} color="#FFFFFF" />
                      <Text style={styles.changeButtonText}>Change Username</Text>
                    </TouchableOpacity>
                  )}
                </View>
                
                {/* Change Email */}
                <View style={styles.settingSection}>
                  <View style={styles.settingHeader}>
                    <Text style={styles.settingTitle}>Email</Text>
                    <Text style={styles.settingValue}>{email}</Text>
                  </View>
                  
                  {showChangeEmail ? (
                    <View style={styles.changeForm}>
                      <TextInput
                        style={styles.input}
                        placeholder="New email address"
                        placeholderTextColor="#AAAAAA"
                        value={newEmail}
                        onChangeText={setNewEmail}
                        autoCapitalize="none"
                        keyboardType="email-address"
                        editable={!emailLoading}
                      />
                      
                      <View style={styles.formButtons}>
                        <TouchableOpacity 
                          style={styles.saveButton}
                          onPress={handleChangeEmail}
                          disabled={emailLoading}
                        >
                          {emailLoading ? (
                            <ActivityIndicator color="#FFFFFF" size="small" />
                          ) : (
                            <Text style={styles.buttonText}>Save</Text>
                          )}
                        </TouchableOpacity>
                        
                        <TouchableOpacity 
                          style={styles.cancelButton}
                          onPress={() => {
                            setShowChangeEmail(false);
                            setNewEmail('');
                          }}
                          disabled={emailLoading}
                        >
                          <Text style={styles.cancelText}>Cancel</Text>
                        </TouchableOpacity>
                      </View>
                    </View>
                  ) : (
                    <TouchableOpacity 
                      style={styles.changeButton}
                      onPress={() => setShowChangeEmail(true)}
                    >
                      <Ionicons name="create-outline" size={16} color="#FFFFFF" />
                      <Text style={styles.changeButtonText}>Change Email</Text>
                    </TouchableOpacity>
                  )}
                </View>
                
                {/* Change Password */}
                <View style={styles.settingSection}>
                  <View style={styles.settingHeader}>
                    <Text style={styles.settingTitle}>Password</Text>
                    <Text style={styles.settingValue}>••••••••</Text>
                  </View>
                  
                  {showChangePassword ? (
                    <View style={styles.changeForm}>
                      <View style={styles.passwordInputContainer}>
                        <TextInput
                          style={styles.input}
                          placeholder="Current password"
                          placeholderTextColor="#AAAAAA"
                          value={oldPassword}
                          onChangeText={setOldPassword}
                          secureTextEntry={!showOldPassword}
                          autoCapitalize="none"
                          editable={!passwordLoading}
                        />
                        <TouchableOpacity
                          style={styles.eyeIcon}
                          onPress={() => setShowOldPassword(!showOldPassword)}
                        >
                          <Ionicons
                            name={showOldPassword ? "eye-off-outline" : "eye-outline"}
                            size={20}
                            color="#AAAAAA"
                          />
                        </TouchableOpacity>
                      </View>
                      
                      <View style={styles.passwordInputContainer}>
                        <TextInput
                          style={styles.input}
                          placeholder="New password"
                          placeholderTextColor="#AAAAAA"
                          value={newPassword}
                          onChangeText={setNewPassword}
                          secureTextEntry={!showNewPassword}
                          autoCapitalize="none"
                          editable={!passwordLoading}
                        />
                        <TouchableOpacity
                          style={styles.eyeIcon}
                          onPress={() => setShowNewPassword(!showNewPassword)}
                        >
                          <Ionicons
                            name={showNewPassword ? "eye-off-outline" : "eye-outline"}
                            size={20}
                            color="#AAAAAA"
                          />
                        </TouchableOpacity>
                      </View>
                      
                      <View style={styles.passwordInputContainer}>
                        <TextInput
                          style={styles.input}
                          placeholder="Confirm new password"
                          placeholderTextColor="#AAAAAA"
                          value={confirmPassword}
                          onChangeText={setConfirmPassword}
                          secureTextEntry={!showConfirmPassword}
                          autoCapitalize="none"
                          editable={!passwordLoading}
                        />
                        <TouchableOpacity
                          style={styles.eyeIcon}
                          onPress={() => setShowConfirmPassword(!showConfirmPassword)}
                        >
                          <Ionicons
                            name={showConfirmPassword ? "eye-off-outline" : "eye-outline"}
                            size={20}
                            color="#AAAAAA"
                          />
                        </TouchableOpacity>
                      </View>
                      
                      <View style={styles.formButtons}>
                        <TouchableOpacity 
                          style={styles.saveButton}
                          onPress={handleChangePassword}
                          disabled={passwordLoading}
                        >
                          {passwordLoading ? (
                            <ActivityIndicator color="#FFFFFF" size="small" />
                          ) : (
                            <Text style={styles.buttonText}>Save</Text>
                          )}
                        </TouchableOpacity>
                        
                        <TouchableOpacity 
                          style={styles.cancelButton}
                          onPress={() => {
                            setShowChangePassword(false);
                            setOldPassword('');
                            setNewPassword('');
                            setConfirmPassword('');
                          }}
                          disabled={passwordLoading}
                        >
                          <Text style={styles.cancelText}>Cancel</Text>
                        </TouchableOpacity>
                      </View>
                    </View>
                  ) : (
                    <TouchableOpacity 
                      style={styles.changeButton}
                      onPress={() => setShowChangePassword(true)}
                    >
                      <Ionicons name="create-outline" size={16} color="#FFFFFF" />
                      <Text style={styles.changeButtonText}>Change Password</Text>
                    </TouchableOpacity>
                  )}
                </View>
              </View>
            </View>
            
            <TouchableOpacity style={styles.supportButton} onPress={goToSupport}>
              <Ionicons name="help-circle-outline" size={20} color="#FFFFFF" />
              <Text style={styles.supportText}>Contact Support</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
              <Ionicons name="log-out-outline" size={20} color="#FFFFFF" />
              <Text style={styles.logoutText}>Logout</Text>
            </TouchableOpacity>
          </View>
        )}
        
        {activeTab === 'achievements' && (
          <View style={styles.tabContent}>
            <View style={styles.card}>
              <View style={styles.cardHeader}>
                <Ionicons name="trophy-outline" size={20} color="#6543CC" />
                <Text style={styles.cardTitle}>Your Achievements</Text>
              </View>
              
              <View style={styles.cardBody}>
                {achievements.length > 0 ? (
                  <>
                    <Text style={styles.achievementsText}>
                      You have unlocked {achievements.length} achievements!
                    </Text>
                    <TouchableOpacity style={styles.viewMoreButton} onPress={goToAchievements}>
                      <Text style={styles.viewMoreText}>View All Achievements</Text>
                      <Ionicons name="chevron-forward" size={16} color="#6543CC" />
                    </TouchableOpacity>
                  </>
                ) : (
                  <Text style={styles.emptyStateText}>
                    Complete quizzes and challenges to earn achievements!
                  </Text>
                )}
              </View>
            </View>
          </View>
        )}
      </ScrollView>
    </SafeAreaView>
  );
};

// Status Modal Component
const StatusModal = ({ visible, message, type, onClose }) => {
  if (!visible) return null;
  
  return (
    <Modal
      transparent
      visible={visible}
      animationType="fade"
      onRequestClose={onClose}
    >
      <View style={styles.modalOverlay}>
        <View style={[
          styles.modalContent,
          type === 'success' ? styles.successModal : styles.errorModal
        ]}>
          <Ionicons 
            name={type === 'success' ? "checkmark-circle" : "alert-circle"} 
            size={24} 
            color={type === 'success' ? "#2ebb77" : "#ff4e4e"} 
          />
          <Text style={styles.modalText}>{message}</Text>
          <TouchableOpacity style={styles.modalCloseButton} onPress={onClose}>
            <Ionicons name="close" size={20} color="#AAAAAA" />
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  scrollView: {
    flex: 1,
  },
  scrollViewContent: {
    paddingHorizontal: 16,
    paddingVertical: 20,
  },
  
  // Header styles
  header: {
    flexDirection: 'row',
    backgroundColor: '#1E1E1E',
    borderRadius: 16,
    padding: 16,
    marginBottom: 20,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.3,
        shadowRadius: 6,
      },
      android: {
        elevation: 4,
      },
    }),
  },
  avatarContainer: {
    marginRight: 16,
  },
  avatar: {
    width: 80,
    height: 80,
    borderRadius: 40,
    borderWidth: 2,
    borderColor: '#6543CC',
  },
  userInfo: {
    flex: 1,
    justifyContent: 'center',
  },
  username: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 6,
  },
  levelContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  levelBadge: {
    backgroundColor: '#6543CC',
    width: 28,
    height: 28,
    borderRadius: 14,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 10,
  },
  levelText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: 'bold',
  },
  xpContainer: {
    flex: 1,
  },
  xpBar: {
    height: 6,
    backgroundColor: '#333333',
    borderRadius: 3,
    marginBottom: 4,
    overflow: 'hidden',
  },
  xpProgress: {
    height: '100%',
    backgroundColor: '#6543CC',
    borderRadius: 3,
  },
  xpText: {
    color: '#AAAAAA',
    fontSize: 12,
    textAlign: 'right',
  },
  statsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statItem: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statText: {
    color: '#FFFFFF',
    marginLeft: 4,
    fontSize: 14,
  },
  
  // Tabs styles
  tabsContainer: {
    flexDirection: 'row',
    marginBottom: 20,
    backgroundColor: '#1E1E1E',
    borderRadius: 8,
    overflow: 'hidden',
  },
  tab: {
    flex: 1,
    paddingVertical: 12,
    alignItems: 'center',
  },
  activeTab: {
    backgroundColor: '#6543CC',
  },
  tabText: {
    color: '#AAAAAA',
    fontSize: 14,
    fontWeight: '500',
  },
  activeTabText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  
  // Content styles
  tabContent: {
    flex: 1,
  },
  card: {
    backgroundColor: '#1E1E1E',
    borderRadius: 12,
    marginBottom: 16,
    overflow: 'hidden',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.2,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#333333',
  },
  cardTitle: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  cardBody: {
    padding: 16,
  },
  
  // Profile details
  profileDetail: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#333333',
  },
  detailLabel: {
    color: '#AAAAAA',
    fontSize: 14,
  },
  detailValue: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '500',
  },
  activeSubscription: {
    color: '#2ebb77',
  },
  inactiveSubscription: {
    color: '#AAAAAA',
  },
  
  // Achievements & Items
  achievementsText: {
    color: '#FFFFFF',
    fontSize: 14,
    marginBottom: 12,
  },
  itemsText: {
    color: '#FFFFFF',
    fontSize: 14,
    marginBottom: 12,
  },
  emptyStateText: {
    color: '#AAAAAA',
    fontSize: 14,
    textAlign: 'center',
    fontStyle: 'italic',
  },
  viewMoreButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    backgroundColor: 'rgba(101, 67, 204, 0.1)',
    borderRadius: 8,
  },
  viewMoreText: {
    color: '#6543CC',
    fontSize: 14,
    marginRight: 4,
  },
  
  // Account settings
  settingSection: {
    marginBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#333333',
    paddingBottom: 16,
  },
  settingHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  settingTitle: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '500',
  },
  settingValue: {
    color: '#AAAAAA',
    fontSize: 14,
  },
  changeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#6543CC',
    paddingVertical: 10,
    borderRadius: 8,
  },
  changeButtonText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 6,
  },
  
  // Forms
  changeForm: {
    marginTop: 8,
  },
  input: {
    backgroundColor: '#333333',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    color: '#FFFFFF',
    marginBottom: 12,
  },
  passwordInputContainer: {
    position: 'relative',
  },
  eyeIcon: {
    position: 'absolute',
    right: 12,
    top: '25%',
    zIndex: 1,
  },
  formButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  saveButton: {
    flex: 1,
    backgroundColor: '#6543CC',
    paddingVertical: 10,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '500',
  },
  cancelButton: {
    flex: 1,
    backgroundColor: '#333333',
    paddingVertical: 10,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  cancelText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '500',
  },
  
  // Buttons
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#E53935',
    paddingVertical: 12,
    borderRadius: 8,
    marginBottom: 20,
  },
  logoutText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  supportButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#2196F3',
    paddingVertical: 12,
    borderRadius: 8,
    marginBottom: 16,
  },
  supportText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  
  // Modal
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#1E1E1E',
    borderRadius: 12,
    padding: 16,
    width: '80%',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.3,
        shadowRadius: 6,
      },
      android: {
        elevation: 4,
      },
    }),
  },
  successModal: {
    borderLeftWidth: 4,
    borderLeftColor: '#2ebb77',
  },
  errorModal: {
    borderLeftWidth: 4,
    borderLeftColor: '#ff4e4e',
  },
  modalText: {
    flex: 1,
    color: '#FFFFFF',
    fontSize: 14,
    marginLeft: 10,
  },
  modalCloseButton: {
    marginLeft: 10,
  },
});

export default ProfileScreen;
</file>

<file path="src/screens/profile/SupportScreen.js">
// src/screens/profile/SupportScreen.js
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  TextInput,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  SafeAreaView,
  StatusBar,
  Keyboard
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import useSupport from '../../hooks/useSupport';
import {
  THREAD_STATUS,
  STATUS_INFO,
  CONNECTION_STATUS,
  EMPTY_STATES,
  PLACEHOLDERS,
  INFO_TEXTS
} from '../../constants/supportConstants';

const SupportScreen = ({ navigation }) => {
  // Use the support hook
  const {
    threads,
    messages,
    selectedThreadId,
    loadingThreads,
    loadingMessages,
    newThreadSubject,
    messageText,
    adminIsTyping,
    connectionStatus,
    error,
    messageEndRef,
    
    setNewThreadSubject,
    loadThreads,
    createThread,
    selectThread,
    sendMessage,
    handleTyping,
    closeThread,
    setError,
    formatTimestamp,
    isThreadClosed,
    getSelectedThread
  } = useSupport();
  
  // Local state for UI
  const [showInfoBanner, setShowInfoBanner] = useState(true);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [viewMode, setViewMode] = useState('threads'); // 'threads' or 'messages'
  
  // Refs
  const subjectInputRef = useRef(null);
  const messageInputRef = useRef(null);
  
  // Effect to load threads when component mounts
  useEffect(() => {
    loadThreads();
  }, [loadThreads]);
  
  // Create a new thread
  const handleCreateThread = async () => {
    if (!newThreadSubject.trim()) {
      setError('Please enter a subject for your conversation');
      return;
    }
    
    const newThread = await createThread(newThreadSubject);
    if (newThread) {
      // Auto-select the new thread
      await selectThread(newThread._id);
      setViewMode('messages');
      setShowCreateForm(false);
      
      // Focus the message input after a short delay
      setTimeout(() => {
        if (messageInputRef.current) {
          messageInputRef.current.focus();
        }
      }, 500);
    }
  };
  
  // Handle thread selection
  const handleSelectThread = async (threadId) => {
    await selectThread(threadId);
    setViewMode('messages');
    
    // Focus the message input if thread is not closed
    if (!isThreadClosed(threadId)) {
      setTimeout(() => {
        if (messageInputRef.current) {
          messageInputRef.current.focus();
        }
      }, 300);
    }
  };
  
  // Send a message in the selected thread
  const handleSendMessage = async () => {
    Keyboard.dismiss();
    await sendMessage(messageText);
  };
  
  // Handle closing a thread
  const handleCloseThread = async () => {
    const success = await closeThread();
    if (success) {
      Alert.alert(
        "Conversation Closed",
        "This conversation has been closed. You can start a new one if you need further assistance."
      );
    }
  };
  
  // Get thread item styles based on status and selection
  const getThreadItemStyles = (thread) => {
    const isSelected = thread._id === selectedThreadId;
    const isClosed = thread.status?.toLowerCase() === 'closed';
    
    return {
      container: [
        styles.threadItem,
        isSelected && styles.threadItemActive,
        isClosed && styles.threadItemClosed,
      ],
      title: [
        styles.threadSubject,
        isClosed && styles.threadTextClosed,
      ]
    };
  };
  
  // Get status indicator for a thread
  const renderStatusIndicator = (status) => {
    const statusLower = status?.toLowerCase() || 'open';
    const statusConfig = STATUS_INFO[statusLower] || STATUS_INFO.open;
    
    return (
      <View style={[styles.statusIndicator, { backgroundColor: statusConfig.color }]}>
        <Ionicons name={statusConfig.iconName} size={12} color="#FFF" />
      </View>
    );
  };
  
  // Render thread item
  const renderThreadItem = ({ item }) => {
    const threadStyles = getThreadItemStyles(item);
    const statusInfo = STATUS_INFO[item.status?.toLowerCase() || 'open'];
    
    return (
      <TouchableOpacity
        style={threadStyles.container}
        onPress={() => handleSelectThread(item._id)}
        activeOpacity={0.7}
      >
        <View style={styles.threadHeader}>
          {renderStatusIndicator(item.status)}
          <Text style={threadStyles.title} numberOfLines={1}>
            {item.subject || "Untitled"}
          </Text>
        </View>
        
        <View style={styles.threadFooter}>
          <Text style={[styles.statusText, { color: statusInfo.color }]}>
            {statusInfo.label}
          </Text>
          <Text style={styles.timestampText}>
            {formatTimestamp(item.lastUpdated)}
          </Text>
        </View>
      </TouchableOpacity>
    );
  };
  
  // Render message item
  const renderMessageItem = ({ item, index }) => {
    const isUser = item.sender === 'user';
    const isSystem = item.sender === 'system';
    
    return (
      <View 
        style={[
          styles.messageContainer,
          isUser ? styles.userMessageContainer : isSystem ? styles.systemMessageContainer : styles.adminMessageContainer
        ]}
      >
        <View style={[
          styles.messageBubble,
          isUser ? styles.userMessageBubble : isSystem ? styles.systemMessageBubble : styles.adminMessageBubble
        ]}>
          {!isSystem && (
            <Text style={[
              styles.messageSender,
              isUser ? styles.userMessageSender : styles.adminMessageSender
            ]}>
              {isUser ? 'You' : 'Support Team'}
            </Text>
          )}
          
          <Text style={styles.messageText}>{item.content}</Text>
          
          <Text style={styles.messageTimestamp}>
            {formatTimestamp(item.timestamp)}
          </Text>
        </View>
      </View>
    );
  };
  
  // Determine if the selected thread is closed
  const selectedThreadClosed = selectedThreadId ? isThreadClosed(selectedThreadId) : false;
  const selectedThread = getSelectedThread();
  
  // Render threads list view
  const renderThreadsView = () => (
    <View style={styles.threadsContainer}>
      <View style={styles.threadListHeader}>
        <Text style={styles.threadListTitle}>Your Conversations</Text>
        <TouchableOpacity 
          style={styles.refreshButton}
          onPress={loadThreads}
        >
          <Ionicons name="refresh" size={20} color="#6543CC" />
        </TouchableOpacity>
      </View>
      
      {showCreateForm ? (
        <View style={styles.createThreadForm}>
          <TextInput
            ref={subjectInputRef}
            style={styles.subjectInput}
            placeholder={PLACEHOLDERS.NEW_THREAD}
            placeholderTextColor="#9DA8B9"
            value={newThreadSubject}
            onChangeText={setNewThreadSubject}
            maxLength={100}
            autoFocus={true}
          />
          
          <View style={styles.createThreadActions}>
            <TouchableOpacity 
              style={styles.cancelButton}
              onPress={() => {
                setShowCreateForm(false);
                setNewThreadSubject('');
              }}
            >
              <Text style={styles.cancelButtonText}>Cancel</Text>
            </TouchableOpacity>
            
            <TouchableOpacity 
              style={[
                styles.createButton,
                !newThreadSubject.trim() && styles.createButtonDisabled
              ]}
              onPress={handleCreateThread}
              disabled={!newThreadSubject.trim()}
            >
              <Text style={styles.createButtonText}>Create</Text>
            </TouchableOpacity>
          </View>
        </View>
      ) : (
        <TouchableOpacity 
          style={styles.newThreadButton}
          onPress={() => {
            setShowCreateForm(true);
            setTimeout(() => {
              if (subjectInputRef.current) {
                subjectInputRef.current.focus();
              }
            }, 100);
          }}
        >
          <Ionicons name="add-circle" size={22} color="#FFF" />
          <Text style={styles.newThreadButtonText}>New Conversation</Text>
        </TouchableOpacity>
      )}
      
      {loadingThreads ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#6543CC" />
          <Text style={styles.loadingText}>Loading conversations...</Text>
        </View>
      ) : threads.length === 0 ? (
        <View style={styles.emptyStateContainer}>
          <Ionicons name="chatbubble-ellipses-outline" size={60} color="#6543CC" opacity={0.5} />
          <Text style={styles.emptyStateTitle}>{EMPTY_STATES.NO_THREADS.title}</Text>
          <Text style={styles.emptyStateSubtitle}>{EMPTY_STATES.NO_THREADS.subtitle}</Text>
        </View>
      ) : (
        <FlatList
          data={threads}
          renderItem={renderThreadItem}
          keyExtractor={(item) => item._id}
          contentContainerStyle={styles.threadsList}
          showsVerticalScrollIndicator={false}
        />
      )}
    </View>
  );
  
  // Render messages view for selected thread
  const renderMessagesView = () => (
    <View style={styles.messagesContainer}>
      <View style={styles.messagesHeader}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => setViewMode('threads')}
        >
          <Ionicons name="arrow-back" size={24} color="#6543CC" />
        </TouchableOpacity>
        
        <View style={styles.threadInfoContainer}>
          {selectedThread && (
            <>
              {renderStatusIndicator(selectedThread.status)}
              <Text style={styles.threadTitle} numberOfLines={1}>
                {selectedThread.subject}
              </Text>
            </>
          )}
        </View>
        
        {selectedThread && !selectedThreadClosed && (
          <TouchableOpacity
            style={styles.closeThreadButton}
            onPress={handleCloseThread}
          >
            <Ionicons name="close-circle-outline" size={22} color="#FF4E4E" />
          </TouchableOpacity>
        )}
      </View>
      
      {loadingMessages ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#6543CC" />
          <Text style={styles.loadingText}>Loading messages...</Text>
        </View>
      ) : messages.length === 0 ? (
        <View style={styles.emptyStateContainer}>
          <Ionicons name="chatbubbles-outline" size={60} color="#6543CC" opacity={0.5} />
          <Text style={styles.emptyStateTitle}>{EMPTY_STATES.NO_MESSAGES.title}</Text>
          <Text style={styles.emptyStateSubtitle}>{EMPTY_STATES.NO_MESSAGES.subtitle}</Text>
        </View>
      ) : (
        <FlatList
          ref={messageEndRef}
          data={messages}
          renderItem={renderMessageItem}
          keyExtractor={(item, index) => `msg-${index}-${item.timestamp}`}
          contentContainerStyle={styles.messagesList}
          showsVerticalScrollIndicator={false}
          onContentSizeChange={() => {
            if (messageEndRef.current) {
              messageEndRef.current.scrollToEnd({ animated: true });
            }
          }}
        />
      )}
      
      {/* Typing indicator */}
      {adminIsTyping && (
        <View style={styles.typingIndicatorContainer}>
          <View style={styles.typingBubble}>
            <View style={styles.typingDots}>
              <View style={styles.typingDot} />
              <View style={[styles.typingDot, styles.typingDotMiddle]} />
              <View style={styles.typingDot} />
            </View>
            <Text style={styles.typingText}>Support team is typing...</Text>
          </View>
        </View>
      )}
      
      {/* Message input or closed notice */}
      {selectedThreadClosed ? (
        <View style={styles.threadClosedNotice}>
          <Ionicons name="lock-closed" size={20} color="#9DA8B9" />
          <Text style={styles.threadClosedText}>
            This conversation is closed. Start a new one if you need more help.
          </Text>
        </View>
      ) : (
        <View style={styles.messageInputContainer}>
          <TextInput
            ref={messageInputRef}
            style={styles.messageInput}
            placeholder={PLACEHOLDERS.MESSAGE_INPUT}
            placeholderTextColor="#9DA8B9"
            value={messageText}
            onChangeText={handleTyping}
            multiline
            maxLength={2000}
          />
          
          <TouchableOpacity
            style={[
              styles.sendButton,
              !messageText.trim() && styles.sendButtonDisabled
            ]}
            onPress={handleSendMessage}
            disabled={!messageText.trim()}
          >
            <Ionicons 
              name="paper-plane" 
              size={20} 
              color={messageText.trim() ? "#FFFFFF" : "rgba(255, 255, 255, 0.5)"} 
            />
          </TouchableOpacity>
        </View>
      )}
    </View>
  );
  
  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#121212" />
      
      <View style={styles.header}>
        <Text style={styles.title}>Support / Ask Anything</Text>
        
        {showInfoBanner && (
          <View style={styles.infoBanner}>
            <View style={styles.infoContent}>
              <Ionicons name="information-circle" size={22} color="#6543CC" />
              <Text style={styles.infoText}>{INFO_TEXTS.RESPONSE_TIME}</Text>
            </View>
            <TouchableOpacity 
              style={styles.infoCloseButton}
              onPress={() => setShowInfoBanner(false)}
            >
              <Ionicons name="close" size={20} color="#9DA8B9" />
            </TouchableOpacity>
          </View>
        )}
        
        <View style={styles.connectionStatus}>
          <View style={[
            styles.connectionIndicator, 
            connectionStatus === CONNECTION_STATUS.CONNECTED 
              ? styles.connectionIndicatorConnected
              : connectionStatus === CONNECTION_STATUS.DISCONNECTED
                ? styles.connectionIndicatorDisconnected
                : styles.connectionIndicatorError
          ]} />
          <Text style={styles.connectionText}>
            {connectionStatus === CONNECTION_STATUS.CONNECTED
              ? 'Real-time connection active'
              : connectionStatus === CONNECTION_STATUS.DISCONNECTED
                ? 'Connecting to real-time service...'
                : 'Connection error - messages may be delayed'}
          </Text>
        </View>
      </View>
      
      {error && (
        <View style={styles.errorContainer}>
          <Ionicons name="alert-circle" size={20} color="#FF4E4E" />
          <Text style={styles.errorText}>{error}</Text>
          <TouchableOpacity
            style={styles.errorCloseButton}
            onPress={() => setError(null)}
          >
            <Ionicons name="close" size={18} color="#9DA8B9" />
          </TouchableOpacity>
        </View>
      )}
      
      <KeyboardAvoidingView 
        style={styles.contentContainer}
        behavior={Platform.OS === 'ios' ? 'padding' : undefined}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
      >
        {viewMode === 'threads' ? renderThreadsView() : renderMessagesView()}
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  header: {
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#333333',
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 10,
  },
  infoBanner: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: 'rgba(101, 67, 204, 0.1)',
    borderRadius: 8,
    padding: 12,
    marginTop: 5,
    marginBottom: 10,
  },
  infoContent: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  infoText: {
    color: '#FFFFFF',
    marginLeft: 10,
    fontSize: 14,
  },
  infoCloseButton: {
    padding: 5,
  },
  connectionStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 5,
  },
  connectionIndicator: {
    width: 10,
    height: 10,
    borderRadius: 5,
    marginRight: 8,
  },
  connectionIndicatorConnected: {
    backgroundColor: '#2ebb77',
  },
  connectionIndicatorDisconnected: {
    backgroundColor: '#ffc107',
  },
  connectionIndicatorError: {
    backgroundColor: '#FF4E4E',
  },
  connectionText: {
    fontSize: 13,
    color: '#9DA8B9',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 78, 78, 0.1)',
    borderRadius: 8,
    padding: 12,
    margin: 15,
    marginTop: 0,
  },
  errorText: {
    color: '#FFFFFF',
    marginLeft: 10,
    flex: 1,
    fontSize: 14,
  },
  errorCloseButton: {
    padding: 5,
  },
  contentContainer: {
    flex: 1,
  },
  
  // Threads View Styles
  threadsContainer: {
    flex: 1,
    padding: 15,
  },
  threadListHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  threadListTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  refreshButton: {
    padding: 8,
    borderRadius: 20,
    backgroundColor: 'rgba(101, 67, 204, 0.1)',
  },
  newThreadButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#6543CC',
    borderRadius: 8,
    padding: 12,
    marginBottom: 15,
  },
  newThreadButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
  createThreadForm: {
    marginBottom: 15,
  },
  subjectInput: {
    backgroundColor: '#1E1E1E',
    color: '#FFFFFF',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: '#333333',
  },
  createThreadActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
  },
  cancelButton: {
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 8,
    marginRight: 10,
  },
  cancelButtonText: {
    color: '#9DA8B9',
    fontSize: 16,
    fontWeight: '600',
  },
  createButton: {
    backgroundColor: '#6543CC',
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 8,
  },
  createButtonDisabled: {
    backgroundColor: 'rgba(101, 67, 204, 0.5)',
  },
  createButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  threadsList: {
    flexGrow: 1,
  },
  threadItem: {
    backgroundColor: '#1E1E1E',
    borderRadius: 10,
    padding: 15,
    marginBottom: 10,
    borderLeftWidth: 3,
    borderLeftColor: '#6543CC',
  },
  threadItemActive: {
    backgroundColor: 'rgba(101, 67, 204, 0.2)',
    borderLeftColor: '#8A58FC',
  },
  threadItemClosed: {
    opacity: 0.7,
    borderLeftColor: '#9DA8B9',
  },
  threadHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  statusIndicator: {
    width: 18,
    height: 18,
    borderRadius: 9,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
  },
  threadSubject: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
    flex: 1,
  },
  threadTextClosed: {
    color: '#9DA8B9',
  },
  threadFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  statusText: {
    fontSize: 13,
    fontWeight: '500',
  },
  timestampText: {
    fontSize: 12,
    color: '#9DA8B9',
  },
  
  // Messages View Styles
  messagesContainer: {
    flex: 1,
  },
  messagesHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#333333',
  },
  backButton: {
    marginRight: 10,
  },
  threadInfoContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  threadTitle: {
    color: '#FFFFFF',
    fontSize: 18,
    fontWeight: '600',
    marginLeft: 8,
    flex: 1,
  },
  closeThreadButton: {
    padding: 5,
  },
  messagesList: {
    flexGrow: 1,
    padding: 15,
  },
  messageContainer: {
    flexDirection: 'row',
    marginBottom: 15,
    maxWidth: '85%',
  },
  userMessageContainer: {
    alignSelf: 'flex-end',
    flexDirection: 'row-reverse',
  },
  adminMessageContainer: {
    alignSelf: 'flex-start',
  },
  systemMessageContainer: {
    alignSelf: 'center',
    maxWidth: '90%',
  },
  messageBubble: {
    backgroundColor: '#1E1E1E',
    borderRadius: 18,
    padding: 12,
    maxWidth: '100%',
  },
  userMessageBubble: {
    backgroundColor: 'rgba(255, 76, 139, 0.1)',
    borderBottomRightRadius: 4,
    borderWidth: 1,
    borderColor: 'rgba(255, 76, 139, 0.3)',
  },
  adminMessageBubble: {
    backgroundColor: 'rgba(134, 88, 252, 0.1)',
    borderBottomLeftRadius: 4,
    borderWidth: 1,
    borderColor: 'rgba(134, 88, 252, 0.3)',
  },
  systemMessageBubble: {
    backgroundColor: 'rgba(52, 152, 219, 0.1)',
    borderWidth: 1,
    borderColor: 'rgba(52, 152, 219, 0.3)',
  },
  messageSender: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 5,
  },
  userMessageSender: {
    color: '#FF4C8B',
  },
  adminMessageSender: {
    color: '#6543CC',
  },
  messageText: {
    color: '#FFFFFF',
    fontSize: 15,
    lineHeight: 20,
  },
  messageTimestamp: {
    fontSize: 11,
    color: '#9DA8B9',
    alignSelf: 'flex-end',
    marginTop: 5,
  },
  typingIndicatorContainer: {
    padding: 15,
    paddingTop: 0,
  },
  typingBubble: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(134, 88, 252, 0.05)',
    borderWidth: 1,
    borderColor: 'rgba(134, 88, 252, 0.2)',
    borderRadius: 18,
    padding: 10,
    alignSelf: 'flex-start',
  },
  typingDots: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 8,
  },
  typingDot: {
    width: 6,
    height: 6,
    borderRadius: 3,
    backgroundColor: '#6543CC',
    opacity: 0.5,
    marginHorizontal: 2,
  },
  typingDotMiddle: {
    marginTop: -4,
  },
  typingText: {
    color: '#9DA8B9',
    fontSize: 14,
  },
  threadClosedNotice: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(157, 168, 185, 0.1)',
    borderTopWidth: 1,
    borderTopColor: '#333333',
    padding: 15,
  },
  threadClosedText: {
    color: '#9DA8B9',
    fontSize: 14,
    marginLeft: 10,
    flex: 1,
  },
  messageInputContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    padding: 15,
    borderTopWidth: 1,
    borderTopColor: '#333333',
    backgroundColor: '#1A1A1A',
  },
  messageInput: {
    flex: 1,
    backgroundColor: '#1E1E1E',
    color: '#FFFFFF',
    borderRadius: 20,
    padding: 12,
    maxHeight: 120,
    fontSize: 16,
    marginRight: 10,
    borderWidth: 1,
    borderColor: '#333333',
  },
  sendButton: {
    backgroundColor: '#6543CC',
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
  },
  sendButtonDisabled: {
    backgroundColor: 'rgba(101, 67, 204, 0.5)',
  },
  
  // Loading and Empty States
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    color: '#FFFFFF',
    marginTop: 10,
    fontSize: 16,
  },
  emptyStateContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyStateTitle: {
    color: '#FFFFFF',
    fontSize: 18,
    fontWeight: '600',
    marginTop: 20,
    marginBottom: 5,
  },
  emptyStateSubtitle: {
    color: '#9DA8B9',
    fontSize: 16,
    textAlign: 'center',
  },
});

export default SupportScreen;
</file>

<file path="src/screens/shop/components/AvatarItem.js">
// src/screens/shop/components/AvatarItem.js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const AvatarItem = ({ item, isPurchased, isEquipped }) => {
  return (
    <View style={styles.container}>
      {/* Use a placeholder instead of trying to load images that don't exist */}
      <View style={styles.placeholderContainer}>
        <Text style={styles.placeholderText}>
          {item.title?.charAt(0) || '?'}
        </Text>
      </View>
      
      {isPurchased && (
        <View style={styles.ownershipBadgeContainer}>
          <View style={[
            styles.ownershipBadge,
            isEquipped ? styles.equippedBadge : styles.purchasedBadge
          ]}>
            <Ionicons 
              name={isEquipped ? "checkmark-circle" : "checkmark"} 
              size={14} 
              color="#FFFFFF" 
            />
          </View>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    height: 140,
    position: 'relative',
  },
  placeholderContainer: {
    width: '100%',
    height: 140,
    backgroundColor: '#2A2A2A',
    justifyContent: 'center',
    alignItems: 'center',
  },
  placeholderText: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  ownershipBadgeContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
  },
  ownershipBadge: {
    width: 24,
    height: 24,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  purchasedBadge: {
    backgroundColor: '#2ebb77',
  },
  equippedBadge: {
    backgroundColor: '#6543CC',
  },
});

export default AvatarItem;
</file>

<file path="src/screens/shop/components/BoostItem.js">
// src/screens/shop/components/BoostItem.js
import React from 'react';
import { View, StyleSheet, Text } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';

const BoostItem = ({ item, isPurchased, isEquipped }) => {
  return (
    <View style={styles.container}>
      <LinearGradient
        colors={['#6543CC', '#FF4C8B']}
        style={styles.gradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      >
        <View style={styles.content}>
          <Ionicons name="flash" size={40} color="#FFFFFF" />
          <Text style={styles.boostValue}>{item.effectValue}x</Text>
          <Text style={styles.boostLabel}>XP Boost</Text>
        </View>
      </LinearGradient>
      
      {isPurchased && (
        <View style={styles.ownershipBadgeContainer}>
          <View style={[
            styles.ownershipBadge,
            isEquipped ? styles.equippedBadge : styles.purchasedBadge
          ]}>
            <Ionicons 
              name={isEquipped ? "checkmark-circle" : "checkmark"} 
              size={14} 
              color="#FFFFFF" 
            />
          </View>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    height: 140,
    position: 'relative',
  },
  gradient: {
    width: '100%',
    height: '100%',
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  boostValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginTop: 8,
  },
  boostLabel: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.8)',
  },
  ownershipBadgeContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
  },
  ownershipBadge: {
    width: 24,
    height: 24,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  purchasedBadge: {
    backgroundColor: '#2ebb77',
  },
  equippedBadge: {
    backgroundColor: '#6543CC',
  },
});

export default BoostItem;
</file>

<file path="src/screens/shop/components/ColorItem.js">
// src/screens/shop/components/ColorItem.js
import React from 'react';
import { View, StyleSheet, Text } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const ColorItem = ({ item, isPurchased, isEquipped }) => {
  const colorValue = item.effectValue || '#FFFFFF';
  
  // Function to determine if the color is light or dark
  const isLightColor = (hexColor) => {
    // Convert hex to RGB
    const r = parseInt(hexColor.substr(1, 2), 16);
    const g = parseInt(hexColor.substr(3, 2), 16);
    const b = parseInt(hexColor.substr(5, 2), 16);
    
    // Calculate brightness (YIQ formula)
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    
    // Return true if it's a light color (brightness > 128)
    return brightness > 128;
  };
  
  const textColor = isLightColor(colorValue) ? '#000000' : '#FFFFFF';
  
  return (
    <View style={styles.container}>
      <View style={[styles.colorBox, { backgroundColor: colorValue }]}>
        <Text style={[styles.colorName, { color: textColor }]}>
          {item.title}
        </Text>
        <Text style={[styles.colorLabel, { color: textColor }]}>
          Name Color
        </Text>
      </View>
      
      {isPurchased && (
        <View style={styles.ownershipBadgeContainer}>
          <View style={[
            styles.ownershipBadge,
            isEquipped ? styles.equippedBadge : styles.purchasedBadge
          ]}>
            <Ionicons 
              name={isEquipped ? "checkmark-circle" : "checkmark"} 
              size={14} 
              color="#FFFFFF" 
            />
          </View>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    height: 140,
    position: 'relative',
  },
  colorBox: {
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  colorName: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  colorLabel: {
    fontSize: 14,
    opacity: 0.8,
  },
  ownershipBadgeContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
  },
  ownershipBadge: {
    width: 24,
    height: 24,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  purchasedBadge: {
    backgroundColor: '#2ebb77',
  },
  equippedBadge: {
    backgroundColor: '#6543CC',
  },
});

export default ColorItem;
</file>

<file path="src/screens/shop/ShopScreen.js">
// src/screens/shop/ShopScreen.js
import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Image,
  ActivityIndicator,
  RefreshControl,
  Alert,
  Modal,
  SafeAreaView,
  Platform
} from 'react-native';
import { useSelector, useDispatch } from 'react-redux';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { fetchShopItems as reduxFetchShopItems } from '../../store/slices/shopSlice';
import { fetchUserData } from '../../store/slices/userSlice';
import * as shopService from '../../api/shopService';

// Item type components
import AvatarItem from './components/AvatarItem';
import BoostItem from './components/BoostItem';
import ColorItem from './components/ColorItem';

const ShopScreen = () => {
  const dispatch = useDispatch();
  const { userId, coins, level, purchasedItems, currentAvatar } = useSelector((state) => state.user);
  const { items: reduxShopItems, status } = useSelector((state) => state.shop);
  
  const [shopItems, setShopItems] = useState([]);
  const [filteredItems, setFilteredItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [activeCategory, setActiveCategory] = useState('all');
  const [selectedItem, setSelectedItem] = useState(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [purchaseLoading, setPurchaseLoading] = useState(false);
  const [equipLoading, setEquipLoading] = useState(false);
  
  // Track whether initial loading has been done
  const initialLoadDone = useRef(false);
  
  // Initial load - using useEffect instead of useCallback to avoid infinite loop
  useEffect(() => {
    if (!initialLoadDone.current) {
      initialLoadDone.current = true;
      loadShopData();
    }
  }, []);
  
  // Watch for Redux shop items changes
  useEffect(() => {
    if (reduxShopItems && reduxShopItems.length > 0) {
      setShopItems(reduxShopItems);
      filterItems(reduxShopItems, activeCategory);
      setLoading(false);
    }
  }, [reduxShopItems, activeCategory]);
  
  // Function to load shop data
  const loadShopData = async () => {
    try {
      setLoading(true);
      // Dispatch Redux action to fetch shop items
      dispatch(reduxFetchShopItems());
    } catch (error) {
      console.error('Error loading shop data:', error);
      setLoading(false);
    }
  };
  
  // Filter items by category
  const filterItems = (items, category) => {
    if (category === 'all') {
      setFilteredItems(items);
    } else {
      setFilteredItems(items.filter(item => item.type === category));
    }
  };
  
  // Handle category change
  const handleCategoryChange = (category) => {
    setActiveCategory(category);
    filterItems(shopItems, category);
  };
  
  // Handle refresh
  const handleRefresh = async () => {
    setRefreshing(true);
    try {
      await Promise.all([
        dispatch(reduxFetchShopItems()),
        dispatch(fetchUserData(userId))
      ]);
    } catch (error) {
      console.error('Error refreshing shop data:', error);
    } finally {
      setRefreshing(false);
    }
  };
  
  // Show item details modal
  const showItemDetails = (item) => {
    setSelectedItem(item);
    setModalVisible(true);
  };
  
  // Handle item purchase
  const handlePurchase = async () => {
    if (!selectedItem) return;
    
    // Check if user has enough coins
    if (coins < selectedItem.cost) {
      Alert.alert(
        'Insufficient Coins',
        `You need ${selectedItem.cost - coins} more coins to purchase this item.`
      );
      return;
    }
    
    // Ask for confirmation
    Alert.alert(
      'Confirm Purchase',
      `Are you sure you want to purchase ${selectedItem.title} for ${selectedItem.cost} coins?`,
      [
        {
          text: 'Cancel',
          style: 'cancel'
        },
        {
          text: 'Purchase',
          onPress: async () => {
            try {
              setPurchaseLoading(true);
              await shopService.purchaseItem(userId, selectedItem._id);
              Alert.alert('Success', `You have purchased ${selectedItem.title}!`);
              
              // Refresh user data to update coins and purchased items
              await dispatch(fetchUserData(userId));
              
              // Ask if user wants to equip the item immediately
              if (selectedItem.type === 'avatar' || selectedItem.type === 'nameColor') {
                Alert.alert(
                  'Equip Item',
                  `Do you want to equip ${selectedItem.title} now?`,
                  [
                    {
                      text: 'No',
                      style: 'cancel'
                    },
                    {
                      text: 'Yes',
                      onPress: () => handleEquip()
                    }
                  ]
                );
              }
              
              // Close the modal
              setModalVisible(false);
            } catch (error) {
              Alert.alert('Error', 'Failed to purchase item. Please try again.');
              console.error('Purchase error:', error);
            } finally {
              setPurchaseLoading(false);
            }
          }
        }
      ]
    );
  };
  
  // Handle equipping an item
  const handleEquip = async () => {
    if (!selectedItem) return;
    
    try {
      setEquipLoading(true);
      await shopService.equipItem(userId, selectedItem._id);
      Alert.alert('Success', `You have equipped ${selectedItem.title}!`);
      
      // Refresh user data to update equipped items
      await dispatch(fetchUserData(userId));
      
      // Close the modal
      setModalVisible(false);
    } catch (error) {
      Alert.alert('Error', 'Failed to equip item. Please try again.');
      console.error('Equip error:', error);
    } finally {
      setEquipLoading(false);
    }
  };
  
  // Check if item is already purchased
  const isItemPurchased = (itemId) => {
    return purchasedItems && purchasedItems.includes(itemId);
  };
  
  // Check if item is already equipped
  const isItemEquipped = (itemId) => {
    return currentAvatar === itemId;
  };
  
  // Render shop item based on type
  const renderShopItem = ({ item }) => {
    const isPurchased = isItemPurchased(item._id);
    const isEquipped = isItemEquipped(item._id);
    const canPurchase = coins >= item.cost && !isPurchased;
    
    let ItemComponent;
    switch (item.type) {
      case 'avatar':
        ItemComponent = AvatarItem;
        break;
      case 'xpBoost':
        ItemComponent = BoostItem;
        break;
      case 'nameColor':
        ItemComponent = ColorItem;
        break;
      default:
        ItemComponent = AvatarItem;
    }
    
    return (
      <TouchableOpacity
        style={[
          styles.itemCard,
          isPurchased && styles.purchasedCard,
          isEquipped && styles.equippedCard
        ]}
        onPress={() => showItemDetails(item)}
        disabled={loading}
      >
        <ItemComponent item={item} isPurchased={isPurchased} isEquipped={isEquipped} />
        
        <View style={styles.itemInfo}>
          <Text style={styles.itemTitle} numberOfLines={1}>{item.title}</Text>
          
          <View style={styles.itemFooter}>
            {!isPurchased ? (
              <>
                {item.unlockLevel > level ? (
                  <View style={styles.lockedContainer}>
                    <Ionicons name="lock-closed" size={16} color="#AAAAAA" />
                    <Text style={styles.lockedText}>Unlock at Level {item.unlockLevel}</Text>
                  </View>
                ) : (
                  <View style={styles.priceContainer}>
                    <Ionicons name="cash-outline" size={16} color="#FFD700" />
                    <Text style={[
                      styles.priceText,
                      !canPurchase && styles.insufficientText
                    ]}>
                      {item.cost}
                    </Text>
                  </View>
                )}
              </>
            ) : isEquipped ? (
              <View style={styles.equippedContainer}>
                <Ionicons name="checkmark-circle" size={16} color="#2ebb77" />
                <Text style={styles.equippedText}>Equipped</Text>
              </View>
            ) : (
              <View style={styles.purchasedContainer}>
                <Ionicons name="checkmark" size={16} color="#2ebb77" />
                <Text style={styles.purchasedText}>Purchased</Text>
              </View>
            )}
          </View>
        </View>
      </TouchableOpacity>
    );
  };
  
  // Render empty state
  const renderEmpty = () => {
    if (loading) return null;
    
    return (
      <View style={styles.emptyContainer}>
        <Ionicons name="cart-outline" size={60} color="#AAAAAA" />
        <Text style={styles.emptyText}>
          No items found in this category
        </Text>
      </View>
    );
  };
  
  // Render item details modal
  const renderItemModal = () => {
    if (!selectedItem) return null;
    
    const isPurchased = isItemPurchased(selectedItem._id);
    const isEquipped = isItemEquipped(selectedItem._id);
    const canPurchase = coins >= selectedItem.cost && !isPurchased;
    const isLocked = selectedItem.unlockLevel > level;
    
    return (
      <Modal
        visible={modalVisible}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setModalVisible(false)}
            >
              <Ionicons name="close" size={24} color="#FFFFFF" />
            </TouchableOpacity>
            
            <Text style={styles.modalTitle}>{selectedItem.title}</Text>
            
            <View style={styles.modalContent}>
              {selectedItem.type === 'avatar' && (
                <View style={styles.modalAvatarContainer}>
                  {/* Use placeholders for avatar images */}
                  <View style={styles.modalAvatarPlaceholder}>
                    <Text style={styles.modalAvatarPlaceholderText}>
                      {selectedItem.title.charAt(0)}
                    </Text>
                  </View>
                </View>
              )}
              
              {selectedItem.type === 'xpBoost' && (
                <View style={styles.boostContainer}>
                  <LinearGradient
                    colors={['#6543CC', '#FF4C8B']}
                    style={styles.boostIcon}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                  >
                    <Ionicons name="flash" size={40} color="#FFFFFF" />
                  </LinearGradient>
                  <Text style={styles.boostValue}>
                    {selectedItem.effectValue}x XP Boost
                  </Text>
                </View>
              )}
              
              {selectedItem.type === 'nameColor' && (
                <View style={styles.colorContainer}>
                  <View style={[
                    styles.colorSample,
                    { backgroundColor: selectedItem.effectValue }
                  ]} />
                  <Text style={styles.colorName}>
                    {selectedItem.title}
                  </Text>
                </View>
              )}
              
              <Text style={styles.modalDescription}>
                {selectedItem.description || 'No description available.'}
              </Text>
              
              {isLocked ? (
                <View style={styles.modalLockedContainer}>
                  <Ionicons name="lock-closed" size={20} color="#AAAAAA" />
                  <Text style={styles.modalLockedText}>
                    Unlocks at Level {selectedItem.unlockLevel}
                  </Text>
                </View>
              ) : isPurchased ? (
                <View style={styles.modalActionContainer}>
                  {isEquipped ? (
                    <View style={styles.modalEquippedContainer}>
                      <Ionicons name="checkmark-circle" size={20} color="#2ebb77" />
                      <Text style={styles.modalEquippedText}>
                        Currently Equipped
                      </Text>
                    </View>
                  ) : (
                    <TouchableOpacity
                      style={styles.equipButton}
                      onPress={handleEquip}
                      disabled={equipLoading}
                    >
                      {equipLoading ? (
                        <ActivityIndicator color="#FFFFFF" size="small" />
                      ) : (
                        <>
                          <Ionicons name="checkmark-circle" size={20} color="#FFFFFF" />
                          <Text style={styles.equipButtonText}>Equip Now</Text>
                        </>
                      )}
                    </TouchableOpacity>
                  )}
                </View>
              ) : (
                <View style={styles.modalActionContainer}>
                  <View style={styles.modalPriceContainer}>
                    <Ionicons name="cash-outline" size={18} color="#FFD700" />
                    <Text style={[
                      styles.modalPriceText,
                      !canPurchase && styles.modalInsufficientText
                    ]}>
                      {selectedItem.cost}
                    </Text>
                  </View>
                  
                  <TouchableOpacity
                    style={[
                      styles.purchaseButton,
                      !canPurchase && styles.disabledButton
                    ]}
                    onPress={handlePurchase}
                    disabled={!canPurchase || purchaseLoading}
                  >
                    {purchaseLoading ? (
                      <ActivityIndicator color="#FFFFFF" size="small" />
                    ) : (
                      <>
                        <Ionicons name="cart" size={20} color="#FFFFFF" />
                        <Text style={styles.purchaseButtonText}>
                          {canPurchase ? 'Purchase' : 'Not Enough Coins'}
                        </Text>
                      </>
                    )}
                  </TouchableOpacity>
                </View>
              )}
            </View>
          </View>
        </View>
      </Modal>
    );
  };
  
  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Shop</Text>
        <View style={styles.walletContainer}>
          <Ionicons name="wallet-outline" size={20} color="#FFD700" />
          <Text style={styles.coinBalance}>{coins}</Text>
        </View>
      </View>
      
      <View style={styles.categoriesContainer}>
        <ScrollableTabs
          tabs={[
            { id: 'all', label: 'All Items' },
            { id: 'avatar', label: 'Avatars' },
            { id: 'xpBoost', label: 'XP Boosts' },
            { id: 'nameColor', label: 'Name Colors' }
          ]}
          activeTab={activeCategory}
          onTabChange={handleCategoryChange}
        />
      </View>
      
      <FlatList
        data={filteredItems}
        renderItem={renderShopItem}
        keyExtractor={(item) => item._id}
        numColumns={2}
        contentContainerStyle={styles.listContent}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={['#6543CC']}
            tintColor="#6543CC"
          />
        }
        ListEmptyComponent={renderEmpty}
        columnWrapperStyle={styles.columnWrapper}
      />
      
      {renderItemModal()}
      
      {loading && !refreshing && (
        <View style={styles.loadingOverlay}>
          <ActivityIndicator size="large" color="#6543CC" />
        </View>
      )}
    </SafeAreaView>
  );
};

// ScrollableTabs component
const ScrollableTabs = ({ tabs, activeTab, onTabChange }) => {
  return (
    <FlatList
      data={tabs}
      horizontal
      showsHorizontalScrollIndicator={false}
      keyExtractor={(item) => item.id}
      contentContainerStyle={styles.tabsContainer}
      renderItem={({ item }) => (
        <TouchableOpacity
          style={[
            styles.tabButton,
            activeTab === item.id && styles.activeTabButton
          ]}
          onPress={() => onTabChange(item.id)}
        >
          <Text style={[
            styles.tabButtonText,
            activeTab === item.id && styles.activeTabButtonText
          ]}>
            {item.label}
          </Text>
        </TouchableOpacity>
      )}
    />
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#1E1E1E',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  walletContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#2A2A2A',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  coinBalance: {
    color: '#FFFFFF',
    fontWeight: 'bold',
    marginLeft: 6,
  },
  categoriesContainer: {
    backgroundColor: '#1A1A1A',
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#333333',
  },
  tabsContainer: {
    paddingHorizontal: 16,
  },
  tabButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    marginRight: 8,
    backgroundColor: '#2A2A2A',
  },
  activeTabButton: {
    backgroundColor: '#6543CC',
  },
  tabButtonText: {
    color: '#AAAAAA',
    fontWeight: '500',
  },
  activeTabButtonText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  listContent: {
    padding: 12,
  },
  columnWrapper: {
    justifyContent: 'space-between',
  },
  itemCard: {
    width: '48%',
    backgroundColor: '#1E1E1E',
    borderRadius: 12,
    marginBottom: 16,
    overflow: 'hidden',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  purchasedCard: {
    borderWidth: 1,
    borderColor: '#2ebb77',
  },
  equippedCard: {
    borderWidth: 1,
    borderColor: '#6543CC',
  },
  itemImage: {
    width: '100%',
    height: 120,
    backgroundColor: '#2A2A2A',
  },
  itemInfo: {
    padding: 12,
  },
  itemTitle: {
    fontSize: 14,
    fontWeight: '500',
    color: '#FFFFFF',
    marginBottom: 8,
  },
  itemFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  priceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  priceText: {
    color: '#FFD700',
    fontWeight: 'bold',
    marginLeft: 4,
  },
  insufficientText: {
    color: '#FF4C8B',
  },
  lockedContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  lockedText: {
    color: '#AAAAAA',
    fontSize: 12,
    marginLeft: 4,
  },
  purchasedContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  purchasedText: {
    color: '#2ebb77',
    fontSize: 12,
    marginLeft: 4,
  },
  equippedContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  equippedText: {
    color: '#2ebb77',
    fontSize: 12,
    fontWeight: 'bold',
    marginLeft: 4,
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyText: {
    fontSize: 16,
    color: '#AAAAAA',
    textAlign: 'center',
    marginTop: 10,
  },
  loadingOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.4)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '80%',
    backgroundColor: '#1E1E1E',
    borderRadius: 16,
    padding: 20,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.3,
        shadowRadius: 8,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  closeButton: {
    position: 'absolute',
    top: 12,
    right: 12,
    zIndex: 1,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 16,
    textAlign: 'center',
  },
  modalContent: {
    alignItems: 'center',
  },
  modalAvatarContainer: {
    width: 120,
    height: 120,
    marginBottom: 16,
  },
  modalAvatarPlaceholder: {
    width: 120,
    height: 120,
    borderRadius: 60,
    backgroundColor: '#2A2A2A',
    justifyContent: 'center',
    alignItems: 'center'
  },
  modalAvatarPlaceholderText: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#FFFFFF'
  },
  boostContainer: {
    alignItems: 'center',
    marginBottom: 16,
  },
  boostIcon: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 8,
  },
  boostValue: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  colorContainer: {
    alignItems: 'center',
    marginBottom: 16,
  },
  colorSample: {
    width: 80,
    height: 80,
    borderRadius: 40,
    marginBottom: 8,
  },
  colorName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  modalDescription: {
    fontSize: 14,
    color: '#AAAAAA',
    textAlign: 'center',
    marginBottom: 20,
  },
  modalLockedContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(170, 170, 170, 0.1)',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
  },
  modalLockedText: {
    color: '#AAAAAA',
    marginLeft: 8,
  },
  modalActionContainer: {
    width: '100%',
  },
  modalPriceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 12,
  },
  modalPriceText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFD700',
    marginLeft: 8,
  },
  modalInsufficientText: {
    color: '#FF4C8B',
  },
  purchaseButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#6543CC',
    paddingVertical: 12,
    borderRadius: 8,
  },
  disabledButton: {
    backgroundColor: '#4F4F4F',
  },
  purchaseButtonText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
    marginLeft: 8,
  },
  modalEquippedContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#2ebb77',
  },
  modalEquippedText: {
    color: '#2ebb77',
    fontWeight: 'bold',
    marginLeft: 8,
  },
  equipButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#2ebb77',
    paddingVertical: 12,
    borderRadius: 8,
  },
  equipButtonText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
    marginLeft: 8,
  },
});

export default ShopScreen;
</file>

<file path="src/screens/tests/categories/APlus2Screen.js">
// src/screens/tests/categories/APlus2Screen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * A+ Core 2 (1102) Test List Screen
 */
const APlus2Screen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'aplus2',
    title: route.params?.title || 'CompTIA A+ Core 2 (1102) 🖥️',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default APlus2Screen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/APlusScreen.js">
// src/screens/tests/categories/APlusScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * A+ Core 1 (1101) Test List Screen
 */
const APlusScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    // If route.params.category is missing, default to 'aplus'
    category: route.params?.category || 'aplus',
    // If route.params.title is missing, default:
    title: route.params?.title || 'CompTIA A+ Core 1 (1101)',
  };
  
  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default APlusScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/AWSCloudScreen.js">
// src/screens/tests/categories/AWSCloudScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * AWS Cloud Practitioner Test List Screen
 */
const AWSCloudScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'awscloud',
    title: route.params?.title || 'AWS Cloud Practitioner (CLE-002) 🌥️',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default AWSCloudScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/CaspPlusScreen.js">
// src/screens/tests/categories/CaspPlusScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * CASP+ (CAS-005) Test List Screen
 */
const CaspPlusScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'caspplus',
    title: route.params?.title || 'CompTIA Security-X (CAS-005) ⚔️',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default CaspPlusScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/CisspScreen.js">
// src/screens/tests/categories/CisspScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * CISSP Test List Screen
 */
const CisspScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'cissp',
    title: route.params?.title || '(ISC)² CISSP 👾',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default CisspScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/CloudPlusScreen.js">
// src/screens/tests/categories/CloudPlusScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * Cloud+ (CV0-004) Test List Screen
 */
const CloudPlusScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'cloudplus',
    title: route.params?.title || 'CompTIA Cloud+ (CV0-004) 🌩️',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default CloudPlusScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/CySAPlusScreen.js">
// src/screens/tests/categories/CySAPlusScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * CySA+ (CS0-003) Test List Screen
 */
const CySAPlusScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'cysa',
    title: route.params?.title || 'CompTIA CySA+ (CS0-003) 🕵️‍♂️',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default CySAPlusScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/DataPlusScreen.js">
// src/screens/tests/categories/DataPlusScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * Data+ (DA0-001) Test List Screen
 */
const DataPlusScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'dataplus',
    title: route.params?.title || 'CompTIA Data+ (DA0-001) 📋',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default DataPlusScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/LinuxPlusScreen.js">
// src/screens/tests/categories/LinuxPlusScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * Linux+ (XK0-005) Test List Screen
 */
const LinuxPlusScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'linuxplus',
    title: route.params?.title || 'CompTIA Linux+ (XK0-005) 🐧',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default LinuxPlusScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/NetworkPlusScreen.js">
// src/screens/tests/categories/NetworkPlusScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * Network+ (N10-009) Test List Screen
 */
const NetworkPlusScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'nplus',
    title: route.params?.title || 'CompTIA Network+ (N10-009) 📡',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default NetworkPlusScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/PenPlusScreen.js">
// src/screens/tests/categories/PenPlusScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * PenTest+ (PT0-003) Test List Screen
 */
const PenPlusScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'penplus',
    title: route.params?.title || 'CompTIA PenTest+ (PT0-003) 🐍',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default PenPlusScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/SecurityPlusScreen.js">
// src/screens/tests/categories/SecurityPlusScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * Security+ (SY0-701) Test List Screen
 */
const SecurityPlusScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'secplus',
    title: route.params?.title || 'CompTIA Security+ (SY0-701) 🔐',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default SecurityPlusScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/categories/ServerPlusScreen.js">
// src/screens/tests/categories/ServerPlusScreen.js
import React from 'react';
import { StyleSheet } from 'react-native';
import TestListScreen from '../TestListScreen';

/**
 * Server+ (SK0-005) Test List Screen
 */
const ServerPlusScreen = ({ navigation, route }) => {
  // Provide fallback
  const params = {
    ...route.params,
    category: route.params?.category || 'serverplus',
    title: route.params?.title || 'CompTIA Server+ (SK0-005) 🧛‍♂️',
  };

  return (
    <TestListScreen
      navigation={navigation}
      route={{ ...route, params }}
    />
  );
};

export default ServerPlusScreen;

const styles = StyleSheet.create({});
</file>

<file path="src/screens/tests/TestListScreen.js">
// src/screens/tests/TestListScreen.js
import React, { useState, useEffect, useCallback } from 'react';
import { 
  View, 
  Text, 
  FlatList, 
  StyleSheet, 
  TouchableOpacity, 
  ActivityIndicator, 
  Alert, 
  RefreshControl,
  Modal
} from 'react-native';
import { useSelector, useDispatch } from 'react-redux';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import * as SecureStore from 'expo-secure-store';
import testService from '../../api/testService';
import { DIFFICULTY_CATEGORIES, TEST_LENGTHS } from '../../constants/testConstants';

/**
 * TestListScreen displays a list of tests for a particular certification category
 * 
 * @param {Object} props - Component props
 * @param {Object} props.route - Route object containing params
 * @param {Object} props.navigation - Navigation object
 * @returns {JSX.Element} - TestListScreen component
 */
const TestListScreen = ({ route, navigation }) => {
  const { category, title } = route.params || {};
  const { userId } = useSelector(state => state.user);
  
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState(null);
  const [tests, setTests] = useState([]);
  const [attemptsData, setAttemptsData] = useState({});
  
  // Exam mode toggle
  const [examMode, setExamMode] = useState(false);
  
  // Modal states
  const [showInfoModal, setShowInfoModal] = useState(false);
  const [showRestartModal, setShowRestartModal] = useState(false);
  const [selectedTest, setSelectedTest] = useState(null);
  
  // Test length
  const allowedTestLengths = TEST_LENGTHS;
  const [selectedLengths, setSelectedLengths] = useState({});
  const [showTestLengthModal, setShowTestLengthModal] = useState(false);
  const [testForLength, setTestForLength] = useState(null);
  
  // Difficulty categories with colors and levels
  const difficultyCategories = DIFFICULTY_CATEGORIES;
  
  // Fetch tests and attempts
  const fetchTestsAndAttempts = useCallback(async () => {
    try {
      setLoading(true);
      
      // First, fetch generated test data for this category (similar to web app)
      try {
        const testsData = await testService.fetchTestsByCategory(category);
        setTests(testsData);
      } catch (testErr) {
        console.error('Error generating tests:', testErr);
        setError(testErr.message || 'Failed to load tests');
        setLoading(false);
        return;
      }
      
      // Then fetch user's attempts if logged in
      if (userId) {
        try {
          const attemptsData = await testService.listTestAttempts(userId);
          const attemptsList = attemptsData.attempts || [];
          
          // Filter attempts for this category
          const relevantAttempts = attemptsList.filter(a => a.category === category);
          
          // Process attempts to get best attempt per test
          const bestAttempts = {};
          for (let att of relevantAttempts) {
            const testKey = att.testId;
            
            // Skip attempts that don't have a valid testId
            if (testKey === undefined || testKey === null) continue;
            
            if (!bestAttempts[testKey]) {
              bestAttempts[testKey] = att;
            } else {
              const existing = bestAttempts[testKey];
              
              // If existing is finished and new is unfinished, keep finished
              if (existing.finished && !att.finished) {
                // Keep existing (finished beats unfinished)
              } 
              // If existing is unfinished and new is finished, use new
              else if (!existing.finished && att.finished) {
                bestAttempts[testKey] = att;
              }
              // If both are finished or both are unfinished, pick newest
              else {
                const existingTime = new Date(existing.finishedAt || existing.updatedAt || 0).getTime();
                const newTime = new Date(att.finishedAt || att.updatedAt || 0).getTime();
                
                if (newTime > existingTime) {
                  bestAttempts[testKey] = att;
                }
              }
            }
          }
          
          setAttemptsData(bestAttempts);
        } catch (attemptErr) {
          console.error('Error fetching attempts:', attemptErr);
          // Continue with empty attempts - don't fail the whole screen
        }
      }
      
      setError(null);
    } catch (err) {
      console.error('Error in fetchTestsAndAttempts:', err);
      setError(err.message || 'Failed to load tests');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, [userId, category]);
  
  // Load data when screen comes into focus
  useFocusEffect(
    useCallback(() => {
      fetchTestsAndAttempts();
      
      // Load the exam mode from storage
      const loadExamMode = async () => {
        try {
          const storedMode = await SecureStore.getItemAsync('examMode');
          setExamMode(storedMode === 'true');
        } catch (err) {
          console.error('Error loading exam mode:', err);
        }
      };
      
      loadExamMode();
    }, [fetchTestsAndAttempts])
  );
  
  // Save exam mode to storage when it changes
  useEffect(() => {
    SecureStore.setItemAsync('examMode', examMode ? 'true' : 'false');
  }, [examMode]);
  
  // Handle refresh
  const handleRefresh = () => {
    setRefreshing(true);
    fetchTestsAndAttempts();
  };
  
  // Handle exam mode toggle
  const toggleExamMode = () => {
    setExamMode(prev => !prev);
  };
  
  // Get attempt doc for a test
  const getAttemptDoc = (testNumber) => {
    return attemptsData[testNumber] || null;
  };
  
  // Get progress display for an attempt
  const getProgressDisplay = (attemptDoc) => {
    if (!attemptDoc) return { text: "Not started", percentage: 0 };
    
    const { finished, score, totalQuestions, currentQuestionIndex, examMode } = attemptDoc;
    const totalQuestionsPerTest = 100;
    
    if (finished === true) {
      const pct = Math.round((score / (totalQuestions || totalQuestionsPerTest)) * 100);
      return { 
        text: `Score: ${score}/${totalQuestions || totalQuestionsPerTest} (${pct}%)${examMode ? ' (Exam Mode)' : ''}`, 
        percentage: pct,
        isFinished: true,
        isExamMode: examMode === true
      };
    } else {
      if (typeof currentQuestionIndex === "number") {
        const progressPct = Math.round(((currentQuestionIndex + 1) / (totalQuestions || totalQuestionsPerTest)) * 100);
        return { 
          text: `Progress: ${currentQuestionIndex + 1}/${totalQuestions || totalQuestionsPerTest}${examMode ? ' (Exam Mode)' : ''}`, 
          percentage: progressPct,
          isFinished: false,
          isExamMode: examMode === true
        };
      }
      return { text: "Not started", percentage: 0 };
    }
  };
  
  // Start or resume a test
  const startTest = (testNumber, doRestart = false, existingAttempt = null) => {
    // For new tests (or restart), show length selector
    if (doRestart || !existingAttempt) {
      setTestForLength(testNumber);
      setShowTestLengthModal(true);
      return;
    }
    
    // For resuming, use attempt's exam mode
    const attemptExamMode = existingAttempt.examMode === true;
    
    // Navigate to test screen with appropriate params
    navigation.navigate('Test', {
      testId: testNumber,
      category,
      title: `${title} - Test ${testNumber}`,
      examMode: attemptExamMode,
      resuming: true
    });
  };
  
  // Create a new attempt with selected length
  const createNewAttempt = async (testNumber, selectedLength) => {
    try {
      const response = await testService.createOrUpdateAttempt(userId, testNumber, {
        category,
        answers: [],
        score: 0,
        totalQuestions: 100,
        selectedLength,
        currentQuestionIndex: 0,
        shuffleOrder: [], // Will be generated on the test screen
        answerOrder: [],  // Will be generated on the test screen
        finished: false,
        examMode,
      });
      
      if (!response) {
        throw new Error("Failed to create attempt document");
      }
      
      // Navigate to test screen
      navigation.navigate('Test', {
        testId: testNumber,
        category,
        title: `${title} - Test ${testNumber}`,
        examMode,
        restarting: true,
        selectedLength
      });
    } catch (err) {
      console.error("Failed to create new attempt:", err);
      Alert.alert("Error", "Failed to start test. Please try again.");
    }
  };
  
  // Handle test length selection
  const handleTestLengthSelect = (length) => {
    setSelectedLengths(prev => ({
      ...prev,
      [testForLength]: length
    }));
  };
  
  // Confirm and start test with selected length
  const confirmTestLength = () => {
    const length = selectedLengths[testForLength] || 100;
    setShowTestLengthModal(false);
    createNewAttempt(testForLength, length);
  };
  
  // Render each test item in the list
  const renderTestItem = ({ item }) => {
    // Handle if item is a test object or just a number
    const testNumber = typeof item === 'object' ? item.testId : item;
    const testName = typeof item === 'object' ? item.testName : `Test ${testNumber}`;
    
    const attemptDoc = getAttemptDoc(testNumber);
    const progress = getProgressDisplay(attemptDoc);
    const difficulty = difficultyCategories[testNumber - 1] || difficultyCategories[0];
    
    const isFinished = attemptDoc?.finished;
    const noAttempt = !attemptDoc;
    const inProgress = attemptDoc && !isFinished;
    
    return (
      <View style={[
        styles.testCard,
        isFinished && styles.completedCard,
        inProgress && styles.progressCard
      ]}>
        <View style={styles.testCardHeader}>
          <Text style={styles.testNumberText}>{testName}</Text>
          <View style={[
            styles.difficultyBadge,
            { backgroundColor: difficulty.color }
          ]}>
            <Text style={[styles.difficultyText, { color: difficulty.textColor }]}>
              {difficulty.label}
            </Text>
          </View>
        </View>
        
        <View style={styles.progressSection}>
          <Text style={styles.progressText}>{progress.text}</Text>
          <View style={styles.progressBarContainer}>
            <View 
              style={[
                styles.progressBar,
                isFinished && styles.completedBar,
                { width: `${progress.percentage}%` }
              ]}
            />
          </View>
        </View>
        
        {/* Test Length Selector (for new or finished tests) */}
        {(noAttempt || isFinished) && (
          <View style={styles.lengthSelector}>
            <Text style={styles.lengthLabel}>Questions:</Text>
            <View style={styles.lengthOptions}>
              {allowedTestLengths.map(length => (
                <TouchableOpacity
                  key={length}
                  style={[
                    styles.lengthOption,
                    (selectedLengths[testNumber] || 100) === length && styles.selectedLength
                  ]}
                  onPress={() => setSelectedLengths(prev => ({
                    ...prev,
                    [testNumber]: length
                  }))}
                >
                  <Text style={[
                    styles.lengthOptionText,
                    (selectedLengths[testNumber] || 100) === length && styles.selectedLengthText
                  ]}>
                    {length}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>
        )}
        
        <View style={styles.actionButtons}>
          {noAttempt && (
            <TouchableOpacity 
              style={styles.startButton}
              onPress={() => startTest(testNumber, false, null)}
            >
              <Ionicons name="play" size={18} color="#FFFFFF" />
              <Text style={styles.buttonText}>Start Test</Text>
            </TouchableOpacity>
          )}
          
          {inProgress && (
            <View style={styles.buttonRow}>
              <TouchableOpacity 
                style={styles.resumeButton}
                onPress={() => startTest(testNumber, false, attemptDoc)}
              >
                <Ionicons name="play" size={18} color="#FFFFFF" />
                <Text style={styles.buttonText}>
                  {attemptDoc?.examMode ? "Resume Exam" : "Resume"}
                </Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={styles.restartButton}
                onPress={() => {
                  setSelectedTest(testNumber);
                  setShowRestartModal(true);
                }}
              >
                <Ionicons name="refresh" size={18} color="#FFFFFF" />
                <Text style={styles.buttonText}>Restart</Text>
              </TouchableOpacity>
            </View>
          )}
          
          {isFinished && (
            <View style={styles.buttonRow}>
              <TouchableOpacity 
                style={styles.reviewButton}
                onPress={() => navigation.navigate('Test', {
                  testId: testNumber,
                  category,
                  title: `${title} - Test ${testNumber}`,
                  review: true
                })}
              >
                <Ionicons name="eye" size={18} color="#FFFFFF" />
                <Text style={styles.buttonText}>View Results</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={styles.restartButton}
                onPress={() => startTest(testNumber, true, attemptDoc)}
              >
                <Ionicons name="refresh" size={18} color="#FFFFFF" />
                <Text style={styles.buttonText}>Restart</Text>
              </TouchableOpacity>
            </View>
          )}
        </View>
        
        {isFinished && progress.percentage >= 80 && (
          <View style={styles.achievementBadge}>
            <Ionicons name="trophy" size={20} color="#FFD700" />
          </View>
        )}
      </View>
    );
  };
  
  // Handle restart confirmation
  const confirmRestart = () => {
    setShowRestartModal(false);
    const attemptDoc = getAttemptDoc(selectedTest);
    startTest(selectedTest, true, attemptDoc);
  };
  
  // If no userId, show login prompt
  if (!userId) {
    return (
      <View style={styles.container}>
        <View style={styles.authMessage}>
          <Ionicons name="lock-closed" size={50} color="#6543CC" />
          <Text style={styles.authTitle}>Login Required</Text>
          <Text style={styles.authSubtitle}>Please log in to access the practice tests</Text>
          <TouchableOpacity 
            style={styles.loginButton}
            onPress={() => navigation.navigate('Login')}
          >
            <Text style={styles.loginButtonText}>Go to Login</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }
  
  // If loading, show spinner
  if (loading && !refreshing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6543CC" />
        <Text style={styles.loadingText}>Loading tests...</Text>
      </View>
    );
  }
  
  // If error, show error message
  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Ionicons name="alert-circle" size={50} color="#FF4E4E" />
        <Text style={styles.errorTitle}>Error Loading Tests</Text>
        <Text style={styles.errorMessage}>{error}</Text>
        <TouchableOpacity 
          style={styles.retryButton}
          onPress={fetchTestsAndAttempts}
        >
          <Text style={styles.retryButtonText}>Retry</Text>
        </TouchableOpacity>
      </View>
    );
  }
  
  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.titleSection}>
          <Text style={styles.title}>{title}</Text>
          <Text style={styles.subtitle}>Practice Test Collection</Text>
        </View>
        
        <View style={styles.examModeToggle}>
          <TouchableOpacity 
            style={styles.infoButton}
            onPress={() => setShowInfoModal(true)}
          >
            <Ionicons name="information-circle" size={24} color="#AAAAAA" />
          </TouchableOpacity>
          
          <View style={styles.toggleContainer}>
            <Text style={styles.toggleLabel}>Exam Mode</Text>
            <TouchableOpacity 
              style={[styles.toggle, examMode && styles.toggleActive]}
              onPress={toggleExamMode}
            >
              <View style={[styles.toggleHandle, examMode && styles.toggleHandleActive]} />
            </TouchableOpacity>
          </View>
        </View>
      </View>
      
      <FlatList
        data={tests}
        keyExtractor={item => (typeof item === 'object' ? item.testId.toString() : item.toString())}
        renderItem={renderTestItem}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl 
            refreshing={refreshing} 
            onRefresh={handleRefresh} 
            colors={["#6543CC"]}
            tintColor="#6543CC"
          />
        }
      />
      
      {/* Info Modal */}
      <Modal
        visible={showInfoModal}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setShowInfoModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Exam Mode</Text>
            <Text style={styles.modalText}>
              Exam Mode simulates a real exam environment:
              {'\n\n'}• No immediate feedback on answers
              {'\n'}• See results only after completing the test
              {'\n'}• Answers cannot be changed after submission
              {'\n'}• Time is tracked for the entire session
              {'\n\n'}This is perfect for final exam preparation!
            </Text>
            <TouchableOpacity 
              style={styles.modalButton}
              onPress={() => setShowInfoModal(false)}
            >
              <Text style={styles.modalButtonText}>Got It</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
      
      {/* Restart Confirmation Modal */}
      <Modal
        visible={showRestartModal}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setShowRestartModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Ionicons name="warning" size={30} color="#FFC107" style={styles.modalIcon} />
            <Text style={styles.modalTitle}>Confirm Restart</Text>
            <Text style={styles.modalText}>
              You're currently in progress on Test {selectedTest}. Are you sure you want to restart?
              {'\n\n'}All current progress will be lost, and your test will begin with your selected length.
            </Text>
            <View style={styles.modalButtons}>
              <TouchableOpacity 
                style={[styles.modalButton, styles.confirmButton]}
                onPress={confirmRestart}
              >
                <Text style={styles.modalButtonText}>Yes, Restart</Text>
              </TouchableOpacity>
              <TouchableOpacity 
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowRestartModal(false)}
              >
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
      
      {/* Test Length Modal */}
      <Modal
        visible={showTestLengthModal}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setShowTestLengthModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Select Test Length</Text>
            <Text style={styles.modalText}>
              How many questions would you like to answer?
              {examMode ? '\n\nExam Mode is ON' : ''}
            </Text>
            
            <View style={styles.lengthModalOptions}>
              {allowedTestLengths.map(length => (
                <TouchableOpacity
                  key={length}
                  style={[
                    styles.lengthModalOption,
                    (selectedLengths[testForLength] || 100) === length && styles.selectedLengthModalOption
                  ]}
                  onPress={() => handleTestLengthSelect(length)}
                >
                  <Text style={[
                    styles.lengthModalOptionText,
                    (selectedLengths[testForLength] || 100) === length && styles.selectedLengthModalOptionText
                  ]}>
                    {length}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
            
            <View style={styles.modalButtons}>
              <TouchableOpacity 
                style={[styles.modalButton, styles.confirmButton]}
                onPress={confirmTestLength}
              >
                <Text style={styles.modalButtonText}>Start Test</Text>
              </TouchableOpacity>
              <TouchableOpacity 
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowTestLengthModal(false)}
              >
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  header: {
    backgroundColor: '#1E1E1E',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#2A2A2A',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    flexWrap: 'wrap',
  },
  titleSection: {
    flex: 1,
    marginRight: 10,
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#6543CC',
    marginBottom: 5,
  },
  subtitle: {
    fontSize: 14,
    color: '#AAAAAA',
  },
  examModeToggle: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  infoButton: {
    padding: 5,
  },
  toggleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderRadius: 20,
    marginLeft: 5,
  },
  toggleLabel: {
    color: '#FFFFFF',
    fontSize: 14,
    marginRight: 10,
  },
  toggle: {
    width: 50,
    height: 26,
    borderRadius: 13,
    backgroundColor: '#2A2A2A',
    padding: 2,
    justifyContent: 'center',
  },
  toggleActive: {
    backgroundColor: '#6543CC',
  },
  toggleHandle: {
    width: 22,
    height: 22,
    borderRadius: 11,
    backgroundColor: '#FFFFFF',
  },
  toggleHandleActive: {
    alignSelf: 'flex-end',
  },
  listContent: {
    padding: 15,
  },
  testCard: {
    backgroundColor: '#1E1E1E',
    borderRadius: 12,
    marginBottom: 15,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: '#2A2A2A',
  },
  completedCard: {
    borderColor: '#2EBB77',
  },
  progressCard: {
    borderColor: '#6543CC',
  },
  testCardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 15,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderBottomWidth: 1,
    borderBottomColor: '#2A2A2A',
  },
  testNumberText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  difficultyBadge: {
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
  },
  difficultyText: {
    fontSize: 12,
    fontWeight: 'bold',
  },
  progressSection: {
    padding: 15,
  },
  progressText: {
    fontSize: 14,
    color: '#AAAAAA',
    marginBottom: 8,
  },
  progressBarContainer: {
    height: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 4,
    overflow: 'hidden',
  },
  progressBar: {
    height: '100%',
    backgroundColor: '#6543CC',
  },
  completedBar: {
    backgroundColor: '#2EBB77',
  },
  lengthSelector: {
    padding: 15,
    paddingTop: 0,
  },
  lengthLabel: {
    fontSize: 14,
    color: '#AAAAAA',
    marginBottom: 8,
  },
  lengthOptions: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  lengthOption: {
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderWidth: 1,
    borderColor: '#2A2A2A',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
    marginRight: 8,
    marginBottom: 8,
  },
  selectedLength: {
    backgroundColor: '#6543CC',
    borderColor: '#7E65D3',
  },
  lengthOptionText: {
    color: '#FFFFFF',
    fontSize: 12,
  },
  selectedLengthText: {
    fontWeight: 'bold',
  },
  actionButtons: {
    padding: 15,
    paddingTop: 0,
  },
  buttonRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  startButton: {
    backgroundColor: '#6543CC',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 8,
  },
  resumeButton: {
    backgroundColor: '#6543CC',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 8,
    flex: 1,
    marginRight: 8,
  },
  restartButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 8,
    flex: 1,
    marginLeft: 8,
  },
  reviewButton: {
    backgroundColor: '#2EBB77',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 8,
    flex: 1,
    marginRight: 8,
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  achievementBadge: {
    position: 'absolute',
    top: 10,
    right: 10,
    width: 30,
    height: 30,
    borderRadius: 15,
    backgroundColor: 'rgba(255, 215, 0, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  // Loading and Error states
  loadingContainer: {
    flex: 1,
    backgroundColor: '#121212',
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    color: '#FFFFFF',
    marginTop: 10,
    fontSize: 16,
  },
  errorContainer: {
    flex: 1,
    backgroundColor: '#121212',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorTitle: {
    color: '#FFFFFF',
    fontSize: 20,
    fontWeight: 'bold',
    marginTop: 15,
  },
  errorMessage: {
    color: '#AAAAAA',
    textAlign: 'center',
    marginTop: 10,
    marginBottom: 20,
  },
  retryButton: {
    backgroundColor: '#6543CC',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  // Auth message
  authMessage: {
    flex: 1,
    backgroundColor: '#121212',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  authTitle: {
    color: '#FFFFFF',
    fontSize: 20,
    fontWeight: 'bold',
    marginTop: 15,
  },
  authSubtitle: {
    color: '#AAAAAA',
    textAlign: 'center',
    marginTop: 10,
    marginBottom: 20,
  },
  loginButton: {
    backgroundColor: '#6543CC',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  loginButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  // Modals
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: '#1E1E1E',
    borderRadius: 12,
    width: '85%',
    padding: 20,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#2A2A2A',
  },
  modalIcon: {
    marginBottom: 10,
  },
  modalTitle: {
    color: '#FFFFFF',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
  },
  modalText: {
    color: '#CCCCCC',
    fontSize: 15,
    textAlign: 'center',
    marginBottom: 20,
    lineHeight: 22,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'center',
    width: '100%',
  },
  modalButton: {
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
    minWidth: 120,
    alignItems: 'center',
    marginHorizontal: 5,
  },
  confirmButton: {
    backgroundColor: '#6543CC',
  },
  cancelButton: {
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: '#2A2A2A',
  },
  modalButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  cancelButtonText: {
    color: '#AAAAAA',
    fontSize: 16,
    fontWeight: 'bold',
  },
  // Test Length Modal specific
  lengthModalOptions: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    marginBottom: 20,
  },
  lengthModalOption: {
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderWidth: 1,
    borderColor: '#2A2A2A',
    paddingHorizontal: 15,
    paddingVertical: 10,
    borderRadius: 8,
    margin: 5,
    minWidth: 60,
    alignItems: 'center',
  },
  selectedLengthModalOption: {
    backgroundColor: '#6543CC',
    borderColor: '#7E65D3',
  },
  lengthModalOptionText: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  selectedLengthModalOptionText: {
    fontWeight: 'bold',
  },
});

export default TestListScreen;
</file>

<file path="src/screens/tests/TestScreen.js">
// src/screens/tests/TestScreen.js
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  StyleSheet,
  ActivityIndicator,
  Alert,
  Modal,
  FlatList,
  Animated
} from 'react-native';
import { useSelector, useDispatch } from 'react-redux';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import * as SecureStore from 'expo-secure-store';

// Replace all direct fetch calls with testService
import testService from '../../api/testService';

import { fetchShopItems } from '../../store/slices/shopSlice';
import { fetchAchievements } from '../../store/slices/achievementsSlice';

import FormattedQuestion from '../../components/FormattedQuestion';

// Helper functions
const shuffleArray = (arr) => {
  const copy = [...arr];
  for (let i = copy.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [copy[i], copy[j]] = [copy[j], copy[i]];
  }
  return copy;
};

const shuffleIndices = (length) => {
  const indices = Array.from({ length }, (_, i) => i);
  return shuffleArray(indices);
};

/**
 * TestScreen shows a test with questions and handles user interactions
 *
 * @param {Object} props - Component props
 * @param {Object} props.route - Route object containing params
 * @param {Object} props.navigation - Navigation object
 * @returns {JSX.Element} - TestScreen component
 */
const TestScreen = ({ route, navigation }) => {
  const {
    testId,
    category,
    examMode: initialExamMode,
    review,
    resuming,
    restarting,
    selectedLength: initialSelectedLength
  } = route.params || {};

  const dispatch = useDispatch();
  const { userId, xp, level, coins, xpBoost, currentAvatar } = useSelector(state => state.user);
  const { items: shopItems = [], status: shopStatus } = useSelector(state => state.shop || { items: [], status: 'idle' });
  const { all: achievements = [] } = useSelector(state => state.achievements || { all: [] });

  // State for test data
  const [testData, setTestData] = useState(null);
  const [shuffleOrder, setShuffleOrder] = useState([]);
  const [answerOrder, setAnswerOrder] = useState([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [answers, setAnswers] = useState([]);
  const [score, setScore] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [examMode, setExamMode] = useState(initialExamMode || false);

  // UI state
  const [isAnswered, setIsAnswered] = useState(false);
  const [selectedOptionIndex, setSelectedOptionIndex] = useState(null);
  const [isFinished, setIsFinished] = useState(false);
  const [flaggedQuestions, setFlaggedQuestions] = useState([]);
  const [reviewFilter, setReviewFilter] = useState('all');

  // Modals
  const [showScoreModal, setShowScoreModal] = useState(false);
  const [showReviewMode, setShowReviewMode] = useState(review || false);
  const [showRestartModal, setShowRestartModal] = useState(false);
  const [showFinishModal, setShowFinishModal] = useState(false);
  const [showWarningModal, setShowWarningModal] = useState(false);
  const [showDropdown, setShowDropdown] = useState(false);

  // Animation
  const [showLevelUpAnimation, setShowLevelUpAnimation] = useState(false);
  const [localLevel, setLocalLevel] = useState(level);
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(50)).current;

  // Selected test length
  const [activeTestLength, setActiveTestLength] = useState(initialSelectedLength || 100);

  useEffect(() => {
    if (userId && shopStatus === 'idle') {
      dispatch(fetchShopItems());
    }
  }, [userId, shopStatus, dispatch]);

  useEffect(() => {
    if (userId && !achievements.length) {
      dispatch(fetchAchievements());
    }
  }, [userId, achievements.length, dispatch]);

  // Fetch test data and attempt
  const fetchTestAndAttempt = useCallback(async () => {
    try {
      setLoading(true);

      let attemptDoc = null;

      // If user is logged in, fetch attempt data
      if (userId) {
        // For restarting, we fetch a fresh attempt
        if (restarting) {
          console.log('Restarting test, using fresh attempt');
        }
        // For resuming or reviewing, fetch the existing attempt
        else if (resuming || review) {
          const status = review ? 'finished' : 'unfinished';
          try {
            const attemptData = await testService.fetchTestAttempt(userId, testId, status);
            if (attemptData?.attempt) {
              attemptDoc = attemptData.attempt;
            }
          } catch (err) {
            // If no attempt found, attemptDoc remains null
          }
        }
        // Otherwise check for any unfinished attempt first
        else {
          try {
            const unfinishedData = await testService.fetchTestAttempt(userId, testId, 'unfinished');
            if (unfinishedData?.attempt) {
              attemptDoc = unfinishedData.attempt;
            } else if (review) {
              const finishedData = await testService.fetchTestAttempt(userId, testId, 'finished');
              if (finishedData?.attempt) {
                attemptDoc = finishedData.attempt;
              }
            }
          } catch (err) {
            // If no attempt found, attemptDoc remains null
          }
        }
      }

      // Fetch the test data from the service
      const testDoc = await testService.fetchTestById(category, testId);
      setTestData(testDoc);
      const totalQ = testDoc.questions.length;

      // If we found an existing attemptDoc
      if (attemptDoc) {
        setAnswers(attemptDoc.answers || []);
        setScore(attemptDoc.score || 0);
        setIsFinished(attemptDoc.finished === true);

        // Use the exam mode from the attempt doc
        const attemptExam = attemptDoc.examMode === true;
        setExamMode(attemptExam);

        // Use the chosen length if available
        const chosenLength = attemptDoc.selectedLength || totalQ;
        setActiveTestLength(chosenLength);

        // Use saved shuffleOrder if valid
        if (
          attemptDoc.shuffleOrder &&
          Array.isArray(attemptDoc.shuffleOrder) &&
          attemptDoc.shuffleOrder.length === chosenLength
        ) {
          setShuffleOrder(attemptDoc.shuffleOrder);
        } else {
          // Create new shuffle order
          const newQOrder = shuffleIndices(chosenLength);
          setShuffleOrder(newQOrder);

          // Immediately save the new order if not in review mode
          if (userId && !review) {
            await testService.createOrUpdateAttempt(userId, testId, {
              category,
              answers: attemptDoc.answers || [],
              score: attemptDoc.score || 0,
              totalQuestions: totalQ,
              selectedLength: chosenLength,
              currentQuestionIndex: attemptDoc.currentQuestionIndex || 0,
              shuffleOrder: newQOrder,
              answerOrder: attemptDoc.answerOrder || [],
              finished: attemptDoc.finished === true,
              examMode: attemptExam
            });
          }
        }

        // Use saved answerOrder if valid
        if (
          attemptDoc.answerOrder &&
          Array.isArray(attemptDoc.answerOrder) &&
          attemptDoc.answerOrder.length === chosenLength
        ) {
          setAnswerOrder(attemptDoc.answerOrder);
        } else {
          // Create new answer order
          const generatedAnswerOrder = testDoc.questions
            .slice(0, chosenLength)
            .map((q) => {
              const numOptions = q.options.length;
              return shuffleArray([...Array(numOptions).keys()]);
            });
          setAnswerOrder(generatedAnswerOrder);

          // Save immediately
          if (userId && !review) {
            await testService.createOrUpdateAttempt(userId, testId, {
              category,
              answers: attemptDoc.answers || [],
              score: attemptDoc.score || 0,
              totalQuestions: totalQ,
              selectedLength: chosenLength,
              currentQuestionIndex: attemptDoc.currentQuestionIndex || 0,
              shuffleOrder: attemptDoc.shuffleOrder || [],
              answerOrder: generatedAnswerOrder,
              finished: attemptDoc.finished === true,
              examMode: attemptExam
            });
          }
        }

        setCurrentQuestionIndex(attemptDoc.currentQuestionIndex || 0);

        // If in review mode and the attempt is finished, show review
        if (review && attemptDoc.finished) {
          setShowReviewMode(true);
        }
      } else if (restarting) {
        // For a restart, create new shuffle and answer orders
        const selectedLength = initialSelectedLength || 100;
        setActiveTestLength(selectedLength);

        const newQOrder = shuffleIndices(selectedLength);
        setShuffleOrder(newQOrder);

        const newAnswerOrder = testDoc.questions
          .slice(0, selectedLength)
          .map((q) => {
            const numOptions = q.options.length;
            return shuffleArray([...Array(numOptions).keys()]);
          });
        setAnswerOrder(newAnswerOrder);

        // Save the new attempt
        if (userId) {
          await testService.createOrUpdateAttempt(userId, testId, {
            category,
            answers: [],
            score: 0,
            totalQuestions: totalQ,
            selectedLength,
            currentQuestionIndex: 0,
            shuffleOrder: newQOrder,
            answerOrder: newAnswerOrder,
            finished: false,
            examMode
          });
        }
      } else {
        // No attempt doc found, show error
        setError('No test attempt found. Please return to the test list and start a new test.');
      }
    } catch (err) {
      console.error('Error fetching test data:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [
    userId,
    testId,
    category,
    review,
    resuming,
    restarting,
    initialSelectedLength,
    initialExamMode,
    examMode
  ]);

  // Load data when screen comes into focus
  useFocusEffect(
    useCallback(() => {
      fetchTestAndAttempt();
    }, [fetchTestAndAttempt])
  );

  // Save progress when unmounting
  useEffect(() => {
    return () => {
      if (userId && testId && testData && !loading && !isFinished && !review) {
        const saveProgressOnExit = async () => {
          try {
            await testService.createOrUpdateAttempt(userId, testId, {
              category,
              answers,
              score,
              totalQuestions: testData?.questions?.length || 0,
              selectedLength: activeTestLength,
              currentQuestionIndex,
              shuffleOrder,
              answerOrder,
              finished: isFinished,
              examMode
            });
          } catch (err) {
            console.error("Failed to save progress on exit", err);
          }
        };

        saveProgressOnExit();
      }
    };
  }, [
    userId,
    testId,
    testData,
    loading,
    category,
    answers,
    score,
    activeTestLength,
    currentQuestionIndex,
    shuffleOrder,
    answerOrder,
    isFinished,
    examMode,
    review
  ]);

  // Watch for level up
  useEffect(() => {
    if (level > localLevel) {
      setLocalLevel(level);
      setShowLevelUpAnimation(true);

      // Animate the level up message
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 500,
          useNativeDriver: true,
        }),
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 500,
          useNativeDriver: true,
        })
      ]).start();

      // Hide the animation after 3 seconds
      const timer = setTimeout(() => {
        Animated.parallel([
          Animated.timing(fadeAnim, {
            toValue: 0,
            duration: 500,
            useNativeDriver: true,
          }),
          Animated.timing(slideAnim, {
            toValue: 50,
            duration: 500,
            useNativeDriver: true,
          })
        ]).start(() => setShowLevelUpAnimation(false));
      }, 3000);

      return () => clearTimeout(timer);
    }
  }, [level, localLevel, fadeAnim, slideAnim]);

  // Get the shuffled index for the current question
  const getShuffledIndex = useCallback(
    (i) => {
      if (!shuffleOrder || shuffleOrder.length === 0) return i;
      return shuffleOrder[i];
    },
    [shuffleOrder]
  );

  // Total number of questions in this test
  const effectiveTotal = activeTestLength || (testData ? testData.questions.length : 0);

  // Get the current question based on shuffled index
  const realIndex = getShuffledIndex(currentQuestionIndex);
  const questionObject = useMemo(() => {
    if (!testData || !testData.questions || !testData.questions.length) return null;
    return testData.questions[realIndex];
  }, [testData, realIndex]);

  // Check if the current question is answered
  useEffect(() => {
    if (!questionObject) return;

    const existing = answers.find(a => a.questionId === questionObject.id);
    if (existing) {
      setSelectedOptionIndex(null);

      if (existing.userAnswerIndex !== null && existing.userAnswerIndex !== undefined) {
        const displayIndex = answerOrder[realIndex].indexOf(existing.userAnswerIndex);
        if (displayIndex >= 0) {
          setSelectedOptionIndex(displayIndex);
          setIsAnswered(true);
        } else {
          setIsAnswered(false);
        }
      } else {
        setIsAnswered(false);
      }
    } else {
      setSelectedOptionIndex(null);
      setIsAnswered(false);
    }
  }, [questionObject, answers, realIndex, answerOrder]);

  // Update progress on server
  const updateServerProgress = useCallback(
    async (updatedAnswers, updatedScore, finished = false, singleAnswer = null) => {
      if (!userId) return;

      try {
        // If we're submitting a single answer
        if (singleAnswer) {
          // Replace direct fetch with testService.submitAnswer
          const data = await testService.submitAnswer(userId, {
            testId,
            questionId: singleAnswer.questionId,
            correctAnswerIndex: singleAnswer.correctAnswerIndex,
            selectedIndex: singleAnswer.userAnswerIndex,
            xpPerCorrect: (testData?.xpPerCorrect || 10) * xpBoost,
            coinsPerCorrect: 5
          });

          // In exam mode, also update the full attempt
          if (examMode) {
            await testService.createOrUpdateAttempt(userId, testId, {
              category,
              answers: updatedAnswers,
              score: updatedScore,
              totalQuestions: testData?.questions?.length || 0,
              selectedLength: activeTestLength,
              currentQuestionIndex,
              shuffleOrder,
              answerOrder,
              finished,
              examMode
            });
          }

          return data;
        }

        // Update current position (question index, etc.)
        await testService.updatePosition(userId, testId, {
          currentQuestionIndex,
          finished
        });

        // Then update the entire attempt
        await testService.createOrUpdateAttempt(userId, testId, {
          category,
          answers: updatedAnswers,
          score: updatedScore,
          totalQuestions: testData?.questions?.length || 0,
          selectedLength: activeTestLength,
          currentQuestionIndex,
          shuffleOrder,
          answerOrder,
          finished,
          examMode
        });
      } catch (err) {
        console.error("Failed to update test attempt on backend", err);
      }
    },
    [
      userId,
      testId,
      testData,
      xpBoost,
      currentQuestionIndex,
      category,
      activeTestLength,
      shuffleOrder,
      answerOrder,
      examMode
    ]
  );

  // Handle option selection
  const handleOptionClick = useCallback(
    async (displayOptionIndex) => {
      if (!questionObject) return;
      if (!examMode && isAnswered) return; // Block if already answered in non-exam mode

      const actualAnswerIndex = answerOrder[realIndex][displayOptionIndex];
      setSelectedOptionIndex(displayOptionIndex);

      // Mark as answered (in exam mode, user can change until finishing)
      setIsAnswered(true);

      try {
        const newAnswerObj = {
          questionId: questionObject.id,
          userAnswerIndex: actualAnswerIndex,
          correctAnswerIndex: questionObject.correctAnswerIndex
        };

        const updatedAnswers = [...answers];
        const idx = updatedAnswers.findIndex(a => a.questionId === questionObject.id);

        if (idx >= 0) {
          updatedAnswers[idx] = newAnswerObj;
        } else {
          updatedAnswers.push(newAnswerObj);
        }

        setAnswers(updatedAnswers);

        // Submit single answer
        const awardData = await updateServerProgress(
          updatedAnswers,
          score,
          false,
          newAnswerObj
        );

        // If not exam mode, update local score and XP
        if (!examMode && awardData && awardData.examMode === false) {
          if (awardData.isCorrect) {
            setScore(prev => prev + 1);
          }

          if (awardData.isCorrect && !awardData.alreadyCorrect && awardData.awardedXP) {
            dispatch({
              type: 'user/setXPAndCoins',
              payload: {
                xp: awardData.newXP,
                coins: awardData.newCoins
              }
            });
          }
        }
      } catch (err) {
        console.error("Failed to submit answer to backend", err);
      }
    },
    [
      isAnswered,
      questionObject,
      examMode,
      testData,
      xpBoost,
      userId,
      testId,
      dispatch,
      score,
      answers,
      updateServerProgress,
      realIndex,
      answerOrder
    ]
  );

  // Finish the test
  const finishTestProcess = useCallback(async () => {
    let finalScore = 0;

    // Calculate final score
    answers.forEach(ans => {
      if (ans.userAnswerIndex === ans.correctAnswerIndex) {
        finalScore++;
      }
    });

    setScore(finalScore);
    setIsFinished(true);

    try {
      // Replace direct fetch with testService.finishTestAttempt
      const finishData = await testService.finishTestAttempt(userId, testId, {
        score: finalScore,
        totalQuestions: effectiveTotal,
        testId,
        category
      });

      // Handle achievement unlocks
      if (finishData.newlyUnlocked && finishData.newlyUnlocked.length > 0) {
        console.log('New achievements unlocked:', finishData.newlyUnlocked);
      }

      // Update user XP and coins
      if (typeof finishData.newXP !== "undefined" && typeof finishData.newCoins !== "undefined") {
        dispatch({
          type: 'user/setXPAndCoins',
          payload: {
            xp: finishData.newXP,
            coins: finishData.newCoins,
            newlyUnlocked: finishData.newlyUnlocked || []
          }
        });
      }
    } catch (err) {
      console.error("Failed to finish test attempt:", err);
    }

    setShowScoreModal(true);
  }, [answers, userId, testId, effectiveTotal, dispatch, category]);

  // Navigation between questions
  const handleNextQuestion = useCallback(() => {
    if (!isAnswered && !examMode) {
      setShowWarningModal(true);
      return;
    }

    if (currentQuestionIndex === effectiveTotal - 1) {
      finishTestProcess();
      return;
    }

    const nextIndex = currentQuestionIndex + 1;
    setCurrentQuestionIndex(nextIndex);
    updateServerProgress(answers, score, false);
  }, [
    isAnswered,
    examMode,
    currentQuestionIndex,
    effectiveTotal,
    finishTestProcess,
    updateServerProgress,
    answers,
    score
  ]);

  const handlePreviousQuestion = useCallback(() => {
    if (currentQuestionIndex > 0) {
      const prevIndex = currentQuestionIndex - 1;
      setCurrentQuestionIndex(prevIndex);
      updateServerProgress(answers, score, false);
    }
  }, [currentQuestionIndex, updateServerProgress, answers, score]);

  // Skip the current question
  const handleSkipQuestion = () => {
    if (!questionObject) return;

    const updatedAnswers = [...answers];
    const idx = updatedAnswers.findIndex(a => a.questionId === questionObject.id);

    const skipObj = {
      questionId: questionObject.id,
      userAnswerIndex: null,
      correctAnswerIndex: questionObject.correctAnswerIndex
    };

    if (idx >= 0) {
      updatedAnswers[idx] = skipObj;
    } else {
      updatedAnswers.push(skipObj);
    }

    setAnswers(updatedAnswers);
    setIsAnswered(false);
    setSelectedOptionIndex(null);

    updateServerProgress(updatedAnswers, score, false, skipObj);

    if (currentQuestionIndex === effectiveTotal - 1) {
      finishTestProcess();
      return;
    }

    setCurrentQuestionIndex(currentQuestionIndex + 1);
  };

  // Flag the current question
  const handleFlagQuestion = () => {
    if (!questionObject) return;

    const qId = questionObject.id;
    if (flaggedQuestions.includes(qId)) {
      setFlaggedQuestions(flaggedQuestions.filter(x => x !== qId));
    } else {
      setFlaggedQuestions([...flaggedQuestions, qId]);
    }
  };

  // Restart the test
  const handleRestartTest = useCallback(async () => {
    setCurrentQuestionIndex(0);
    setSelectedOptionIndex(null);
    setIsAnswered(false);
    setScore(0);
    setAnswers([]);
    setFlaggedQuestions([]);
    setIsFinished(false);
    setShowReviewMode(false);
    setShowScoreModal(false);

    if (testData?.questions?.length && activeTestLength) {
      const newQOrder = shuffleIndices(activeTestLength);
      setShuffleOrder(newQOrder);

      const newAnswerOrder = testData.questions
        .slice(0, activeTestLength)
        .map(q => {
          const numOpts = q.options.length;
          return shuffleArray([...Array(numOpts).keys()]);
        });

      setAnswerOrder(newAnswerOrder);

      if (userId) {
        await testService.createOrUpdateAttempt(userId, testId, {
          answers: [],
          score: 0,
          totalQuestions: testData.questions.length,
          selectedLength: activeTestLength,
          category: testData.category || category,
          currentQuestionIndex: 0,
          shuffleOrder: newQOrder,
          answerOrder: newAnswerOrder,
          finished: false,
          examMode
        });
      }
    }
  }, [
    testData,
    userId,
    testId,
    category,
    examMode,
    activeTestLength
  ]);

  // Show review mode
  const handleReviewAnswers = () => {
    setShowReviewMode(true);
    setReviewFilter('all');
  };

  // Close review mode
  const handleCloseReview = () => {
    if (!isFinished) {
      setShowReviewMode(false);
    } else {
      // If the test is finished, navigate back to test list
      navigation.goBack();
    }
  };

  // Filter questions for review mode
  const filteredQuestions = useMemo(() => {
    if (!testData || !testData.questions) return [];

    return testData.questions.slice(0, effectiveTotal).filter(q => {
      const userAns = answers.find(a => a.questionId === q.id);
      const isFlagged = flaggedQuestions.includes(q.id);

      if (!userAns) {
        // Not answered => count it as "skipped" or "all"
        return reviewFilter === 'skipped' || reviewFilter === 'all';
      }

      const isSkipped = userAns.userAnswerIndex === null;
      const isCorrect = userAns.userAnswerIndex === q.correctAnswerIndex;

      if (reviewFilter === 'all') return true;
      if (reviewFilter === 'skipped' && isSkipped) return true;
      if (reviewFilter === 'flagged' && isFlagged) return true;
      if (reviewFilter === 'incorrect' && !isCorrect && !isSkipped) return true;
      if (reviewFilter === 'correct' && isCorrect && !isSkipped) return true;

      return false;
    });
  }, [testData, answers, flaggedQuestions, reviewFilter, effectiveTotal]);

  // Select a specific question from the dropdown
  const handleQuestionSelect = (index) => {
    setCurrentQuestionIndex(index);
    updateServerProgress(answers, score, false);
    setShowDropdown(false);
  };

  // Get the status of a question for the dropdown
  const getQuestionStatus = (index) => {
    const realIndex = shuffleOrder[index];
    if (!testData || !testData.questions || realIndex === undefined) return {};

    const question = testData.questions[realIndex];
    if (!question) return {};

    const answer = answers.find(a => a.questionId === question.id);
    const isFlagged = flaggedQuestions.includes(question.id);
    const isAnswered = answer?.userAnswerIndex !== undefined;
    const isSkipped = answer?.userAnswerIndex === null;
    const isCorrect = answer && answer.userAnswerIndex === question.correctAnswerIndex;

    return { isAnswered, isSkipped, isCorrect, isFlagged };
  };

  // Calculate progress percentage
  const progressPercentage = effectiveTotal
    ? Math.round(((currentQuestionIndex + 1) / effectiveTotal) * 100)
    : 0;

  // Get avatar URL
  const avatarUrl = useMemo(() => {
    let url = 'https://via.placeholder.com/60';
    if (currentAvatar && shopItems && shopItems.length > 0) {
      const avatarItem = shopItems.find(item => item._id === currentAvatar);
      if (avatarItem && avatarItem.imageUrl) {
        url = avatarItem.imageUrl;
      }
    }
    return url;
  }, [currentAvatar, shopItems]);

  // Get shuffled options for current question
  const displayedOptions = useMemo(() => {
    if (!questionObject || !answerOrder[realIndex]) return [];
    return answerOrder[realIndex].map(
      optionIdx => questionObject.options[optionIdx]
    );
  }, [questionObject, answerOrder, realIndex]);

  // Render level up animation
  const renderLevelUpAnimation = () => {
    if (!showLevelUpAnimation) return null;

    return (
      <Animated.View
        style={[
          styles.levelUpOverlay,
          {
            opacity: fadeAnim,
            transform: [{ translateY: slideAnim }]
          }
        ]}
      >
        <Text style={styles.levelUpText}>
          LEVEL UP! You are now Level {level}
        </Text>
      </Animated.View>
    );
  };

  // Render warning modal
  const renderWarningModal = () => {
    if (!showWarningModal) return null;

    return (
      <Modal
        visible={showWarningModal}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setShowWarningModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Ionicons name="warning" size={30} color="#FFC107" style={styles.modalIcon} />
            <Text style={styles.modalTitle}>No Answer Selected</Text>
            <Text style={styles.modalText}>
              You haven't answered this question yet. Please select an answer or skip the question.
            </Text>
            <TouchableOpacity
              style={styles.modalButton}
              onPress={() => setShowWarningModal(false)}
            >
              <Text style={styles.modalButtonText}>OK</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    );
  };

  // Render restart modal
  const renderRestartModal = () => {
    if (!showRestartModal) return null;

    return (
      <Modal
        visible={showRestartModal}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setShowRestartModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Ionicons name="warning" size={30} color="#FFC107" style={styles.modalIcon} />
            <Text style={styles.modalTitle}>Confirm Restart</Text>
            <Text style={styles.modalText}>
              Are you sure you want to restart the test? All progress will be lost and you'll start from the beginning.
            </Text>
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={[styles.modalButton, styles.confirmButton]}
                onPress={() => {
                  setShowRestartModal(false);
                  handleRestartTest();
                }}
              >
                <Text style={styles.modalButtonText}>Yes, Restart</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowRestartModal(false)}
              >
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    );
  };

  // Render finish modal
  const renderFinishModal = () => {
    if (!showFinishModal) return null;

    return (
      <Modal
        visible={showFinishModal}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setShowFinishModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Ionicons name="warning" size={30} color="#FFC107" style={styles.modalIcon} />
            <Text style={styles.modalTitle}>Confirm Finish</Text>
            <Text style={styles.modalText}>
              Are you sure you want to finish the test now? Any unanswered questions will be marked as skipped.
            </Text>
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={[styles.modalButton, styles.confirmButton]}
                onPress={() => {
                  setShowFinishModal(false);
                  finishTestProcess();
                }}
              >
                <Text style={styles.modalButtonText}>Yes, Finish</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowFinishModal(false)}
              >
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    );
  };

  // Render score modal
  const renderScoreModal = () => {
    if (!showScoreModal) return null;

    const percentage = effectiveTotal
      ? Math.round((score / effectiveTotal) * 100)
      : 0;

    // Determine grade based on percentage
    let grade = "";
    let gradeClass = "";

    if (percentage >= 90) {
      grade = "Outstanding!";
      gradeClass = "gradeAPlus";
    } else if (percentage >= 80) {
      grade = "Excellent!";
      gradeClass = "gradeA";
    } else if (percentage >= 70) {
      grade = "Great Job!";
      gradeClass = "gradeB";
    } else if (percentage >= 60) {
      grade = "Good Effort!";
      gradeClass = "gradeC";
    } else {
      grade = "Keep Practicing!";
      gradeClass = "gradeD";
    }

    return (
      <Modal
        visible={showScoreModal}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setShowScoreModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, styles.scoreModalContent]}>
            <Text style={styles.scoreTitle}>Test Complete!</Text>

            <View style={styles.scoreGradeContainer}>
              <View style={[styles.scoreGrade, styles[gradeClass]]}>
                <Text style={styles.percentageDisplay}>{percentage}%</Text>
                <Text style={styles.gradeLabel}>{grade}</Text>
              </View>

              <View style={styles.scoreDetailsContainer}>
                <Text style={styles.scoreDetails}>
                  You answered <Text style={styles.scoreHighlight}>{score}</Text> out of <Text style={styles.scoreHighlight}>{effectiveTotal}</Text> questions correctly.
                </Text>

                {examMode && (
                  <View style={styles.examModeNote}>
                    <Ionicons name="trophy" size={20} color="#FFD700" />
                    <Text style={styles.examModeText}>You completed this test in exam mode!</Text>
                  </View>
                )}
              </View>
            </View>

            <View style={styles.scoreButtons}>
              <TouchableOpacity
                style={[styles.scoreButton, styles.restartScoreButton]}
                onPress={() => setShowRestartModal(true)}
              >
                <Ionicons name="refresh" size={18} color="#FFFFFF" />
                <Text style={styles.scoreButtonText}>Restart Test</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.scoreButton, styles.reviewScoreButton]}
                onPress={handleReviewAnswers}
              >
                <Ionicons name="eye" size={18} color="#FFFFFF" />
                <Text style={styles.scoreButtonText}>Review Answers</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.scoreButton, styles.backScoreButton]}
                onPress={() => navigation.goBack()}
              >
                <Ionicons name="arrow-back" size={18} color="#FFFFFF" />
                <Text style={styles.scoreButtonText}>Back to List</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    );
  };

  // Render review mode
  const renderReviewMode = () => {
    if (!showReviewMode) return null;

    return (
      <Modal
        visible={showReviewMode}
        transparent={true}
        animationType="fade"
        onRequestClose={handleCloseReview}
      >
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, styles.reviewModalContent]}>
            <View style={styles.reviewHeader}>
              <TouchableOpacity
                style={styles.closeReviewButton}
                onPress={handleCloseReview}
              >
                <Ionicons name="close" size={24} color="#AAAAAA" />
              </TouchableOpacity>
              <Text style={styles.reviewTitle}>Review Mode</Text>

              {isFinished && (
                <Text style={styles.reviewScoreSummary}>
                  Your score: {score}/{effectiveTotal} ({effectiveTotal ? Math.round((score / effectiveTotal) * 100) : 0}%)
                </Text>
              )}
            </View>

            <View style={styles.reviewFilters}>
              <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={styles.reviewFiltersScroll}>
                <TouchableOpacity
                  style={[styles.filterButton, reviewFilter === 'all' && styles.activeFilter]}
                  onPress={() => setReviewFilter('all')}
                >
                  <Ionicons name="list" size={18} color={reviewFilter === 'all' ? "#FFFFFF" : "#AAAAAA"} />
                  <Text style={[styles.filterButtonText, reviewFilter === 'all' && styles.activeFilterText]}>All</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.filterButton, reviewFilter === 'skipped' && styles.activeFilter]}
                  onPress={() => setReviewFilter('skipped')}
                >
                  <Ionicons name="play-skip-forward" size={18} color={reviewFilter === 'skipped' ? "#FFFFFF" : "#AAAAAA"} />
                  <Text style={[styles.filterButtonText, reviewFilter === 'skipped' && styles.activeFilterText]}>Skipped</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.filterButton, reviewFilter === 'flagged' && styles.activeFilter]}
                  onPress={() => setReviewFilter('flagged')}
                >
                  <Ionicons name="flag" size={18} color={reviewFilter === 'flagged' ? "#FFFFFF" : "#AAAAAA"} />
                  <Text style={[styles.filterButtonText, reviewFilter === 'flagged' && styles.activeFilterText]}>Flagged</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.filterButton, reviewFilter === 'incorrect' && styles.activeFilter]}
                  onPress={() => setReviewFilter('incorrect')}
                >
                  <Ionicons name="close-circle" size={18} color={reviewFilter === 'incorrect' ? "#FFFFFF" : "#AAAAAA"} />
                  <Text style={[styles.filterButtonText, reviewFilter === 'incorrect' && styles.activeFilterText]}>Incorrect</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.filterButton, reviewFilter === 'correct' && styles.activeFilter]}
                  onPress={() => setReviewFilter('correct')}
                >
                  <Ionicons name="checkmark-circle" size={18} color={reviewFilter === 'correct' ? "#FFFFFF" : "#AAAAAA"} />
                  <Text style={[styles.filterButtonText, reviewFilter === 'correct' && styles.activeFilterText]}>Correct</Text>
                </TouchableOpacity>
              </ScrollView>

              <Text style={styles.filterCount}>
                Showing {filteredQuestions.length} questions
              </Text>
            </View>

            <FlatList
              data={filteredQuestions}
              keyExtractor={item => item.id}
              renderItem={({ item, index }) => {
                const userAns = answers.find(a => a.questionId === item.id);
                const isFlagged = flaggedQuestions.includes(item.id);

                // Determine answer status
                let answerStatus = { type: 'unanswered', label: 'Not Answered', color: '#FFC107', icon: 'alert' };

                if (userAns) {
                  const isSkipped = userAns.userAnswerIndex === null;
                  const isCorrect = userAns.userAnswerIndex === item.correctAnswerIndex;

                  if (isSkipped) {
                    answerStatus = { type: 'skipped', label: 'Skipped', color: '#FF9800', icon: 'play-skip-forward' };
                  } else if (isCorrect) {
                    answerStatus = { type: 'correct', label: 'Correct!', color: '#2EBB77', icon: 'checkmark-circle' };
                  } else {
                    answerStatus = { type: 'incorrect', label: 'Incorrect', color: '#FF4E4E', icon: 'close-circle' };
                  }
                }

                return (
                  <View style={[styles.reviewQuestionCard, styles[`${answerStatus.type}Card`]]}>
                    <View style={styles.reviewQuestionHeader}>
                      <Text style={styles.reviewQuestionNumber}>Question {index + 1}</Text>
                      {isFlagged && (
                        <Ionicons name="flag" size={18} color="#FFC107" style={styles.flaggedIcon} />
                      )}
                    </View>

                    <View style={styles.reviewQuestionContent}>
                      <FormattedQuestion questionText={item.question} />
                    </View>

                    <View style={[styles.answerSection, styles[`${answerStatus.type}Section`]]}>
                      <View style={styles.answerStatusRow}>
                        <Ionicons name={answerStatus.icon} size={20} color={answerStatus.color} />
                        <Text style={[styles.answerStatusText, { color: answerStatus.color }]}>
                          {answerStatus.label}
                        </Text>
                      </View>

                      {userAns && userAns.userAnswerIndex !== null && (
                        <Text style={styles.yourAnswerText}>
                          <Text style={styles.answerLabel}>Your Answer: </Text>
                          {item.options[userAns.userAnswerIndex]}
                        </Text>
                      )}

                      <Text style={styles.correctAnswerText}>
                        <Text style={styles.answerLabel}>Correct Answer: </Text>
                        {item.options[item.correctAnswerIndex]}
                      </Text>
                    </View>

                    <View style={styles.explanationSection}>
                      <Text style={styles.explanationText}>{item.explanation}</Text>
                    </View>
                  </View>
                );
              }}
              contentContainerStyle={styles.reviewList}
            />

            {!isFinished && (
              <TouchableOpacity
                style={styles.closeReviewButtonBottom}
                onPress={handleCloseReview}
              >
                <Text style={styles.closeReviewButtonText}>Return to Test</Text>
              </TouchableOpacity>
            )}
          </View>
        </View>
      </Modal>
    );
  };

  // Render dropdown for question selection
  const renderQuestionDropdown = () => {
    if (!showDropdown) return null;

    return (
      <Modal
        visible={showDropdown}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setShowDropdown(false)}
      >
        <TouchableOpacity
          style={styles.dropdownOverlay}
          activeOpacity={1}
          onPress={() => setShowDropdown(false)}
        >
          <View style={styles.dropdownContent}>
            <FlatList
              data={Array.from({ length: effectiveTotal }, (_, i) => i)}
              keyExtractor={item => item.toString()}
              renderItem={({ item: index }) => {
                const status = getQuestionStatus(index);

                return (
                  <TouchableOpacity
                    style={[
                      styles.dropdownItem,
                      index === currentQuestionIndex && styles.activeDropdownItem
                    ]}
                    onPress={() => handleQuestionSelect(index)}
                  >
                    <Text style={styles.dropdownItemText}>
                      Question {index + 1}
                    </Text>
                    <View style={styles.dropdownItemStatus}>
                      {status.isSkipped && (
                        <Ionicons name="play-skip-forward" size={18} color="#FF9800" />
                      )}
                      {status.isFlagged && (
                        <Ionicons name="flag" size={18} color="#FFC107" />
                      )}
                      {!examMode && status.isAnswered && !status.isSkipped && (
                        <Ionicons
                          name={status.isCorrect ? "checkmark-circle" : "close-circle"}
                          size={18}
                          color={status.isCorrect ? "#2EBB77" : "#FF4E4E"}
                        />
                      )}
                    </View>
                  </TouchableOpacity>
                );
              }}
              style={styles.dropdownList}
            />
            <TouchableOpacity
              style={styles.closeDropdownButton}
              onPress={() => setShowDropdown(false)}
            >
              <Text style={styles.closeDropdownText}>Close</Text>
            </TouchableOpacity>
          </View>
        </TouchableOpacity>
      </Modal>
    );
  };

  // Show loading spinner while data is loading
  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6543CC" />
        <Text style={styles.loadingText}>Loading test data...</Text>
      </View>
    );
  }

  // Show error screen if there's an error
  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Ionicons name="alert-circle" size={50} color="#FF4E4E" />
        <Text style={styles.errorTitle}>Error Loading Test</Text>
        <Text style={styles.errorMessage}>{error}</Text>
        <View style={styles.errorButtons}>
          <TouchableOpacity
            style={styles.errorButton}
            onPress={() => fetchTestAndAttempt()}
          >
            <Text style={styles.errorButtonText}>Try Again</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.errorButton, styles.errorBackButton]}
            onPress={() => navigation.goBack()}
          >
            <Text style={styles.errorButtonTextBack}>Back to Tests</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  // Show error if test data or questions are missing
  if (!testData || !testData.questions || testData.questions.length === 0) {
    return (
      <View style={styles.errorContainer}>
        <Ionicons name="alert-circle" size={50} color="#FF4E4E" />
        <Text style={styles.errorTitle}>No Questions Found</Text>
        <Text style={styles.errorMessage}>This test doesn't have any questions yet.</Text>
        <TouchableOpacity
          style={styles.errorButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.errorButtonText}>Back to Tests</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* Level up animation */}
      {renderLevelUpAnimation()}

      {/* Modals */}
      {renderWarningModal()}
      {renderRestartModal()}
      {renderFinishModal()}
      {renderScoreModal()}
      {renderReviewMode()}
      {renderQuestionDropdown()}

      {/* Upper controls */}
      <View style={styles.topBar}>
        <View style={styles.userInfoSection}>
          <View style={[styles.avatarImage, { backgroundImage: `url(${avatarUrl})` }]} />
          <View style={styles.userStats}>
            <View style={styles.levelBadge}>
              <Ionicons name="trophy" size={12} color="#FFFFFF" />
              <Text style={styles.levelText}>{level}</Text>
            </View>
            <View style={styles.statsRow}>
              <View style={styles.xpDisplay}>
                <Ionicons name="star" size={12} color="#FFD700" />
                <Text style={styles.xpText}>{xp} XP</Text>
              </View>
              <View style={styles.coinsDisplay}>
                <Ionicons name="cash" size={12} color="#2EBB77" />
                <Text style={styles.coinsText}>{coins}</Text>
              </View>
            </View>
          </View>
        </View>

        <View style={styles.testControls}>
          <TouchableOpacity
            style={styles.restartTestButton}
            onPress={() => setShowRestartModal(true)}
          >
            <Ionicons name="refresh" size={18} color="#FFFFFF" />
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={18} color="#FFFFFF" />
          </TouchableOpacity>
        </View>
      </View>

      {/* Title bar */}
      <View style={styles.titleBar}>
        <Text style={styles.testTitle}>{testData.testName}</Text>
        {examMode && (
          <View style={styles.examModeBadge}>
            <Ionicons name="trophy" size={14} color="#FFFFFF" />
            <Text style={styles.examModeText}>EXAM MODE</Text>
          </View>
        )}
      </View>

      {/* Question controls */}
      <View style={styles.questionControlBar}>
        <TouchableOpacity
          style={[
            styles.flagButton,
            questionObject && flaggedQuestions.includes(questionObject.id) && styles.flaggedButton
          ]}
          onPress={handleFlagQuestion}
        >
          <Ionicons
            name="flag"
            size={18}
            color={
              questionObject && flaggedQuestions.includes(questionObject.id)
                ? "#FFC107"
                : "#AAAAAA"
            }
          />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.questionDropdownButton}
          onPress={() => setShowDropdown(true)}
        >
          <Text style={styles.questionDropdownText}>
            Question {currentQuestionIndex + 1} of {effectiveTotal}
          </Text>
          <Ionicons name="chevron-down" size={18} color="#FFFFFF" />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.finishButton}
          onPress={() => setShowFinishModal(true)}
        >
          <Ionicons name="flag-checkered" size={18} color="#FFFFFF" />
        </TouchableOpacity>
      </View>

      {/* Progress bar */}
      <View style={styles.progressBarContainer}>
        <View
          style={[
            styles.progressBar,
            {
              width: `${progressPercentage}%`,
              backgroundColor: `hsl(${(progressPercentage * 120) / 100}, 100%, 50%)`
            }
          ]}
        />
      </View>

      {/* Question content */}
      <ScrollView style={styles.questionScrollView} contentContainerStyle={styles.questionContainer}>
        <View style={styles.questionCard}>
          {/* Question text */}
          <View style={styles.questionTextContainer}>
            {questionObject && (
              <FormattedQuestion questionText={questionObject.question} />
            )}
          </View>

          {/* Answer options */}
          <View style={styles.optionsContainer}>
            {displayedOptions.map((option, displayIdx) => {
              let optionStyle = [styles.optionButton];
              let textStyle = [styles.optionText];

              // Add styles based on answer status
              if (!examMode) {
                if (isAnswered && questionObject) {
                  const correctIndex = questionObject.correctAnswerIndex;
                  const actualIndex = answerOrder[realIndex][displayIdx];

                  if (actualIndex === correctIndex) {
                    optionStyle.push(styles.correctOption);
                    textStyle.push(styles.correctOptionText);
                  } else if (
                    displayIdx === selectedOptionIndex &&
                    actualIndex !== correctIndex
                  ) {
                    optionStyle.push(styles.incorrectOption);
                    textStyle.push(styles.incorrectOptionText);
                  }
                }
              } else {
                // In exam mode, just highlight the selected option
                if (isAnswered && displayIdx === selectedOptionIndex) {
                  optionStyle.push(styles.chosenOption);
                  textStyle.push(styles.chosenOptionText);
                }
              }

              return (
                <TouchableOpacity
                  key={displayIdx}
                  style={optionStyle}
                  onPress={() => handleOptionClick(displayIdx)}
                  disabled={examMode ? false : isAnswered}
                >
                  <View style={styles.optionLetter}>
                    <Text style={styles.optionLetterText}>
                      {String.fromCharCode(65 + displayIdx)}
                    </Text>
                  </View>
                  <Text style={textStyle}>{option}</Text>
                </TouchableOpacity>
              );
            })}
          </View>

          {/* Explanation (shown after answering in non-exam mode) */}
          {isAnswered && questionObject && !examMode && (
            <>
              <View style={[
                styles.explanation,
                selectedOptionIndex !== null &&
                answerOrder[realIndex][selectedOptionIndex] === questionObject.correctAnswerIndex
                  ? styles.correctExplanation
                  : styles.incorrectExplanation
              ]}>
                <View style={styles.explanationHeader}>
                  <Ionicons
                    name={
                      selectedOptionIndex !== null &&
                      answerOrder[realIndex][selectedOptionIndex] === questionObject.correctAnswerIndex
                        ? "checkmark-circle"
                        : "close-circle"
                    }
                    size={20}
                    color={
                      selectedOptionIndex !== null &&
                      answerOrder[realIndex][selectedOptionIndex] === questionObject.correctAnswerIndex
                        ? "#2EBB77"
                        : "#FF4E4E"
                    }
                  />
                  <Text style={[
                    styles.explanationHeaderText,
                    {
                      color:
                        selectedOptionIndex !== null &&
                        answerOrder[realIndex][selectedOptionIndex] === questionObject.correctAnswerIndex
                          ? "#2EBB77"
                          : "#FF4E4E"
                    }
                  ]}>
                    {selectedOptionIndex !== null &&
                      answerOrder[realIndex][selectedOptionIndex] === questionObject.correctAnswerIndex
                      ? "Correct!"
                      : "Incorrect!"
                    }
                  </Text>
                </View>
                <Text style={styles.explanationText}>{questionObject.explanation}</Text>
              </View>

              {/* Exam tip if available */}
              {questionObject.examTip && (
                <View style={styles.examTip}>
                  <View style={styles.examTipHeader}>
                    <Ionicons name="flash" size={20} color="#FFC107" />
                    <Text style={styles.examTipHeaderText}>Exam Tip</Text>
                  </View>
                  <Text style={styles.examTipText}>{questionObject.examTip}</Text>
                </View>
              )}
            </>
          )}
        </View>
      </ScrollView>

      {/* Navigation buttons */}
      <View style={styles.navigationContainer}>
        <View style={styles.navigationRow}>
          <TouchableOpacity
            style={[styles.navButton, styles.prevButton, currentQuestionIndex === 0 && styles.disabledButton]}
            onPress={handlePreviousQuestion}
            disabled={currentQuestionIndex === 0}
          >
            <Ionicons name="chevron-back" size={20} color="#FFFFFF" />
            <Text style={styles.navButtonText}>Previous</Text>
          </TouchableOpacity>

          {currentQuestionIndex === effectiveTotal - 1 ? (
            <TouchableOpacity
              style={[styles.navButton, styles.finishNavButton]}
              onPress={handleNextQuestion}
            >
              <Ionicons name="flag-checkered" size={20} color="#FFFFFF" />
              <Text style={styles.navButtonText}>Finish Test</Text>
            </TouchableOpacity>
          ) : (
            <TouchableOpacity
              style={[styles.navButton, styles.nextButton]}
              onPress={handleNextQuestion}
            >
              <Text style={styles.navButtonText}>Next</Text>
              <Ionicons name="chevron-forward" size={20} color="#FFFFFF" />
            </TouchableOpacity>
          )}
        </View>

        <TouchableOpacity
          style={styles.skipButton}
          onPress={handleSkipQuestion}
        >
          <Ionicons name="play-skip-forward" size={18} color="#FFFFFF" />
          <Text style={styles.skipButtonText}>Skip Question</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};




const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  // Top bar with user info
  topBar: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#1E1E1E',
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#2A2A2A',
  },
  userInfoSection: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatarImage: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#2A2A2A',
    borderWidth: 2,
    borderColor: '#6543CC',
  },
  userStats: {
    marginLeft: 10,
  },
  levelBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#6543CC',
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
    marginBottom: 4,
  },
  levelText: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: 'bold',
    marginLeft: 4,
  },
  statsRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  xpDisplay: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 8,
    marginRight: 6,
  },
  xpText: {
    color: '#FFD700',
    fontSize: 12,
    marginLeft: 4,
  },
  coinsDisplay: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 8,
  },
  coinsText: {
    color: '#2EBB77',
    fontSize: 12,
    marginLeft: 4,
  },
  testControls: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  restartTestButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    padding: 8,
    borderRadius: 8,
    marginRight: 8,
  },
  backButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    padding: 8,
    borderRadius: 8,
  },
  // Title bar
  titleBar: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 15,
  },
  testTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#6543CC',
    flex: 1,
  },
  examModeBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#6543CC',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  examModeText: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: 'bold',
    marginLeft: 5,
  },
  // Question controls
  questionControlBar: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#1E1E1E',
    paddingHorizontal: 15,
    paddingVertical: 10,
    borderRadius: 8,
    margin: 15,
    marginTop: 0,
  },
  flagButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    padding: 8,
    borderRadius: 8,
  },
  flaggedButton: {
    backgroundColor: 'rgba(255, 193, 7, 0.2)',
  },
  questionDropdownButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#6543CC',
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 8,
  },
  questionDropdownText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: 'bold',
    marginRight: 8,
  },
  finishButton: {
    backgroundColor: '#FF4E4E',
    padding: 8,
    borderRadius: 8,
  },
  // Progress bar
  progressBarContainer: {
    height: 6,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 3,
    overflow: 'hidden',
    marginHorizontal: 15,
    marginBottom: 15,
  },
  progressBar: {
    height: '100%',
    backgroundColor: '#6543CC',
  },
  // Question content
  questionScrollView: {
    flex: 1,
  },
  questionContainer: {
    paddingHorizontal: 15,
    paddingBottom: 20,
  },
  questionCard: {
    backgroundColor: '#1E1E1E',
    borderRadius: 12,
    padding: 20,
    marginBottom: 15,
    borderWidth: 1,
    borderColor: '#2A2A2A',
  },
  questionTextContainer: {
    marginBottom: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#2A2A2A',
    paddingBottom: 15,
  },
  // Options
  optionsContainer: {
    marginBottom: 20,
  },
  optionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderWidth: 1,
    borderColor: '#2A2A2A',
    borderRadius: 8,
    marginBottom: 10,
    overflow: 'hidden',
  },
  optionLetter: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    width: 36,
    height: '100%',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 15,
  },
  optionLetterText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  optionText: {
    flex: 1,
    color: '#E2E2E2',
    fontSize: 16,
    paddingHorizontal: 15,
    paddingVertical: 15,
  },
  correctOption: {
    backgroundColor: 'rgba(46, 187, 119, 0.15)',
    borderColor: '#2EBB77',
  },
  incorrectOption: {
    backgroundColor: 'rgba(255, 78, 78, 0.15)',
    borderColor: '#FF4E4E',
  },
  chosenOption: {
    backgroundColor: 'rgba(101, 67, 204, 0.15)',
    borderColor: '#6543CC',
  },
  correctOptionText: {
    color: '#2EBB77',
    fontWeight: 'bold',
  },
  incorrectOptionText: {
    color: '#FF4E4E',
  },
  chosenOptionText: {
    color: '#6543CC',
    fontWeight: 'bold',
  },
  // Explanation
  explanation: {
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderWidth: 1,
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
  },
  correctExplanation: {
    borderColor: '#2EBB77',
    borderLeftWidth: 4,
  },
  incorrectExplanation: {
    borderColor: '#FF4E4E',
    borderLeftWidth: 4,
  },
  explanationHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
  },
  explanationHeaderText: {
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  explanationText: {
    color: '#E2E2E2',
    fontSize: 15,
    lineHeight: 22,
  },
  // Exam tip
  examTip: {
    backgroundColor: 'rgba(255, 193, 7, 0.1)',
    borderWidth: 1,
    borderColor: '#2A2A2A',
    borderLeftWidth: 4,
    borderLeftColor: '#FFC107',
    borderRadius: 8,
    padding: 15,
  },
  examTipHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
  },
  examTipHeaderText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFC107',
    marginLeft: 8,
  },
  examTipText: {
    color: '#E2E2E2',
    fontSize: 15,
    lineHeight: 22,
    fontStyle: 'italic',
  },
  // Navigation buttons
  navigationContainer: {
    padding: 15,
    backgroundColor: '#1E1E1E',
    borderTopWidth: 1,
    borderTopColor: '#2A2A2A',
  },
  navigationRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 10,
  },
  navButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 8,
    flex: 1,
  },
  prevButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    marginRight: 8,
  },
  nextButton: {
    backgroundColor: '#6543CC',
    marginLeft: 8,
  },
  finishNavButton: {
    backgroundColor: '#FF4E4E',
    marginLeft: 8,
  },
  disabledButton: {
    opacity: 0.5,
  },
  navButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginHorizontal: 8,
  },
  skipButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    padding: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#2A2A2A',
  },
  skipButtonText: {
    color: '#AAAAAA',
    fontSize: 14,
    marginLeft: 8,
  },
  // Level up animation
  levelUpOverlay: {
    position: 'absolute',
    top: 100,
    alignSelf: 'center',
    backgroundColor: 'rgba(101, 67, 204, 0.9)',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 25,
    zIndex: 1000,
  },
  levelUpText: {
    color: '#FFFFFF',
    fontSize: 18,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  // Modals
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: '#1E1E1E',
    borderRadius: 12,
    width: '85%',
    padding: 20,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#2A2A2A',
  },
  modalIcon: {
    marginBottom: 10,
  },
  modalTitle: {
    color: '#FFFFFF',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
  },
  modalText: {
    color: '#CCCCCC',
    fontSize: 15,
    textAlign: 'center',
    marginBottom: 20,
    lineHeight: 22,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'center',
    width: '100%',
  },
  modalButton: {
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
    minWidth: 120,
    alignItems: 'center',
    marginHorizontal: 5,
  },
  confirmButton: {
    backgroundColor: '#6543CC',
  },
  cancelButton: {
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: '#2A2A2A',
  },
  modalButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  cancelButtonText: {
    color: '#AAAAAA',
    fontSize: 16,
    fontWeight: 'bold',
  },
  // Score modal
  scoreModalContent: {
    width: '90%',
    maxWidth: 500,
  },
  scoreTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#6543CC',
    marginBottom: 20,
    textAlign: 'center',
  },
  scoreGradeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 30,
    width: '100%',
  },
  scoreGrade: {
    width: 100,
    height: 100,
    borderRadius: 50,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 20,
  },
  gradeAPlus: {
    backgroundColor: 'rgba(46, 187, 119, 0.2)',
    borderWidth: 3,
    borderColor: '#2EBB77',
  },
  gradeA: {
    backgroundColor: 'rgba(46, 187, 119, 0.2)',
    borderWidth: 3,
    borderColor: '#2EBB77',
  },
  gradeB: {
    backgroundColor: 'rgba(52, 152, 219, 0.2)',
    borderWidth: 3,
    borderColor: '#3498DB',
  },
  gradeC: {
    backgroundColor: 'rgba(255, 193, 7, 0.2)',
    borderWidth: 3,
    borderColor: '#FFC107',
  },
  gradeD: {
    backgroundColor: 'rgba(255, 78, 78, 0.2)',
    borderWidth: 3,
    borderColor: '#FF4E4E',
  },
  percentageDisplay: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  gradeLabel: {
    fontSize: 12,
    color: '#FFFFFF',
    marginTop: 5,
  },
  scoreDetailsContainer: {
    flex: 1,
  },
  scoreDetails: {
    fontSize: 16,
    color: '#CCCCCC',
    marginBottom: 10,
    lineHeight: 24,
  },
  scoreHighlight: {
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  examModeNote: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 215, 0, 0.1)',
    padding: 10,
    borderRadius: 8,
    marginTop: 10,
  },
  examModeText: {
    color: '#FFD700',
    fontSize: 14,
    marginLeft: 8,
  },
  scoreButtons: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    width: '100%',
  },
  scoreButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    paddingHorizontal: 15,
    borderRadius: 8,
    margin: 5,
    minWidth: '30%',
    flex: 1,
  },
  restartScoreButton: {
    backgroundColor: '#6543CC',
  },
  reviewScoreButton: {
    backgroundColor: '#2EBB77',
  },
  backScoreButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderWidth: 1,
    borderColor: '#2A2A2A',
  },
  scoreButtonText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  // Review modal
  reviewModalContent: {
    width: '95%',
    height: '90%',
    padding: 0,
  },
  reviewHeader: {
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#2A2A2A',
    width: '100%',
    alignItems: 'center',
  },
  closeReviewButton: {
    position: 'absolute',
    top: 15,
    right: 15,
    zIndex: 10,
  },
  reviewTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 5,
  },
  reviewScoreSummary: {
    fontSize: 14,
    color: '#AAAAAA',
  },
  reviewFilters: {
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#2A2A2A',
    width: '100%',
  },
  reviewFiltersScroll: {
    paddingBottom: 5,
  },
  filterButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
    marginRight: 8,
  },
  activeFilter: {
    backgroundColor: '#6543CC',
  },
  filterButtonText: {
    color: '#AAAAAA',
    fontSize: 14,
    marginLeft: 6,
  },
  activeFilterText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  filterCount: {
    color: '#AAAAAA',
    fontSize: 12,
    marginTop: 10,
  },
  reviewList: {
    padding: 15,
  },
  reviewQuestionCard: {
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderWidth: 1,
    borderColor: '#2A2A2A',
    borderRadius: 12,
    padding: 15,
    marginBottom: 15,
  },
  unansweredCard: {
    borderLeftWidth: 4,
    borderLeftColor: '#FFC107',
  },
  skippedCard: {
    borderLeftWidth: 4,
    borderLeftColor: '#FF9800',
  },
  correctCard: {
    borderLeftWidth: 4,
    borderLeftColor: '#2EBB77',
  },
  incorrectCard: {
    borderLeftWidth: 4,
    borderLeftColor: '#FF4E4E',
  },
  reviewQuestionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  reviewQuestionNumber: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  flaggedIcon: {
    marginLeft: 8,
  },
  reviewQuestionContent: {
    marginBottom: 15,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#2A2A2A',
  },
  answerSection: {
    marginBottom: 15,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#2A2A2A',
  },
  unansweredSection: {
    backgroundColor: 'rgba(255, 193, 7, 0.05)',
    padding: 10,
    borderRadius: 8,
  },
  skippedSection: {
    backgroundColor: 'rgba(255, 152, 0, 0.05)',
    padding: 10,
    borderRadius: 8,
  },
  correctSection: {
    backgroundColor: 'rgba(46, 187, 119, 0.05)',
    padding: 10,
    borderRadius: 8,
  },
  incorrectSection: {
    backgroundColor: 'rgba(255, 78, 78, 0.05)',
    padding: 10,
    borderRadius: 8,
  },
  answerStatusRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
  },
  answerStatusText: {
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  yourAnswerText: {
    color: '#E2E2E2',
    fontSize: 15,
    marginBottom: 8,
  },
  correctAnswerText: {
    color: '#E2E2E2',
    fontSize: 15,
  },
  answerLabel: {
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  explanationSection: {
    backgroundColor: 'rgba(0, 0, 0, 0.1)',
    padding: 10,
    borderRadius: 8,
  },
  closeReviewButtonBottom: {
    backgroundColor: '#6543CC',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    alignSelf: 'center',
    marginVertical: 15,
  },
  closeReviewButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  // Question dropdown
  dropdownOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  dropdownContent: {
    backgroundColor: '#1E1E1E',
    borderRadius: 12,
    width: '80%',
    maxHeight: '70%',
    borderWidth: 1,
    borderColor: '#2A2A2A',
    overflow: 'hidden',
  },
  dropdownList: {
    maxHeight: '90%',
  },
  dropdownItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#2A2A2A',
  },
  activeDropdownItem: {
    backgroundColor: 'rgba(101, 67, 204, 0.2)',
  },
  dropdownItemText: {
    color: '#FFFFFF',
    fontSize: 16,
  },
  dropdownItemStatus: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  closeDropdownButton: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    backgroundColor: '#6543CC',
  },
  closeDropdownText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  // Loading & Error states
  loadingContainer: {
    flex: 1,
    backgroundColor: '#121212',
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    color: '#FFFFFF',
    marginTop: 10,
    fontSize: 16,
  },
  errorContainer: {
    flex: 1,
    backgroundColor: '#121212',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorTitle: {
    color: '#FFFFFF',
    fontSize: 20,
    fontWeight: 'bold',
    marginTop: 15,
  },
  errorMessage: {
    color: '#AAAAAA',
    textAlign: 'center',
    marginTop: 10,
    marginBottom: 20,
  },
  errorButtons: {
    flexDirection: 'row',
  },
  errorButton: {
    backgroundColor: '#6543CC',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
    marginHorizontal: 5,
  },
  errorBackButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderWidth: 1,
    borderColor: '#2A2A2A',
  },
  errorButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  errorButtonTextBack: {
    color: '#AAAAAA',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

export default TestScreen;
</file>

<file path="src/screens/tools/AnalogyHubScreen.js">
// src/screens/tools/AnalogyHubScreen.js
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  Keyboard,
  Platform,
  SafeAreaView,
  Dimensions
} from 'react-native';
import { Picker } from '@react-native-picker/picker';
import { Ionicons } from '@expo/vector-icons';
import { StatusBar } from 'expo-status-bar';
import * as Clipboard from 'expo-clipboard';
import { streamAnalogy } from '../../api/analogyService';
import { useToast } from 'react-native-toast-notifications';

const AnalogyHubScreen = () => {
  const [analogyType, setAnalogyType] = useState('single');
  const [inputValues, setInputValues] = useState(['']);
  const [analogyCategory, setAnalogyCategory] = useState('real-world');
  const [isStreaming, setIsStreaming] = useState(false);
  const [generatedAnalogy, setGeneratedAnalogy] = useState('');
  
  const toast = useToast();
  const scrollViewRef = useRef();

  // Update input fields based on analogy type
  useEffect(() => {
    switch (analogyType) {
      case 'comparison':
        setInputValues(['', '']);
        break;
      case 'triple':
        setInputValues(['', '', '']);
        break;
      default:
        setInputValues(['']);
    }
  }, [analogyType]);

  const handleInputChange = (index, value) => {
    const newValues = [...inputValues];
    newValues[index] = value;
    setInputValues(newValues);
  };

  const handleGenerateAnalogy = async () => {
    Keyboard.dismiss();
    setIsStreaming(true);
    setGeneratedAnalogy('');

    try {
      const data = {
        analogy_type: analogyType,
        category: analogyCategory,
        concept1: inputValues[0] || '',
        concept2: inputValues[1] || '',
        concept3: inputValues[2] || ''
      };
      
      // Use the service to stream the analogy
      const textChunks = await streamAnalogy(
        analogyType,
        inputValues[0],
        inputValues[1] || '',
        inputValues[2] || '',
        analogyCategory
      );
      
      let accumulatedText = '';
      
      // Simulate streaming by updating the text in chunks
      for (const chunk of textChunks.split('\n')) {
        accumulatedText += chunk + '\n';
        setGeneratedAnalogy(accumulatedText);
        
        // Scroll to bottom as text comes in
        if (scrollViewRef.current) {
          scrollViewRef.current.scrollToEnd({ animated: true });
        }
        
        // Add a small delay to simulate streaming
        await new Promise(resolve => setTimeout(resolve, 50));
      }
    } catch (error) {
      console.error('Error generating analogy:', error);
      toast.show('An error occurred while generating the analogy', {
        type: 'danger',
        duration: 3000,
      });
    } finally {
      setIsStreaming(false);
    }
  };

  const copyToClipboard = async () => {
    if (generatedAnalogy) {
      await Clipboard.setStringAsync(generatedAnalogy);
      toast.show('Copied to clipboard!', {
        type: 'success',
        duration: 2000,
      });
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar style="light" />
      
      <View style={styles.headerContainer}>
        <Text style={styles.title}>Analogy Hub</Text>
        <Text style={styles.subtitle}>runtime-error.r00</Text>
      </View>
      
      <ScrollView 
        style={styles.scrollView}
        contentContainerStyle={styles.scrollViewContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.formContainer}>
          {/* Analogy Type Picker */}
          <View style={styles.pickerContainer}>
            <Text style={styles.label}>Analogy Type</Text>
            <View style={styles.pickerWrapper}>
              <Picker
                selectedValue={analogyType}
                onValueChange={(value) => setAnalogyType(value)}
                style={styles.picker}
                dropdownIconColor="#00ffea"
                itemStyle={styles.pickerItem}
                enabled={!isStreaming}
              >
                <Picker.Item label="Single" value="single" />
                <Picker.Item label="Comparison" value="comparison" />
                <Picker.Item label="Triple Comparison" value="triple" />
              </Picker>
            </View>
          </View>
          
          {/* Input Fields */}
          <View style={styles.inputFields}>
            {inputValues.map((value, index) => (
              <TextInput
                key={index}
                style={styles.input}
                placeholder={`Enter concept ${index + 1}`}
                placeholderTextColor="#666"
                value={value}
                onChangeText={(text) => handleInputChange(index, text)}
                editable={!isStreaming}
              />
            ))}
          </View>
          
          {/* Category Picker */}
          <View style={styles.pickerContainer}>
            <Text style={styles.label}>Category</Text>
            <View style={styles.pickerWrapper}>
              <Picker
                selectedValue={analogyCategory}
                onValueChange={(value) => setAnalogyCategory(value)}
                style={styles.picker}
                dropdownIconColor="#00ffea"
                itemStyle={styles.pickerItem}
                enabled={!isStreaming}
              >
                <Picker.Item label="Real World Analogy" value="real-world" />
                <Picker.Item label="Video Games" value="video-games" />
                <Picker.Item label="TV Show" value="tv-show" />
                <Picker.Item label="Sports" value="sports" />
                <Picker.Item label="Fiction" value="fiction" />
                <Picker.Item label="Food & Cooking" value="food" />
                <Picker.Item label="Relationships" value="relationships" />
                <Picker.Item label="Music & Instruments" value="music" />
                <Picker.Item label="Animals" value="animals" />
                <Picker.Item label="Nature & Environment" value="nature" />
                <Picker.Item label="Travel & Exploration" value="travel" />
                <Picker.Item label="Historical Events" value="history" />
                <Picker.Item label="Technology" value="technology" />
                <Picker.Item label="Mythology" value="mythology" />
                <Picker.Item label="Business & Economics" value="business" />
                <Picker.Item label="Art & Creativity" value="art" />
                <Picker.Item label="School & Education" value="school" />
                <Picker.Item label="Construction & Engineering" value="construction" />
                <Picker.Item label="Space & Astronomy" value="space" />
                <Picker.Item label="Superheroes & Comic Books" value="superheroes" />
                <Picker.Item label="Medieval Times" value="medieval" />
                <Picker.Item label="Movies & Cinema" value="movies" />
                <Picker.Item label="Everyday Life" value="everyday-life" />
                <Picker.Item label="Gardening" value="gardening" />
                <Picker.Item label="Mr Robot" value="mr-robot" />
              </Picker>
            </View>
          </View>
          
          {/* Generate Button */}
          <TouchableOpacity 
            style={[styles.generateButton, isStreaming && styles.generateButtonDisabled]} 
            onPress={handleGenerateAnalogy}
            disabled={isStreaming}
          >
            {isStreaming ? (
              <View style={styles.buttonContent}>
                <ActivityIndicator color="#fff" size="small" />
                <Text style={styles.buttonText}>Streaming...</Text>
              </View>
            ) : (
              <Text style={styles.buttonText}>Generate Analogy</Text>
            )}
          </TouchableOpacity>
        </View>
        
        {/* Output Area */}
        {(generatedAnalogy || isStreaming) && (
          <View style={styles.outputContainer}>
            {generatedAnalogy ? (
              <>
                <View style={styles.outputHeader}>
                  <Text style={styles.outputTitle}>Generated Analogy</Text>
                  <TouchableOpacity 
                    style={styles.copyButton}
                    onPress={copyToClipboard}
                  >
                    <Ionicons name="copy-outline" size={16} color="#fff" />
                    <Text style={styles.copyText}>Copy</Text>
                  </TouchableOpacity>
                </View>
                <ScrollView 
                  ref={scrollViewRef}
                  style={styles.analogyTextContainer}
                  contentContainerStyle={styles.analogyTextContent}
                >
                  <Text style={styles.analogyText}>{generatedAnalogy}</Text>
                </ScrollView>
              </>
            ) : (
              <View style={styles.loadingContainer}>
                <ActivityIndicator color="#00ffea" size="large" />
                <Text style={styles.loadingText}>Generating analogy...</Text>
              </View>
            )}
          </View>
        )}
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  headerContainer: {
    alignItems: 'center',
    padding: 20,
    backgroundColor: 'rgba(0,0,0,0.5)',
    borderBottomWidth: 2,
    borderBottomColor: '#8B0000',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#ff4c8b',
    textShadowColor: 'rgba(255,0,0,0.7)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
    marginBottom: 5,
  },
  subtitle: {
    fontSize: 16,
    color: '#00ffea',
    textShadowColor: 'rgba(0,0,0,0.7)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  scrollView: {
    flex: 1,
  },
  scrollViewContent: {
    padding: 20,
  },
  formContainer: {
    marginBottom: 20,
  },
  pickerContainer: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    color: '#00ffea',
    marginBottom: 8,
  },
  pickerWrapper: {
    borderWidth: 2,
    borderColor: '#8B0000',
    borderRadius: 10,
    backgroundColor: '#222',
    overflow: 'hidden',
  },
  picker: {
    color: '#00ffea',
    backgroundColor: '#222',
    height: 50,
  },
  pickerItem: {
    fontSize: 16,
    color: '#00ffea',
  },
  inputFields: {
    gap: 16,
    marginBottom: 16,
  },
  input: {
    backgroundColor: '#222',
    borderWidth: 2,
    borderColor: '#8B0000',
    borderRadius: 10,
    color: '#00ffea',
    padding: 12,
    fontSize: 16,
  },
  generateButton: {
    backgroundColor: '#8B0000',
    paddingVertical: 14,
    paddingHorizontal: 20,
    borderRadius: 10,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2,
    borderColor: '#000',
    marginTop: 10,
  },
  generateButtonDisabled: {
    backgroundColor: '#550000',
    opacity: 0.7,
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  outputContainer: {
    backgroundColor: 'rgba(17, 17, 17, 0.95)',
    borderRadius: 10,
    borderWidth: 2,
    borderColor: '#8B0000',
    padding: 15,
    marginTop: 20,
  },
  outputHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 0, 0, 0.2)',
    paddingBottom: 10,
    marginBottom: 10,
  },
  outputTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ff0000',
  },
  copyButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
    paddingVertical: 6,
    paddingHorizontal: 12,
    borderRadius: 5,
    borderWidth: 1,
    borderColor: 'rgba(255,255,255,0.3)',
  },
  copyText: {
    color: '#fff',
    fontSize: 12,
    marginLeft: 5,
  },
  analogyTextContainer: {
    maxHeight: 300,
  },
  analogyTextContent: {
    paddingVertical: 10,
  },
  analogyText: {
    color: '#00ffea',
    fontSize: 16,
    lineHeight: 24,
  },
  loadingContainer: {
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    color: '#00ffea',
    marginTop: 10,
    fontSize: 16,
  },
});

export default AnalogyHubScreen;
</file>

<file path="src/screens/tools/DailyStationScreen.js">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  SafeAreaView,
  Platform,
  Modal,
  Animated
} from 'react-native';
import { useSelector, useDispatch } from 'react-redux';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import * as SecureStore from 'expo-secure-store';
import { claimDailyBonus, getDailyQuestion, submitDailyAnswer } from '../../api/dailyStationService';
import { fetchUserData } from '../../store/slices/userSlice';
import FormattedQuestion from '../../components/FormattedQuestion';

// Helper to format seconds as HH:MM:SS
function formatCountdown(seconds) {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = seconds % 60;
  return [h, m, s].map((x) => String(x).padStart(2, '0')).join(':');
}

const DailyStationScreen = () => {
  const dispatch = useDispatch();
  const { userId, username, coins, xp, lastDailyClaim } = useSelector((state) => state.user);

  // Local states for bonus section
  const [bonusError, setBonusError] = useState(null);
  const [claimInProgress, setClaimInProgress] = useState(false);
  const [claimed, setClaimed] = useState(false);
  const [bonusCountdown, setBonusCountdown] = useState(24 * 3600); // 24 hours in seconds
  const [showButton, setShowButton] = useState(true);
  const [localLastClaim, setLocalLastClaim] = useState(null);
  const [showBonusAnimation, setShowBonusAnimation] = useState(false);

  // Local states for question section
  const [loadingQuestion, setLoadingQuestion] = useState(true);
  const [questionError, setQuestionError] = useState(null);
  const [questionData, setQuestionData] = useState(null);
  const [selectedAnswer, setSelectedAnswer] = useState(null);
  const [submitResult, setSubmitResult] = useState(null);
  const [questionCountdown, setQuestionCountdown] = useState(0);
  const [showCorrectAnimation, setShowCorrectAnimation] = useState(false);
  const [showWrongAnimation, setShowWrongAnimation] = useState(false);

  // Animation values
  const fadeAnim = useState(new Animated.Value(0))[0];

  // Check if user can claim bonus on initial load
  useEffect(() => {
    if (userId) {
      // Check if there's a recent claim from storage or server
      const checkStoredClaim = async () => {
        try {
          const storedLastClaim = await SecureStore.getItemAsync(`lastClaim_${userId}`);
          const serverLastClaim = lastDailyClaim;
          
          const lastClaimDate = serverLastClaim || (storedLastClaim ? new Date(storedLastClaim) : null);
          
          if (lastClaimDate) {
            setLocalLastClaim(lastClaimDate);
            checkClaimStatus(lastClaimDate);
          } else {
            // No previous claim found, so show button
            setShowButton(true);
          }
        } catch (error) {
          console.error("Error checking stored claim:", error);
          // Default to showing button if there's an error
          setShowButton(true);
        }
      };
      
      checkStoredClaim();
    }
  }, [userId, lastDailyClaim]);

  // Check claim status helper function
  function checkClaimStatus(lastClaimDate) {
    const now = new Date();
    const lastClaimTime = new Date(lastClaimDate).getTime();
    const diffMs = now - lastClaimTime;
    
    if (diffMs >= 24 * 60 * 60 * 1000) {
      // It's been 24 hours, show button
      setShowButton(true);
    } else {
      // Less than 24 hours, show countdown
      setShowButton(false);
      const secondsRemaining = Math.floor((24 * 60 * 60 * 1000 - diffMs) / 1000);
      setBonusCountdown(secondsRemaining);
    }
  }

  // Bonus countdown logic (runs every second)
  useEffect(() => {
    if (!showButton && localLastClaim) {
      function tickBonus() {
        const now = new Date();
        const lastClaimTime = new Date(localLastClaim).getTime();
        const diffMs = now - lastClaimTime;
        
        if (diffMs >= 24 * 60 * 60 * 1000) {
          // It's been 24 hours, show button
          setShowButton(true);
          setBonusCountdown(0);
        } else {
          // Less than 24 hours, update countdown
          const secondsRemaining = Math.floor((24 * 60 * 60 * 1000 - diffMs) / 1000);
          setBonusCountdown(secondsRemaining);
        }
      }
      
      tickBonus(); // Run immediately
      const bonusInterval = setInterval(tickBonus, 1000);
      return () => clearInterval(bonusInterval);
    }
  }, [localLastClaim, showButton]);

  // Daily question refresh countdown logic
  useEffect(() => {
    function tickQuestion() {
      const now = new Date();
      const nextMidnightUTC = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1));
      const diff = Math.floor((nextMidnightUTC - now) / 1000);
      setQuestionCountdown(diff);
    }
    
    tickQuestion(); // Run immediately
    const questionInterval = setInterval(tickQuestion, 1000);
    return () => clearInterval(questionInterval);
  }, []);

  // Fetch daily question if user is logged in
  useEffect(() => {
    if (userId) {
      fetchDailyQuestion();
    } else {
      setLoadingQuestion(false);
    }
  }, [userId]);

  // Handle bonus animation
  useEffect(() => {
    if (showBonusAnimation) {
      Animated.sequence([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true
        }),
        Animated.delay(2000),
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: true
        })
      ]).start(() => {
        setShowBonusAnimation(false);
      });
    } else {
      fadeAnim.setValue(0);
    }
  }, [showBonusAnimation, fadeAnim]);

  // Claim daily bonus
  const handleClaimDailyBonus = async () => {
    if (!userId) {
      setBonusError('Please log in first.');
      return;
    }
    
    // IMMEDIATELY hide button and show countdown to prevent double-clicks
    setShowButton(false);
    setClaimInProgress(true);
    setBonusError(null);
    
    // Set last claim time to now and store it in state
    const now = new Date();
    setLocalLastClaim(now);
    // Store in SecureStore for persistence
    try {
      await SecureStore.setItemAsync(`lastClaim_${userId}`, now.toISOString());
    } catch (error) {
      console.error("Error saving claim time:", error);
    }
    
    // Start the countdown immediately
    setBonusCountdown(24 * 60 * 60); // 24 hours in seconds
    
    try {
      // Make the API call
      const data = await claimDailyBonus(userId);
      
      setClaimInProgress(false);
      
      if (data.success) {
        // Show success animation
        setShowBonusAnimation(true);
        setClaimed(true);
        
        // Update the user data in Redux
        dispatch(fetchUserData(userId));
      } else {
        // Server says already claimed
        setBonusError(data.message);
        // Don't change UI state - keep showing countdown
      }
    } catch (err) {
      setBonusError('Error: ' + err.message);
      setClaimInProgress(false);
      // Even if there's an error, keep showing the countdown
    }
  };

  // Fetch daily question
  const fetchDailyQuestion = async () => {
    setLoadingQuestion(true);
    setQuestionError(null);
    
    try {
      const data = await getDailyQuestion(userId);
      setQuestionData(data);
      setLoadingQuestion(false);
    } catch (err) {
      setQuestionError('Error fetching daily question: ' + err.message);
      setLoadingQuestion(false);
    }
  };

  // Submit daily answer
  const handleSubmitAnswer = async () => {
    if (!questionData || questionData.alreadyAnswered) {
      setQuestionError("You've already answered today's question!");
      return;
    }
    
    if (selectedAnswer === null) {
      setQuestionError('Please select an answer first.');
      return;
    }
    
    setQuestionError(null);
    
    try {
      const ansData = await submitDailyAnswer(userId, questionData.dayIndex, selectedAnswer);
      
      setSubmitResult(ansData);
      
      // Update the Redux store with new XP and coins
      dispatch(fetchUserData(userId));
      
      setQuestionData((prev) => ({
        ...prev,
        alreadyAnswered: true
      }));

      if (ansData.correct) {
        setShowCorrectAnimation(true);
        setTimeout(() => setShowCorrectAnimation(false), 2000);
      } else {
        setShowWrongAnimation(true);
        setTimeout(() => setShowWrongAnimation(false), 2000);
      }
    } catch (err) {
      setQuestionError('Error: ' + err.message);
    }
  };

  // Not needed anymore since we're using the FormattedQuestion component

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView style={styles.scrollView}>
        {/* Header Section */}
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Daily Station</Text>
          <Text style={styles.subtitle}>Claim your daily rewards and answer the challenge</Text>
          
          {userId && (
            <View style={styles.userStats}>
              <View style={styles.statItem}>
                <Ionicons name="cash" size={18} color="#FFD700" />
                <Text style={styles.statValue}>{coins}</Text>
              </View>
              <View style={styles.statItem}>
                <Ionicons name="star" size={18} color="#0095FF" />
                <Text style={styles.statValue}>{xp}</Text>
              </View>
            </View>
          )}
        </View>

        {/* Main Content */}
        <View style={styles.content}>
          {!userId ? (
            <View style={styles.loginRequired}>
              <Ionicons name="bulb" size={40} color="#6543CC" style={styles.loginIcon} />
              <Text style={styles.loginTitle}>Login Required</Text>
              <Text style={styles.loginText}>
                Please log in to claim daily rewards and participate in daily challenges.
              </Text>
            </View>
          ) : (
            <>
              {/* Daily Bonus Card */}
              <View style={styles.card}>
                <LinearGradient
                  colors={['#FF4C8B', '#FF7950']}
                  start={{x: 0, y: 0}}
                  end={{x: 1, y: 0}}
                  style={styles.cardHeader}
                >
                  <Ionicons name="gift" size={20} color="#FFFFFF" />
                  <Text style={styles.cardTitle}>Daily Bonus</Text>
                </LinearGradient>
                
                <View style={styles.cardContent}>
                  <View style={styles.bonusInfo}>
                    <View style={styles.bonusValue}>
                      <Ionicons name="cash" size={24} color="#FFD700" />
                      <Text style={styles.bonusValueText}>250</Text>
                    </View>
                    <Text style={styles.bonusText}>Claim your free coins every 24 hours!</Text>
                  </View>
                  
                  {/* Show error if any */}
                  {bonusError && !bonusError.includes("Next bonus in") && (
                    <View style={styles.errorContainer}>
                      <Ionicons name="alert-circle" size={20} color="#FF4E4E" />
                      <Text style={styles.errorText}>{bonusError}</Text>
                    </View>
                  )}
                  
                  {/* Claim Button or Countdown */}
                  <View style={styles.bonusAction}>
                    {showButton ? (
                      <TouchableOpacity 
                        style={styles.claimButton}
                        onPress={handleClaimDailyBonus}
                        disabled={claimInProgress}
                      >
                        {claimInProgress ? (
                          <View style={styles.buttonContent}>
                            <ActivityIndicator size="small" color="#FFFFFF" />
                            <Text style={styles.buttonText}>Claiming...</Text>
                          </View>
                        ) : (
                          <View style={styles.buttonContent}>
                            <Ionicons name="cash" size={20} color="#FFFFFF" />
                            <Text style={styles.buttonText}>Claim Bonus</Text>
                          </View>
                        )}
                      </TouchableOpacity>
                    ) : (
                      <View style={styles.countdown}>
                        <Ionicons name="hourglass" size={24} color="#6543CC" />
                        <View style={styles.countdownInfo}>
                          <Text style={styles.countdownLabel}>Next bonus in:</Text>
                          <Text style={styles.countdownTime}>{formatCountdown(bonusCountdown)}</Text>
                        </View>
                      </View>
                    )}
                  </View>
                </View>
              </View>

              {/* Daily Question Card */}
              <View style={styles.card}>
                <LinearGradient
                  colors={['#6543CC', '#8A58FC']}
                  start={{x: 0, y: 0}}
                  end={{x: 1, y: 0}}
                  style={styles.cardHeader}
                >
                  <Ionicons name="bulb" size={20} color="#FFFFFF" />
                  <Text style={styles.cardTitle}>Daily Challenge</Text>
                </LinearGradient>
                
                <View style={styles.cardContent}>
                  {loadingQuestion ? (
                    <View style={styles.loading}>
                      <ActivityIndicator size="large" color="#6543CC" />
                      <Text style={styles.loadingText}>Loading challenge...</Text>
                    </View>
                  ) : questionError ? (
                    <View style={styles.errorContainer}>
                      <Ionicons name="alert-circle" size={20} color="#FF4E4E" />
                      <Text style={styles.errorText}>{questionError}</Text>
                    </View>
                  ) : !questionData ? (
                    <View style={styles.emptyState}>
                      <Text style={styles.emptyText}>No challenges available today. Check back tomorrow!</Text>
                    </View>
                  ) : (
                    <View style={[
                      styles.question,
                      showCorrectAnimation && styles.correctAnimation,
                      showWrongAnimation && styles.wrongAnimation
                    ]}>
                      <View style={styles.questionPrompt}>
                        <FormattedQuestion questionText={questionData.prompt} />
                      </View>
                      
                      {questionData.alreadyAnswered ? (
                        <View style={styles.questionAnswered}>
                          {submitResult && (
                            <View style={[
                              styles.resultContainer,
                              submitResult.correct ? styles.correctResult : styles.incorrectResult
                            ]}>
                              <Ionicons 
                                name={submitResult.correct ? "checkmark-circle" : "close-circle"} 
                                size={24} 
                                color={submitResult.correct ? "#2EBB77" : "#FF4E4E"} 
                              />
                              <Text style={styles.resultText}>
                                {submitResult.correct ? 
                                  `Correct! You earned ${submitResult.awardedCoins} coins.` : 
                                  `Not quite, but you still got ${submitResult.awardedCoins} coins.`}
                              </Text>
                            </View>
                          )}
                          
                          {/* Explanation Section */}
                          {(questionData.explanation || (submitResult && submitResult.explanation)) && (
                            <View style={styles.explanation}>
                              <Text style={styles.explanationTitle}>Explanation:</Text>
                              <FormattedQuestion questionText={questionData.explanation || (submitResult && submitResult.explanation)} />
                            </View>
                          )}
                          
                          <View style={styles.nextQuestion}>
                            <View style={styles.countdown}>
                              <Ionicons name="calendar" size={24} color="#6543CC" />
                              <View style={styles.countdownInfo}>
                                <Text style={styles.countdownLabel}>Next challenge in:</Text>
                                <Text style={styles.countdownTime}>{formatCountdown(questionCountdown)}</Text>
                              </View>
                            </View>
                          </View>
                        </View>
                      ) : (
                        <View style={styles.questionOptions}>
                          {questionData.options.map((option, index) => (
                            <TouchableOpacity 
                              key={index}
                              style={[
                                styles.optionItem,
                                selectedAnswer === index && styles.selectedOption
                              ]}
                              onPress={() => setSelectedAnswer(index)}
                            >
                              <Text style={[
                                styles.optionText,
                                selectedAnswer === index && styles.selectedOptionText
                              ]}>
                                {option}
                              </Text>
                              {selectedAnswer === index && (
                                <Ionicons name="chevron-forward" size={18} color="#FFFFFF" style={styles.optionIcon} />
                              )}
                            </TouchableOpacity>
                          ))}
                          
                          <TouchableOpacity 
                            style={[
                              styles.submitButton,
                              selectedAnswer === null && styles.disabledButton
                            ]}
                            onPress={handleSubmitAnswer}
                            disabled={selectedAnswer === null}
                          >
                            <Text style={styles.buttonText}>Submit Answer</Text>
                          </TouchableOpacity>
                          
                          <View style={styles.nextQuestion}>
                            <View style={styles.countdown}>
                              <Ionicons name="calendar" size={24} color="#6543CC" />
                              <View style={styles.countdownInfo}>
                                <Text style={styles.countdownLabel}>Challenge refreshes in:</Text>
                                <Text style={styles.countdownTime}>{formatCountdown(questionCountdown)}</Text>
                              </View>
                            </View>
                          </View>
                        </View>
                      )}
                    </View>
                  )}
                </View>
              </View>
            </>
          )}
        </View>
      </ScrollView>
      
      {/* BONUS CLAIM ANIMATION OVERLAY */}
      {showBonusAnimation && (
        <Animated.View style={[styles.overlay, {opacity: fadeAnim}]}>
          <View style={styles.bonusAnimation}>
            <Ionicons name="cash" size={60} color="#FFD700" style={styles.bonusIcon} />
            <View style={styles.bonusAnimationText}>
              <Text style={styles.bonusAnimationTitle}>Daily Bonus Claimed!</Text>
              <Text style={styles.bonusAnimationSubtitle}>+250 coins added to your account</Text>
            </View>
          </View>
        </Animated.View>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0B0C15',
  },
  scrollView: {
    flex: 1,
  },
  header: {
    padding: 20,
    backgroundColor: '#171A23',
    borderBottomWidth: 1,
    borderBottomColor: '#2A2C3D',
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 5,
  },
  subtitle: {
    fontSize: 14,
    color: '#9DA8B9',
    marginBottom: 15,
  },
  userStats: {
    flexDirection: 'row',
    marginTop: 10,
  },
  statItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 15,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 10,
  },
  statValue: {
    color: '#FFFFFF',
    marginLeft: 6,
    fontWeight: '600',
  },
  content: {
    padding: 20,
  },
  loginRequired: {
    backgroundColor: '#171A23',
    borderRadius: 15,
    padding: 30,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: '#2A2C3D',
  },
  loginIcon: {
    marginBottom: 15,
  },
  loginTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 10,
  },
  loginText: {
    color: '#9DA8B9',
    textAlign: 'center',
    lineHeight: 22,
  },
  card: {
    backgroundColor: '#171A23',
    borderRadius: 15,
    overflow: 'hidden',
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#2A2C3D',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.4,
    shadowRadius: 24,
    elevation: 10,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    gap: 10,
  },
  cardTitle: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  cardContent: {
    padding: 20,
  },
  bonusInfo: {
    alignItems: 'center',
    marginBottom: 20,
  },
  bonusValue: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 20,
    paddingVertical: 10,
    paddingHorizontal: 20,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: 'rgba(255, 215, 0, 0.3)',
  },
  bonusValueText: {
    color: '#FFFFFF',
    fontSize: 20,
    fontWeight: 'bold',
    marginLeft: 10,
  },
  bonusText: {
    color: '#9DA8B9',
    textAlign: 'center',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 78, 78, 0.1)',
    padding: 10,
    borderRadius: 8,
    marginBottom: 15,
  },
  errorText: {
    color: '#FF4E4E',
    marginLeft: 10,
    flex: 1,
  },
  bonusAction: {
    alignItems: 'center',
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
  },
  claimButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#FF4C8B',
    borderRadius: 25,
    paddingVertical: 12,
    paddingHorizontal: 24,
    minWidth: 200,
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  countdown: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 20,
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderWidth: 1,
    borderColor: '#2A2C3D',
  },
  countdownInfo: {
    marginLeft: 10,
  },
  countdownLabel: {
    color: '#9DA8B9',
    fontSize: 12,
  },
  countdownTime: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
    fontFamily: Platform.OS === 'ios' ? 'Courier' : 'monospace',
  },
  loading: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 30,
  },
  loadingText: {
    color: '#9DA8B9',
    marginTop: 10,
  },
  emptyState: {
    alignItems: 'center',
    padding: 20,
  },
  emptyText: {
    color: '#9DA8B9',
    textAlign: 'center',
  },
  question: {
    borderRadius: 10,
    overflow: 'hidden',
  },
  questionPrompt: {
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 10,
    padding: 15,
    marginBottom: 15,
    borderWidth: 1,
    borderColor: '#2A2C3D',
  },
  questionText: {
    color: '#FFFFFF',
    fontSize: 16,
    lineHeight: 24,
  },
  questionOptions: {
    marginBottom: 15,
  },
  optionItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 8,
    padding: 15,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: '#2A2C3D',
  },
  selectedOption: {
    backgroundColor: 'rgba(101, 67, 204, 0.2)',
    borderColor: '#6543CC',
  },
  optionText: {
    color: '#FFFFFF',
    flex: 1,
  },
  selectedOptionText: {
    fontWeight: '600',
  },
  optionIcon: {
    marginLeft: 10,
  },
  submitButton: {
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#6543CC',
    borderRadius: 25,
    paddingVertical: 12,
    paddingHorizontal: 24,
    marginTop: 10,
    marginBottom: 20,
  },
  disabledButton: {
    backgroundColor: 'rgba(101, 67, 204, 0.5)',
  },
  nextQuestion: {
    alignItems: 'center',
  },
  questionAnswered: {
    padding: 5,
  },
  resultContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    borderRadius: 10,
    marginBottom: 15,
  },
  correctResult: {
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
    borderWidth: 1,
    borderColor: 'rgba(46, 187, 119, 0.3)',
  },
  incorrectResult: {
    backgroundColor: 'rgba(255, 78, 78, 0.1)',
    borderWidth: 1,
    borderColor: 'rgba(255, 78, 78, 0.3)',
  },
  resultText: {
    color: '#FFFFFF',
    marginLeft: 10,
    flex: 1,
  },
  explanation: {
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 10,
    padding: 15,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#2A2C3D',
    borderLeftWidth: 3,
    borderLeftColor: '#6543CC',
  },
  explanationTitle: {
    color: '#FFFFFF',
    fontWeight: '600',
    marginBottom: 10,
  },
  explanationText: {
    color: '#9DA8B9',
    lineHeight: 22,
  },
  correctAnimation: {
    borderColor: '#2EBB77',
    borderWidth: 1,
  },
  wrongAnimation: {
    borderColor: '#FF4E4E',
    borderWidth: 1,
  },
  overlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
  },
  bonusAnimation: {
    backgroundColor: '#171A23',
    borderRadius: 15,
    padding: 30,
    alignItems: 'center',
    maxWidth: '80%',
    borderWidth: 1,
    borderColor: '#6543CC',
    shadowColor: '#6543CC',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.5,
    shadowRadius: 20,
    elevation: 15,
  },
  bonusIcon: {
    marginBottom: 20,
  },
  bonusAnimationText: {
    alignItems: 'center',
  },
  bonusAnimationTitle: {
    color: '#FFFFFF',
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  bonusAnimationSubtitle: {
    color: '#9DA8B9',
    fontSize: 16,
  },
});

export default DailyStationScreen;
</file>

<file path="src/screens/tools/GRCScreen.js">
// src/screens/tools/GRCScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  SafeAreaView,
  Dimensions
} from 'react-native';
import { Picker } from '@react-native-picker/picker';
import { Ionicons } from '@expo/vector-icons';
import * as Clipboard from 'expo-clipboard';
import { StatusBar } from 'expo-status-bar';
import { useToast } from 'react-native-toast-notifications';
import { streamGRCQuestion } from '../../api/grcService';

const GRCScreen = () => {
  const [category, setCategory] = useState('Random');
  const [difficulty, setDifficulty] = useState('Easy');
  const [loading, setLoading] = useState(false);
  const [questionData, setQuestionData] = useState(null);
  const [selectedOption, setSelectedOption] = useState(null);
  const [showExplanation, setShowExplanation] = useState(false);
  const [copiedToClipboard, setCopiedToClipboard] = useState(false);
  
  const toast = useToast();
  
  // Categories and difficulties arrays
  const categories = [
    "Regulation",
    "Risk Management",
    "Compliance",
    "Audit",
    "Governance",
    "Management",
    "Policy",
    "Ethics",
    "Threat Assessment",
    "Leadership",
    "Business Continuity",
    "Random"
  ];
  
  const difficulties = ["Easy", "Medium", "Hard"];
  
  // Map difficulty to colors
  const difficultyColors = {
    "Easy": "#2ebb77",
    "Medium": "#ffc107",
    "Hard": "#ff4c8b"
  };
  
  // Reset copy status after 2 seconds
  useEffect(() => {
    if (copiedToClipboard) {
      const timer = setTimeout(() => {
        setCopiedToClipboard(false);
      }, 2000);
      return () => clearTimeout(timer);
    }
  }, [copiedToClipboard]);
  
  const fetchQuestion = async () => {
    setLoading(true);
    setQuestionData(null);
    setSelectedOption(null);
    setShowExplanation(false);

    try {
      const data = await streamGRCQuestion(category, difficulty);
      setQuestionData(data);
    } catch (error) {
      console.error('Error fetching question:', error);
      toast.show('Error fetching question. Please try again.', {
        type: 'danger',
        duration: 3000,
      });
    } finally {
      setLoading(false);
    }
  };
  
  const handleAnswer = (optionIndex) => {
    if (!questionData) return;
    
    setSelectedOption(optionIndex);
    setShowExplanation(true);
  };
  
  const handleCopy = async () => {
    if (!questionData || !showExplanation) return;
    
    const correctIndex = questionData.correct_answer_index;
    const correctExplanation = questionData.explanations[correctIndex.toString()];
    const examTip = questionData.exam_tip;
    
    const textToCopy = `Question: ${questionData.question}\n\nOptions:\n${questionData.options.map((opt, i) => `${i + 1}. ${opt}`).join('\n')}\n\nCorrect Answer: ${questionData.options[correctIndex]}\n\nExplanation: ${correctExplanation}\n\nExam Tip: ${examTip}`;
    
    await Clipboard.setStringAsync(textToCopy);
    setCopiedToClipboard(true);
    toast.show('Copied to clipboard!', {
      type: 'success',
      duration: 2000,
    });
  };
  
  const getNewQuestion = () => {
    fetchQuestion();
  };
  
  // Get the letter representation (A, B, C, D) from index
  const getLetterFromIndex = (index) => {
    return String.fromCharCode(65 + index);
  };
  
  return (
    <SafeAreaView style={styles.container}>
      <StatusBar style="light" />
      
      <View style={styles.header}>
        <Text style={styles.title}>GRC Wizard</Text>
        <Text style={styles.subtitle}>Master the art of Governance, Risk, and Compliance</Text>
      </View>
      
      <ScrollView style={styles.scrollView}>
        <View style={styles.wizardCard}>
          <View style={styles.cardHeader}>
            <Text style={styles.cardTitle}>Generate a Question</Text>
            <Text style={styles.cardSubtitle}>Select a category and difficulty level</Text>
          </View>
          
          <View style={styles.controls}>
            {/* Category Picker */}
            <View style={styles.controlGroup}>
              <Text style={styles.label}>Category</Text>
              <View style={styles.pickerWrapper}>
                <Picker
                  selectedValue={category}
                  onValueChange={(value) => setCategory(value)}
                  style={styles.picker}
                  dropdownIconColor="#6543cc"
                  itemStyle={styles.pickerItem}
                  enabled={!loading}
                >
                  {categories.map((cat) => (
                    <Picker.Item key={cat} label={cat} value={cat} />
                  ))}
                </Picker>
              </View>
            </View>
            
            {/* Difficulty Picker */}
            <View style={styles.controlGroup}>
              <Text style={styles.label}>Difficulty</Text>
              <View style={styles.pickerWrapper}>
                <Picker
                  selectedValue={difficulty}
                  onValueChange={(value) => setDifficulty(value)}
                  style={styles.picker}
                  dropdownIconColor={difficultyColors[difficulty]}
                  itemStyle={styles.pickerItem}
                  enabled={!loading}
                >
                  {difficulties.map((level) => (
                    <Picker.Item key={level} label={level} value={level} />
                  ))}
                </Picker>
              </View>
            </View>
            
            {/* Generate Button */}
            <TouchableOpacity
              style={styles.generateButton}
              onPress={fetchQuestion}
              disabled={loading}
            >
              {loading ? (
                <View style={styles.buttonContent}>
                  <ActivityIndicator color="#fff" size="small" />
                  <Text style={styles.buttonText}>Generating</Text>
                </View>
              ) : questionData ? (
                <View style={styles.buttonContent}>
                  <Ionicons name="sync" size={20} color="#fff" />
                  <Text style={styles.buttonText}>New Question</Text>
                </View>
              ) : (
                <View style={styles.buttonContent}>
                  <Ionicons name="book" size={20} color="#fff" />
                  <Text style={styles.buttonText}>Generate Question</Text>
                </View>
              )}
            </TouchableOpacity>
          </View>
        </View>
        
        {questionData && (
          <View style={styles.questionCard}>
            <View style={styles.questionHeader}>
              <View style={styles.questionMeta}>
                <Text style={styles.questionCategory}>
                  <Ionicons name={category === 'Random' ? 'shuffle' : 'shield-checkmark'} size={16} color="#AAAAAA" /> {category}
                </Text>
                <Text style={[styles.questionDifficulty, {color: difficultyColors[difficulty]}]}>
                  <Ionicons 
                    name={difficulty === 'Easy' ? 'bulb-outline' : difficulty === 'Medium' ? 'rocket' : 'trophy'} 
                    size={16} 
                    color={difficultyColors[difficulty]} 
                  /> {difficulty}
                </Text>
              </View>
              <Text style={styles.questionTitle}>Question</Text>
            </View>
            
            <View style={styles.questionContent}>
              <Text style={styles.questionText}>{questionData.question}</Text>
              
              <View style={styles.optionsContainer}>
                {questionData.options.map((option, index) => {
                  const isCorrect = index === questionData.correct_answer_index;
                  const isSelected = selectedOption === index;
                  
                  return (
                    <TouchableOpacity
                      key={index}
                      style={[
                        styles.option,
                        isSelected && styles.selectedOption,
                        showExplanation && isCorrect && styles.correctOption,
                        showExplanation && isSelected && !isCorrect && styles.incorrectOption
                      ]}
                      onPress={() => handleAnswer(index)}
                      disabled={selectedOption !== null}
                    >
                      <View style={[
                        styles.optionLetter,
                        showExplanation && isCorrect && styles.correctLetter,
                        showExplanation && isSelected && !isCorrect && styles.incorrectLetter
                      ]}>
                        <Text style={styles.optionLetterText}>{getLetterFromIndex(index)}</Text>
                      </View>
                      <Text style={styles.optionText}>{option}</Text>
                      {showExplanation && isCorrect && (
                        <Ionicons name="checkmark" size={20} color="#2ebb77" style={styles.statusIcon} />
                      )}
                      {showExplanation && isSelected && !isCorrect && (
                        <Ionicons name="close" size={20} color="#ff4e4e" style={styles.statusIcon} />
                      )}
                    </TouchableOpacity>
                  );
                })}
              </View>
            </View>
            
            {showExplanation && (
              <View style={styles.explanationContainer}>
                <View style={styles.explanationHeader}>
                  <Text style={styles.explanationTitle}>
                    {selectedOption === questionData.correct_answer_index ? (
                      <><Ionicons name="checkmark" size={20} color="#2ebb77" /> Correct Answer</>
                    ) : (
                      <><Ionicons name="close" size={20} color="#ff4e4e" /> Incorrect Answer</>
                    )}
                  </Text>
                  <TouchableOpacity 
                    style={[styles.copyButton, copiedToClipboard && styles.copiedButton]}
                    onPress={handleCopy}
                  >
                    {copiedToClipboard ? (
                      <><Ionicons name="checkmark" size={16} color="#fff" /> Copied</>
                    ) : (
                      <><Ionicons name="copy" size={16} color="#fff" /> Copy</>
                    )}
                  </TouchableOpacity>
                </View>
                
                <View style={styles.explanationContent}>
                  <View style={styles.explanationSection}>
                    <Text style={styles.explanationSectionTitle}>Explanation</Text>
                    <Text style={styles.explanationText}>{questionData.explanations[selectedOption.toString()]}</Text>
                  </View>
                  
                  <View style={styles.explanationSection}>
                    <Text style={styles.explanationSectionTitle}>
                      <Ionicons name="bulb" size={18} color="#ffc107" /> Exam Tip
                    </Text>
                    <Text style={styles.tipText}>{questionData.exam_tip}</Text>
                  </View>
                </View>
                
                <View style={styles.actionButtons}>
                  <TouchableOpacity 
                    style={styles.nextButton} 
                    onPress={getNewQuestion}
                  >
                    <Ionicons name="sync" size={20} color="#fff" />
                    <Text style={styles.nextButtonText}>New Question</Text>
                  </TouchableOpacity>
                </View>
              </View>
            )}
          </View>
        )}
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0b0c15',
  },
  header: {
    backgroundColor: '#171a23',
    padding: 20,
    borderRadius: 15,
    margin: 15,
    borderWidth: 1,
    borderColor: '#2a2c3d',
    borderTopWidth: 4,
    borderTopColor: '#6543cc',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#6543cc',
    textAlign: 'center',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#9da8b9',
    textAlign: 'center',
  },
  scrollView: {
    flex: 1,
    padding: 15,
  },
  wizardCard: {
    backgroundColor: '#171a23',
    borderRadius: 15,
    padding: 20,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#2a2c3d',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.4,
    shadowRadius: 24,
    elevation: 5,
  },
  cardHeader: {
    marginBottom: 20,
    alignItems: 'center',
  },
  cardTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#e2e2e2',
    marginBottom: 5,
  },
  cardSubtitle: {
    fontSize: 14,
    color: '#9da8b9',
  },
  controls: {
    gap: 15,
  },
  controlGroup: {
    marginBottom: 15,
  },
  label: {
    fontSize: 14,
    color: '#9da8b9',
    marginBottom: 8,
    fontWeight: '500',
  },
  pickerWrapper: {
    borderWidth: 1,
    borderColor: '#2a2c3d',
    borderRadius: 8,
    backgroundColor: '#333333',
    overflow: 'hidden',
  },
  picker: {
    color: '#e2e2e2',
    height: 50,
  },
  pickerItem: {
    fontSize: 16,
  },
  generateButton: {
    backgroundColor: '#6543cc',
    borderRadius: 8,
    paddingVertical: 12,
    paddingHorizontal: 20,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: 'rgba(101, 67, 204, 0.3)',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 15,
    elevation: 5,
    marginTop: 5,
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  questionCard: {
    backgroundColor: '#171a23',
    borderRadius: 15,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: '#2a2c3d',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.4,
    shadowRadius: 24,
    elevation: 5,
    marginBottom: 20,
  },
  questionHeader: {
    padding: 20,
    backgroundColor: '#333333',
    borderBottomWidth: 1,
    borderBottomColor: '#2a2c3d',
  },
  questionMeta: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 10,
  },
  questionCategory: {
    fontSize: 14,
    color: '#9da8b9',
    flexDirection: 'row',
    alignItems: 'center',
  },
  questionDifficulty: {
    fontSize: 14,
    flexDirection: 'row',
    alignItems: 'center',
  },
  questionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#e2e2e2',
  },
  questionContent: {
    padding: 20,
  },
  questionText: {
    fontSize: 18,
    color: '#e2e2e2',
    lineHeight: 26,
    marginBottom: 25,
  },
  optionsContainer: {
    gap: 15,
  },
  option: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#333333',
    borderWidth: 1,
    borderColor: '#2a2c3d',
    borderRadius: 10,
    padding: 15,
  },
  selectedOption: {
    borderColor: '#6543cc',
    backgroundColor: 'rgba(101, 67, 204, 0.1)',
  },
  correctOption: {
    borderColor: '#2ebb77',
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
  },
  incorrectOption: {
    borderColor: '#ff4e4e',
    backgroundColor: 'rgba(255, 78, 78, 0.1)',
  },
  optionLetter: {
    width: 30,
    height: 30,
    backgroundColor: '#0b0c15',
    borderRadius: 15,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 15,
  },
  correctLetter: {
    backgroundColor: '#2ebb77',
  },
  incorrectLetter: {
    backgroundColor: '#ff4e4e',
  },
  optionLetterText: {
    color: '#e2e2e2',
    fontWeight: 'bold',
    fontSize: 14,
  },
  optionText: {
    flex: 1,
    color: '#e2e2e2',
    fontSize: 16,
    lineHeight: 24,
  },
  statusIcon: {
    marginLeft: 10,
  },
  explanationContainer: {
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#2a2c3d',
    backgroundColor: 'rgba(0, 0, 0, 0.15)',
  },
  explanationHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  explanationTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#e2e2e2',
    flexDirection: 'row',
    alignItems: 'center',
  },
  copyButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#333333',
    borderWidth: 1,
    borderColor: '#2a2c3d',
    borderRadius: 6,
    paddingVertical: 8,
    paddingHorizontal: 12,
    gap: 6,
  },
  copiedButton: {
    backgroundColor: '#2ebb77',
    borderColor: 'transparent',
  },
  explanationContent: {
    gap: 20,
  },
  explanationSection: {
    backgroundColor: '#333333',
    borderWidth: 1,
    borderColor: '#2a2c3d',
    borderRadius: 10,
    padding: 15,
  },
  explanationSectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#e2e2e2',
    marginBottom: 10,
    flexDirection: 'row',
    alignItems: 'center',
  },
  explanationText: {
    fontSize: 15,
    color: '#9da8b9',
    lineHeight: 22,
  },
  tipText: {
    fontSize: 15,
    color: '#9da8b9',
    lineHeight: 22,
    fontStyle: 'italic',
    borderLeftWidth: 3,
    borderLeftColor: '#ffc107',
    paddingLeft: 10,
  },
  actionButtons: {
    alignItems: 'center',
    marginTop: 25,
  },
  nextButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ff4c8b',
    borderRadius: 8,
    paddingVertical: 12,
    paddingHorizontal: 25,
    shadowColor: 'rgba(255, 76, 139, 0.3)',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 15,
    elevation: 5,
    gap: 10,
  },
  nextButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

export default GRCScreen;
</file>

<file path="src/screens/tools/NewsletterScreen.js">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  Alert,
  SafeAreaView,
  Platform,
  KeyboardAvoidingView
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { subscribeToNewsletter, unsubscribeFromNewsletter } from '../../api/newsletterService';

const NewsletterScreen = () => {
  const [email, setEmail] = useState('');
  const [activeSection, setActiveSection] = useState('subscribe');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [statusMsg, setStatusMsg] = useState('');
  const [isError, setIsError] = useState(false);
  const [showStatusMsg, setShowStatusMsg] = useState(false);

  // Clear status message after 5 seconds
  useEffect(() => {
    if (statusMsg && showStatusMsg) {
      const timer = setTimeout(() => {
        setShowStatusMsg(false);
        setTimeout(() => setStatusMsg(''), 300); // Clear message after fade-out
      }, 5000);
      return () => clearTimeout(timer);
    }
  }, [statusMsg, showStatusMsg]);

  // Email validation
  const isValidEmail = (email) => {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
  };

  const handleSubscribe = async () => {
    if (!email) {
      setIsError(true);
      setStatusMsg("Please enter your email address.");
      setShowStatusMsg(true);
      return;
    }

    if (!isValidEmail(email)) {
      setIsError(true);
      setStatusMsg("Please enter a valid email address.");
      setShowStatusMsg(true);
      return;
    }

    setIsSubmitting(true);
    setStatusMsg("");
    setShowStatusMsg(false);
    
    try {
      const response = await subscribeToNewsletter(email);
      setIsError(false);
      setStatusMsg(response.message || "Successfully subscribed to the Daily Cyber Brief!");
      setShowStatusMsg(true);
      // Clear email field on successful subscription
      setEmail("");
    } catch (err) {
      setIsError(true);
      const fallback = "Subscription failed. Please try again.";
      setStatusMsg(err.message || fallback);
      setShowStatusMsg(true);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleUnsubscribe = async () => {
    if (!email) {
      setIsError(true);
      setStatusMsg("Please enter your email address to unsubscribe.");
      setShowStatusMsg(true);
      return;
    }

    if (!isValidEmail(email)) {
      setIsError(true);
      setStatusMsg("Please enter a valid email address.");
      setShowStatusMsg(true);
      return;
    }

    setIsSubmitting(true);
    setStatusMsg("");
    setShowStatusMsg(false);
    
    try {
      const response = await unsubscribeFromNewsletter(email);
      setIsError(false);
      setStatusMsg(response.message || "Successfully unsubscribed from the Daily Cyber Brief.");
      setShowStatusMsg(true);
      // Clear email field on successful unsubscription
      setEmail("");
    } catch (err) {
      setIsError(true);
      const fallback = "Unsubscribe failed. Please try again.";
      setStatusMsg(err.message || fallback);
      setShowStatusMsg(true);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      if (activeSection === "subscribe") {
        handleSubscribe();
      } else {
        handleUnsubscribe();
      }
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <ScrollView style={styles.scrollView}>
          {/* Header Section */}
          <View style={styles.header}>
            <View style={styles.logoContainer}>
              <LinearGradient
                colors={['#6543CC', '#8A58FC']}
                style={styles.logoBackground}
              >
                <Ionicons name="newspaper" size={30} color="#FFFFFF" />
              </LinearGradient>
            </View>
            <Text style={styles.headerTitle}>Daily Cyber Brief</Text>
            <Text style={styles.subtitle}>Your essential cybersecurity intelligence, delivered daily</Text>
          </View>

          {/* Main Content */}
          <View style={styles.mainContent}>
            {/* Intro Card */}
            <View style={styles.card}>
              <LinearGradient
                colors={['#6543CC', '#8A58FC']}
                start={{x: 0, y: 0}}
                end={{x: 1, y: 0}}
                style={styles.cardHeader}
              >
                <Ionicons name="shield" size={20} color="#FFFFFF" />
                <Text style={styles.cardTitle}>Stay Ahead of Cyber Threats</Text>
              </LinearGradient>
              
              <View style={styles.cardContent}>
                <Text style={styles.cardText}>
                  The Daily Cyber Brief delivers curated, actionable cybersecurity intelligence 
                  directly to your inbox. Stay informed about emerging threats, security best 
                  practices, and industry trends.
                </Text>
                
                <View style={styles.features}>
                  <View style={styles.feature}>
                    <Ionicons name="lock-closed" size={20} color="#FF4C8B" />
                    <View style={styles.featureTextContainer}>
                      <Text style={styles.featureTitle}>Threat Intelligence</Text>
                      <Text style={styles.featureText}>Get the latest on emerging cyber threats and vulnerabilities</Text>
                    </View>
                  </View>
                  
                  <View style={styles.feature}>
                    <Ionicons name="trending-up" size={20} color="#FF4C8B" />
                    <View style={styles.featureTextContainer}>
                      <Text style={styles.featureTitle}>Industry Trends</Text>
                      <Text style={styles.featureText}>Track industry trends and stay ahead of the curve</Text>
                    </View>
                  </View>
                  
                  <View style={styles.feature}>
                    <Ionicons name="construct" size={20} color="#FF4C8B" />
                    <View style={styles.featureTextContainer}>
                      <Text style={styles.featureTitle}>Security Tools</Text>
                      <Text style={styles.featureText}>Practical security tools and techniques for implementation</Text>
                    </View>
                  </View>
                  
                  <View style={styles.feature}>
                    <Ionicons name="bulb" size={20} color="#FF4C8B" />
                    <View style={styles.featureTextContainer}>
                      <Text style={styles.featureTitle}>Expert Insights</Text>
                      <Text style={styles.featureText}>Gain insights from security experts and thought leaders</Text>
                    </View>
                  </View>
                </View>
              </View>
            </View>

            {/* Signup Card */}
            <View style={styles.card}>
              <LinearGradient
                colors={['#6543CC', '#8A58FC']}
                start={{x: 0, y: 0}}
                end={{x: 1, y: 0}}
                style={styles.cardHeader}
              >
                <Ionicons name="notifications" size={20} color="#FFFFFF" />
                <Text style={styles.cardTitle}>Join the Cyber Brief Community</Text>
              </LinearGradient>
              
              <View style={styles.cardContent}>
                <View style={styles.tabs}>
                  <TouchableOpacity 
                    style={[styles.tab, activeSection === 'subscribe' && styles.activeTab]}
                    onPress={() => setActiveSection('subscribe')}
                  >
                    <Ionicons name="checkmark" size={18} color={activeSection === 'subscribe' ? "#FFFFFF" : "#AAAAAA"} />
                    <Text style={[styles.tabText, activeSection === 'subscribe' && styles.activeTabText]}>Subscribe</Text>
                  </TouchableOpacity>
                  
                  <TouchableOpacity 
                    style={[styles.tab, activeSection === 'unsubscribe' && styles.activeTab]}
                    onPress={() => setActiveSection('unsubscribe')}
                  >
                    <Ionicons name="close" size={18} color={activeSection === 'unsubscribe' ? "#FFFFFF" : "#AAAAAA"} />
                    <Text style={[styles.tabText, activeSection === 'unsubscribe' && styles.activeTabText]}>Unsubscribe</Text>
                  </TouchableOpacity>
                </View>

                <View style={styles.form}>
                  <View style={styles.inputContainer}>
                    <Ionicons name="mail" size={20} color="#AAAAAA" style={styles.inputIcon} />
                    <TextInput
                      style={styles.input}
                      placeholder="Enter your email address"
                      placeholderTextColor="#AAAAAA"
                      value={email}
                      onChangeText={setEmail}
                      keyboardType="email-address"
                      autoCapitalize="none"
                      editable={!isSubmitting}
                      onSubmitEditing={() => activeSection === 'subscribe' ? handleSubscribe() : handleUnsubscribe()}
                    />
                  </View>

                  {activeSection === 'subscribe' ? (
                    <TouchableOpacity 
                      style={styles.submitButton}
                      onPress={handleSubscribe}
                      disabled={isSubmitting}
                    >
                      {isSubmitting ? (
                        <View style={styles.buttonContent}>
                          <ActivityIndicator size="small" color="#FFFFFF" />
                          <Text style={styles.submitButtonText}>Subscribing...</Text>
                        </View>
                      ) : (
                        <View style={styles.buttonContent}>
                          <Ionicons name="rocket" size={20} color="#FFFFFF" />
                          <Text style={styles.submitButtonText}>Subscribe to Daily Updates</Text>
                        </View>
                      )}
                    </TouchableOpacity>
                  ) : (
                    <TouchableOpacity 
                      style={[styles.submitButton, styles.unsubscribeButton]}
                      onPress={handleUnsubscribe}
                      disabled={isSubmitting}
                    >
                      {isSubmitting ? (
                        <View style={styles.buttonContent}>
                          <ActivityIndicator size="small" color="#FFFFFF" />
                          <Text style={styles.submitButtonText}>Processing...</Text>
                        </View>
                      ) : (
                        <View style={styles.buttonContent}>
                          <Ionicons name="close" size={20} color="#FFFFFF" />
                          <Text style={styles.submitButtonText}>Unsubscribe from Updates</Text>
                        </View>
                      )}
                    </TouchableOpacity>
                  )}
                </View>

                {showStatusMsg && (
                  <View style={[
                    styles.statusMsg,
                    isError ? styles.errorMsg : styles.successMsg
                  ]}>
                    <Ionicons 
                      name={isError ? "alert-circle" : "checkmark-circle"} 
                      size={20} 
                      color={isError ? "#FF4E4E" : "#2EBB77"} 
                    />
                    <Text style={styles.statusText}>{statusMsg}</Text>
                  </View>
                )}
              </View>
            </View>

            {/* Info Card */}
            <View style={styles.card}>
              <LinearGradient
                colors={['#6543CC', '#8A58FC']}
                start={{x: 0, y: 0}}
                end={{x: 1, y: 0}}
                style={styles.cardHeader}
              >
                <Ionicons name="information-circle" size={20} color="#FFFFFF" />
                <Text style={styles.cardTitle}>About Our Newsletter</Text>
              </LinearGradient>
              
              <View style={styles.cardContent}>
                <Text style={styles.cardText}>
                  The Daily Cyber Brief is sent every weekday morning. We respect your privacy
                  and will never share your email address with third parties. Each newsletter includes
                  an unsubscribe link for easy opt-out at any time.
                </Text>
                <Text style={styles.cardText}>
                  Our team of security experts curates the most important cybersecurity news and
                  practical advice to help you protect your digital life and stay informed about
                  the evolving threat landscape.
                </Text>
              </View>
            </View>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0B0C15',
  },
  keyboardView: {
    flex: 1,
  },
  scrollView: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    paddingTop: 20,
    paddingBottom: 20,
  },
  logoContainer: {
    marginBottom: 15,
  },
  logoBackground: {
    width: 70,
    height: 70,
    borderRadius: 35,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#6543CC',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.5,
    shadowRadius: 15,
    elevation: 10,
  },
  headerTitle: {
    fontSize: 26,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 14,
    color: '#9DA8B9',
    textAlign: 'center',
    maxWidth: '80%',
  },
  mainContent: {
    padding: 20,
  },
  card: {
    backgroundColor: '#171A23',
    borderRadius: 15,
    overflow: 'hidden',
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#2A2C3D',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.4,
    shadowRadius: 24,
    elevation: 10,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    gap: 10,
  },
  cardTitle: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  cardContent: {
    padding: 20,
  },
  cardText: {
    color: '#9DA8B9',
    fontSize: 14,
    lineHeight: 22,
    marginBottom: 15,
  },
  features: {
    marginTop: 10,
  },
  feature: {
    flexDirection: 'row',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 10,
    padding: 15,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.05)',
  },
  featureTextContainer: {
    marginLeft: 15,
    flex: 1,
  },
  featureTitle: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 5,
  },
  featureText: {
    color: '#9DA8B9',
    fontSize: 14,
    lineHeight: 20,
  },
  tabs: {
    flexDirection: 'row',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 8,
    padding: 4,
    marginBottom: 20,
  },
  tab: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 6,
    gap: 8,
  },
  activeTab: {
    backgroundColor: '#6543CC',
  },
  tabText: {
    color: '#AAAAAA',
    fontSize: 14,
  },
  activeTabText: {
    color: '#FFFFFF',
    fontWeight: '600',
  },
  form: {
    marginBottom: 20,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#2A2C3D',
    marginBottom: 15,
  },
  inputIcon: {
    padding: 15,
  },
  input: {
    flex: 1,
    height: 50,
    color: '#FFFFFF',
    fontSize: 16,
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
  },
  submitButton: {
    backgroundColor: '#6543CC',
    borderRadius: 8,
    padding: 15,
  },
  unsubscribeButton: {
    backgroundColor: '#454545',
  },
  submitButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'center',
  },
  statusMsg: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    borderRadius: 8,
    marginTop: 15,
    opacity: 1,
    transform: [{ translateY: 0 }],
    transition: 'opacity 0.3s, transform 0.3s',
  },
  successMsg: {
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
    borderLeftWidth: 3,
    borderLeftColor: '#2EBB77',
  },
  errorMsg: {
    backgroundColor: 'rgba(255, 78, 78, 0.1)',
    borderLeftWidth: 3,
    borderLeftColor: '#FF4E4E',
  },
  statusText: {
    color: '#FFFFFF',
    marginLeft: 10,
    flex: 1,
  },
});

export default NewsletterScreen;
</file>

<file path="src/screens/tools/ResourcesScreen.js">
// src/screens/tools/ResourcesScreen.js
import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  TextInput,
  FlatList,
  TouchableOpacity,
  StyleSheet,
  SafeAreaView,
  StatusBar,
  RefreshControl,
  ActivityIndicator,
  useWindowDimensions,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import ResourcesCategoriesComponent from '../../components/ResourcesCategoriesComponent';
import ResourceItemComponent from '../../components/ResourceItemComponent';
import ResourceRandomModal from '../../components/ResourceRandomModal';
import useResources from '../../hooks/useResources';

const ResourcesScreen = () => {
  // Use our custom hook for resources management
  const {
    searchTerm,
    setSearchTerm,
    selectedCategory,
    setSelectedCategory,
    showCertCategories,
    filteredResources,
    loading,
    sortAlphabetically,
    randomResource,
    loadingRandom,
    loadResources,
    getRandomResource,
    toggleCertCategories,
    toggleSort,
    clearFilters,
  } = useResources('all');
  
  // Local UI state
  const [viewMode, setViewMode] = useState('grid'); // 'grid' or 'list'
  const [showRandomModal, setShowRandomModal] = useState(false);
  
  // Get window dimensions to adjust layout
  const { width } = useWindowDimensions();
  const isWideScreen = width >= 768;
  
  // Handle category selection
  const handleCategorySelect = useCallback((categoryId) => {
    setSelectedCategory(categoryId);
  }, [setSelectedCategory]);
  
  // Toggle view mode (grid/list)
  const toggleViewMode = useCallback(() => {
    setViewMode(prev => (prev === 'grid' ? 'list' : 'grid'));
  }, []);
  
  // Handle showing random resource modal
  const handleGetRandomResource = useCallback(() => {
    const resource = getRandomResource();
    if (resource) {
      setShowRandomModal(true);
    }
  }, [getRandomResource]);
  
  // Handle refresh (pull to refresh)
  const handleRefresh = useCallback(() => {
    loadResources(selectedCategory);
  }, [loadResources, selectedCategory]);
  
  // Render resource item
  const renderResourceItem = useCallback(({ item }) => (
    <ResourceItemComponent 
      resource={item} 
      listMode={viewMode === 'list'}
    />
  ), [viewMode]);
  
  // Render empty state when no resources match the search
  const renderEmptyState = useCallback(() => (
    <View style={styles.emptyContainer}>
      <Ionicons name="search" size={50} color="#6543CC" style={styles.emptyIcon} />
      <Text style={styles.emptyTitle}>No resources found</Text>
      <Text style={styles.emptyMessage}>
        Try adjusting your search or selecting a different category
      </Text>
      <TouchableOpacity 
        style={styles.resetButton}
        onPress={clearFilters}
      >
        <Text style={styles.resetButtonText}>Reset Filters</Text>
      </TouchableOpacity>
    </View>
  ), [clearFilters]);
  
  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="light-content" />
      
      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Resources Hub</Text>
        <Text style={styles.headerSubtitle}>
          Find tools and learning materials for certifications
        </Text>
      </View>
      
      {/* Search Bar */}
      <View style={styles.searchContainer}>
        <Ionicons name="search" size={20} color="#AAAAAA" style={styles.searchIcon} />
        <TextInput
          style={styles.searchInput}
          placeholder="Search resources..."
          placeholderTextColor="#AAAAAA"
          value={searchTerm}
          onChangeText={setSearchTerm}
          returnKeyType="search"
          autoCapitalize="none"
        />
        {searchTerm ? (
          <TouchableOpacity style={styles.clearButton} onPress={() => setSearchTerm('')}>
            <Ionicons name="close-circle" size={20} color="#AAAAAA" />
          </TouchableOpacity>
        ) : null}
      </View>
      
      {/* Categories */}
      <ResourcesCategoriesComponent
        selectedCategory={selectedCategory}
        onSelectCategory={handleCategorySelect}
        showCerts={showCertCategories}
        onToggleCerts={toggleCertCategories}
      />
      
      {/* Action Buttons */}
      <View style={styles.actionBar}>
        <View style={styles.resultsCount}>
          <Text style={styles.resultsText}>
            {filteredResources.length} resources
          </Text>
        </View>
        
        <View style={styles.actionButtons}>
          <TouchableOpacity 
            style={[styles.actionButton, sortAlphabetically && styles.activeActionButton]} 
            onPress={toggleSort}
          >
            <Ionicons 
              name={sortAlphabetically ? "text" : "text-outline"} 
              size={22} 
              color={sortAlphabetically ? "#FFFFFF" : "#AAAAAA"} 
            />
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={styles.actionButton} 
            onPress={toggleViewMode}
          >
            <Ionicons 
              name={viewMode === 'grid' ? "list-outline" : "grid-outline"} 
              size={22} 
              color="#AAAAAA" 
            />
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={[styles.actionButton, styles.randomButton]} 
            onPress={handleGetRandomResource}
            disabled={loadingRandom || filteredResources.length === 0}
          >
            {loadingRandom ? (
              <ActivityIndicator size="small" color="#FFFFFF" />
            ) : (
              <Ionicons name="shuffle-outline" size={22} color="#FFFFFF" />
            )}
          </TouchableOpacity>
        </View>
      </View>
      
      {/* Resources List */}
      <FlatList
        data={filteredResources}
        renderItem={renderResourceItem}
        keyExtractor={(item, index) => `${item.name}-${index}`}
        contentContainerStyle={[
          styles.resourcesList,
          filteredResources.length === 0 && styles.emptyList
        ]}
        numColumns={viewMode === 'grid' && isWideScreen ? 2 : 1}
        key={viewMode + (isWideScreen ? '-wide' : '-narrow')} // Force re-render when changing viewMode or screen size
        ItemSeparatorComponent={
          viewMode === 'list' ? () => <View style={styles.separator} /> : null
        }
        refreshControl={
          <RefreshControl
            refreshing={loading}
            onRefresh={handleRefresh}
            tintColor="#6543CC"
            colors={["#6543CC"]}
          />
        }
        ListEmptyComponent={renderEmptyState}
      />
      
      {/* Random Resource Modal */}
      <ResourceRandomModal
        visible={showRandomModal}
        resource={randomResource}
        onClose={() => setShowRandomModal(false)}
        onGetAnother={handleGetRandomResource}
        isLoading={loadingRandom}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  header: {
    padding: 15,
    backgroundColor: '#1A1A1A',
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 5,
  },
  headerSubtitle: {
    fontSize: 14,
    color: '#AAAAAA',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#1E1E1E',
    margin: 15,
    borderRadius: 10,
    paddingHorizontal: 15,
    height: 50,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  searchIcon: {
    marginRight: 10,
  },
  searchInput: {
    flex: 1,
    height: '100%',
    color: '#FFFFFF',
    fontSize: 16,
  },
  clearButton: {
    padding: 5,
  },
  actionBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 15,
    marginBottom: 10,
  },
  resultsCount: {
    backgroundColor: 'rgba(101, 67, 204, 0.1)',
    paddingVertical: 4,
    paddingHorizontal: 12,
    borderRadius: 15,
    borderWidth: 1,
    borderColor: 'rgba(101, 67, 204, 0.3)',
  },
  resultsText: {
    color: '#6543CC',
    fontSize: 12,
    fontWeight: '500',
  },
  actionButtons: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  actionButton: {
    width: 38,
    height: 38,
    borderRadius: 19,
    backgroundColor: '#1E1E1E',
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 10,
  },
  activeActionButton: {
    backgroundColor: '#6543CC',
  },
  randomButton: {
    backgroundColor: '#6543CC',
  },
  resourcesList: {
    padding: 15,
    paddingTop: 5,
  },
  emptyList: {
    flex: 1,
    justifyContent: 'center',
  },
  separator: {
    height: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  emptyIcon: {
    marginBottom: 20,
    opacity: 0.5,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 10,
  },
  emptyMessage: {
    fontSize: 14,
    color: '#AAAAAA',
    textAlign: 'center',
    marginBottom: 20,
  },
  resetButton: {
    backgroundColor: '#6543CC',
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  resetButtonText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
});

export default ResourcesScreen;
</file>

<file path="src/screens/tools/ScenarioSphereScreen.js">
// src/screens/tools/ScenarioSphereScreen.js
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  TextInput,
  ActivityIndicator,
  FlatList,
  Modal,
  SafeAreaView,
  Dimensions
} from 'react-native';
import { Picker } from '@react-native-picker/picker';
import Slider from '@react-native-community/slider';
import { Ionicons } from '@expo/vector-icons';
import { StatusBar } from 'expo-status-bar';
import { useToast } from 'react-native-toast-notifications';
import { streamScenario, streamScenarioQuestions } from '../../api/scenarioService';

// Sample attack types - in a real app, you'd import this from a separate file
const ATTACK_TYPES = [
  "AI Activation Exploit",
  "AI Algorithm Manipulation",
  "AI Data Leakage",
  "AI Data Poisoning",
  "Backdoor",
  "Brute Force",
  "Buffer Overflow",
  "Business Email Compromise",
  "Cloud Service Abuse",
  "Command Injection",
  "Cross-Site Request Forgery",
  "Cross-Site Scripting",
  "Cryptojacking",
  "DDoS Attack",
  "DNS Hijacking",
  "DNS Spoofing",
  "Data Exfiltration",
  "Deepfake",
  "Drive-by Download",
  "Eavesdropping",
  "Evil Twin Attack",
  "File Inclusion",
  "Firmware Attack",
  "GDPR Violation",
  "Honey Trap",
  "IMSI Catcher",
  "Identity Theft",
  "Insider Threat",
  "IoT Botnet",
  "Keylogger",
  "LDAP Injection",
  "LLM Prompt Injection",
  "Logic Bomb",
  "MFA Bypass",
  "MitM Attack",
  "OAuth Token Theft",
  "Password Spraying",
  "Phishing",
  "Ping of Death",
  "Privilege Escalation",
  "Ransomware",
  "Remote Code Execution",
  "Reverse Shell",
  "Rootkit",
  "SAML Attack",
  "SQL Injection",
  "Sandbox Escape",
  "Session Hijacking",
  "Side-Channel Attack",
  "Social Engineering",
  "Software Supply Chain",
  "Spear Phishing",
  "Spyware",
  "Typosquatting",
  "USB Drop Attack",
  "Vishing",
  "Virtual Host Confusion",
  "Watering Hole",
  "Web Shell",
  "Zero-Day Exploit"
];

const ScenarioSphereScreen = () => {
  const [isGenerating, setIsGenerating] = useState(false);
  const [industry, setIndustry] = useState("Finance");
  const [attackType, setAttackType] = useState("");
  const [skillLevel, setSkillLevel] = useState("Script Kiddie");
  const [threatIntensity, setThreatIntensity] = useState(50);

  const [scenarioText, setScenarioText] = useState("");
  const [interactiveQuestions, setInteractiveQuestions] = useState([]);
  const [userAnswers, setUserAnswers] = useState({});
  const [feedback, setFeedback] = useState({});

  const [suggestions, setSuggestions] = useState([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [showAllSuggestions, setShowAllSuggestions] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  const [scoreCounter, setScoreCounter] = useState(0);

  const [outputExpanded, setOutputExpanded] = useState(true);
  const [questionsExpanded, setQuestionsExpanded] = useState(true);
  const [generationComplete, setGenerationComplete] = useState(false);
  const [scenarioGenerated, setScenarioGenerated] = useState(false);

  const toast = useToast();
  const scrollViewRef = useRef();
  const scenarioOutputRef = useRef();

  const handleAttackTypeChange = (text) => {
    setAttackType(text);
    setShowAllSuggestions(false);
    setErrorMessage("");

    if (text.length > 0) {
      const filteredSuggestions = ATTACK_TYPES.filter(
        (attack) => attack.toLowerCase().includes(text.toLowerCase())
      );
      setSuggestions(filteredSuggestions);
      setShowSuggestions(true);
    } else {
      setSuggestions([]);
      setShowSuggestions(false);
    }
  };

  const selectSuggestion = (suggestion) => {
    setAttackType(suggestion);
    setShowSuggestions(false);
  };

  const handleGenerateScenario = async () => {
    if (!attackType.trim()) {
      setErrorMessage("Please enter the Type of Attack");
      toast.show("Please enter the Type of Attack", {
        type: 'danger',
        duration: 3000,
      });
      return;
    }

    setErrorMessage("");
    setIsGenerating(true);
    setScenarioText("");
    setInteractiveQuestions([]);
    setUserAnswers({});
    setFeedback({});
    setScoreCounter(0);
    setScenarioGenerated(true);
    setGenerationComplete(false);

    try {
      // Start streaming the scenario
      const response = await streamScenario(
        industry,
        attackType,
        skillLevel,
        threatIntensity
      );

      let accumulatedText = '';
      
      // Simulate streaming by updating the text in chunks
      const paragraphs = response.split('\n\n');
      
      for (const paragraph of paragraphs) {
        accumulatedText += paragraph + '\n\n';
        setScenarioText(accumulatedText);
        
        // Simulate delay for streaming effect
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Scroll to bottom as text comes in
        if (scenarioOutputRef.current) {
          scenarioOutputRef.current.scrollToEnd({ animated: true });
        }
      }
      
      setGenerationComplete(true);
      
      // Now fetch the questions based on the scenario
      fetchQuestions(accumulatedText);
    } catch (error) {
      console.error('Error generating scenario:', error);
      setErrorMessage("An error occurred while generating the scenario");
      toast.show("Error generating scenario. Please try again.", {
        type: 'danger',
        duration: 3000,
      });
    } finally {
      setIsGenerating(false);
    }
  };

  const fetchQuestions = async (finalScenarioText) => {
    if (!finalScenarioText) return;

    try {
      const questions = await streamScenarioQuestions(finalScenarioText);
      
      if (Array.isArray(questions)) {
        const errorObj = questions.find(q => q.error);
        if (errorObj) {
          console.error("Error in questions generation:", errorObj.error);
          setErrorMessage(`Error generating questions: ${errorObj.error}`);
          toast.show(`Error generating questions: ${errorObj.error}`, {
            type: 'danger',
            duration: 3000,
          });
        } else if (questions.length === 3) {
          setInteractiveQuestions(questions);
        } else {
          console.error("Expected exactly 3 questions, but received:", questions);
          setErrorMessage("Unexpected number of questions received");
        }
      } else {
        console.error("Parsed questions are not in an array format.");
        setErrorMessage("Invalid format for interactive questions");
      }
    } catch (error) {
      console.error("Error fetching questions:", error);
      setErrorMessage("Error fetching questions");
      toast.show("Error fetching questions. Please try again.", {
        type: 'danger',
        duration: 3000,
      });
    }
  };

  const handleAnswerSelect = (questionIndex, selectedOption) => {
    // Already answered? do nothing
    if (Object.prototype.hasOwnProperty.call(userAnswers, questionIndex)) {
      return;
    }
    
    const question = interactiveQuestions[questionIndex];
    const isCorrect = selectedOption === question.correct_answer;

    setUserAnswers((prevAnswers) => ({
      ...prevAnswers,
      [questionIndex]: selectedOption,
    }));

    setFeedback((prevFeedback) => ({
      ...prevFeedback,
      [questionIndex]: {
        isCorrect,
        explanation: question.explanation,
      },
    }));
    
    if (isCorrect) {
      setScoreCounter(prev => prev + 1);
      toast.show("Correct answer!", {
        type: 'success',
        duration: 2000,
      });
    } else {
      toast.show("Incorrect answer.", {
        type: 'danger',
        duration: 2000,
      });
    }
  };

  // Calculate a rough progress percentage based on paragraph count
  const calculateStreamProgress = () => {
    if (!scenarioText) return 0;
    const paragraphs = scenarioText.split('\n\n').filter(p => p.trim().length > 0);
    return Math.min(Math.ceil((paragraphs.length / 5) * 100), 90);
  };

  const streamProgress = calculateStreamProgress();

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar style="light" />
      
      <View style={styles.header}>
        <Text style={styles.title}>
          <Ionicons name="shield" size={24} color="#6543cc" /> Scenario Sphere
        </Text>
        <Text style={styles.subtitle}>
          Immerse yourself in realistic cybersecurity scenarios and test your knowledge
        </Text>
        
        {errorMessage ? (
          <View style={styles.errorContainer}>
            <Ionicons name="warning" size={20} color="#ff4e4e" />
            <Text style={styles.errorText}>{errorMessage}</Text>
            <TouchableOpacity 
              style={styles.errorCloseButton}
              onPress={() => setErrorMessage("")}
            >
              <Ionicons name="close" size={18} color="#9da8b9" />
            </TouchableOpacity>
          </View>
        ) : null}
      </View>
      
      <ScrollView style={styles.scrollView}>
        <View style={styles.content}>
          <View style={styles.paramsCard}>
            <View style={styles.paramsHeader}>
              <View style={styles.paramsHeaderLeft}>
                <Ionicons name="settings" size={20} color="#6543cc" />
                <Text style={styles.paramsTitle}>Generation Parameters</Text>
              </View>
              
              <View style={styles.scoreCounter}>
                <Text style={styles.scoreValue}>
                  <Text style={styles.scoreHighlight}>{scoreCounter}</Text>/3
                </Text>
                <Text style={styles.scoreLabel}>Correct</Text>
              </View>
            </View>
            
            <View style={styles.paramsContent}>
              {/* Industry Picker */}
              <View style={styles.paramGroup}>
                <Text style={styles.paramLabel}>
                  <Ionicons name="business" size={16} color="#6543cc" /> Industry
                </Text>
                <View style={styles.pickerWrapper}>
                  <Picker
                    selectedValue={industry}
                    onValueChange={(value) => setIndustry(value)}
                    style={styles.picker}
                    dropdownIconColor="#6543cc"
                    itemStyle={styles.pickerItem}
                    enabled={!isGenerating}
                  >
                    <Picker.Item label="Finance" value="Finance" />
                    <Picker.Item label="Healthcare" value="Healthcare" />
                    <Picker.Item label="Retail" value="Retail" />
                    <Picker.Item label="Technology" value="Technology" />
                    <Picker.Item label="Energy" value="Energy" />
                    <Picker.Item label="Education" value="Education" />
                    <Picker.Item label="Supply Chain" value="Supply Chain" />
                    <Picker.Item label="Telecommunications" value="Telecommunications" />
                    <Picker.Item label="Pharmaceutical" value="Pharmaceutical" />
                    <Picker.Item label="Transportation" value="Transportation" />
                    <Picker.Item label="Cybersecurity Company" value="Cybersecurity Company" />
                    <Picker.Item label="Manufacturing" value="Manufacturing" />
                    <Picker.Item label="CYBERPUNK2077" value="CYBERPUNK2077" />
                  </Picker>
                </View>
              </View>
              
              {/* Attack Type Input */}
              <View style={styles.paramGroup}>
                <Text style={styles.paramLabel}>
                  <Ionicons name="skull" size={16} color="#6543cc" /> Attack Type
                </Text>
                <View style={styles.inputWrapper}>
                  <Ionicons name="search" size={20} color="#6543cc" style={styles.inputIcon} />
                  <TextInput
                    style={styles.textInput}
                    placeholder="Search or enter attack type..."
                    placeholderTextColor="#9da8b9"
                    value={attackType}
                    onChangeText={handleAttackTypeChange}
                    editable={!isGenerating}
                  />
                </View>
                
                {showSuggestions && suggestions.length > 0 && (
                  <View style={styles.suggestionsContainer}>
                    <FlatList
                      data={showAllSuggestions ? suggestions : suggestions.slice(0, 5)}
                      keyExtractor={(item) => item}
                      renderItem={({ item }) => (
                        <TouchableOpacity
                          style={styles.suggestionItem}
                          onPress={() => selectSuggestion(item)}
                        >
                          <Text style={styles.suggestionText}>{item}</Text>
                        </TouchableOpacity>
                      )}
                      style={styles.suggestionsList}
                    />
                    
                    {!showAllSuggestions && suggestions.length > 5 && (
                      <TouchableOpacity 
                        style={styles.showAllButton}
                        onPress={() => setShowAllSuggestions(true)}
                      >
                        <Ionicons name="chevron-down" size={16} color="#6543cc" />
                        <Text style={styles.showAllText}>
                          Show all options ({suggestions.length})
                        </Text>
                      </TouchableOpacity>
                    )}
                  </View>
                )}
              </View>
              
              {/* Skill Level Picker */}
              <View style={styles.paramGroup}>
                <Text style={styles.paramLabel}>
                  <Ionicons name="person" size={16} color="#6543cc" /> Attacker Skill Level
                </Text>
                <View style={styles.pickerWrapper}>
                  <Picker
                    selectedValue={skillLevel}
                    onValueChange={(value) => setSkillLevel(value)}
                    style={styles.picker}
                    dropdownIconColor="#6543cc"
                    itemStyle={styles.pickerItem}
                    enabled={!isGenerating}
                  >
                    <Picker.Item label="Script Kiddie" value="Script Kiddie" />
                    <Picker.Item label="Intermediate" value="Intermediate" />
                    <Picker.Item label="Advanced" value="Advanced" />
                    <Picker.Item label="APT" value="APT" />
                  </Picker>
                </View>
              </View>
              
              {/* Threat Intensity Slider */}
              <View style={styles.paramGroup}>
                <View style={styles.sliderLabelContainer}>
                  <Text style={styles.paramLabel}>
                    <Ionicons name="thermometer" size={16} color="#6543cc" /> Threat Intensity
                  </Text>
                  <View style={styles.intensityBadge}>
                    <Text style={styles.intensityValue}>{threatIntensity}</Text>
                  </View>
                </View>
                
                <Slider
                  style={styles.slider}
                  minimumValue={1}
                  maximumValue={100}
                  step={1}
                  value={threatIntensity}
                  onValueChange={(value) => setThreatIntensity(value)}
                  minimumTrackTintColor="#6543cc"
                  maximumTrackTintColor="#333333"
                  thumbTintColor="#6543cc"
                  disabled={isGenerating}
                />
                
                <View style={styles.sliderMarkers}>
                  <Text style={styles.sliderMarker}>Low</Text>
                  <Text style={styles.sliderMarker}>Medium</Text>
                  <Text style={styles.sliderMarker}>High</Text>
                </View>
              </View>
              
              {/* Generate Button */}
              <TouchableOpacity
                style={[styles.generateButton, isGenerating && styles.generateButtonDisabled]}
                onPress={handleGenerateScenario}
                disabled={isGenerating}
              >
                {isGenerating ? (
                  <View style={styles.buttonContent}>
                    <ActivityIndicator color="#fff" size="small" />
                    <Text style={styles.buttonText}>Generating...</Text>
                  </View>
                ) : (
                  <View style={styles.buttonContent}>
                    <Ionicons name="play" size={20} color="#fff" />
                    <Text style={styles.buttonText}>Generate Scenario</Text>
                  </View>
                )}
              </TouchableOpacity>
            </View>
          </View>
          
          {scenarioGenerated && (
            <View style={styles.results}>
              {/* Scenario Output Card */}
              <View style={styles.outputCard}>
                <TouchableOpacity 
                  style={styles.outputHeader}
                  onPress={() => setOutputExpanded(!outputExpanded)}
                >
                  <View style={styles.outputHeaderLeft}>
                    <Ionicons name="lock-closed" size={20} color="#6543cc" />
                    <Text style={styles.outputTitle}>Generated Scenario</Text>
                  </View>
                  
                  <View style={styles.outputControls}>
                    {!generationComplete && isGenerating && (
                      <View style={styles.progressContainer}>
                        <View style={styles.progressBar}>
                          <View 
                            style={[styles.progressFill, { width: `${streamProgress}%` }]}
                          />
                        </View>
                        <Text style={styles.progressLabel}>Generating...</Text>
                      </View>
                    )}
                    
                    <TouchableOpacity style={styles.toggleButton}>
                      <Ionicons 
                        name={outputExpanded ? "chevron-up" : "chevron-down"} 
                        size={20} 
                        color="#9da8b9" 
                      />
                    </TouchableOpacity>
                  </View>
                </TouchableOpacity>
                
                {outputExpanded && (
                  <ScrollView 
                    style={styles.outputContent}
                    ref={scenarioOutputRef}
                  >
                    {scenarioText ? (
                      <Text style={styles.scenarioText}>
                        {scenarioText}
                        {isGenerating && <Text style={styles.cursor}>|</Text>}
                      </Text>
                    ) : (
                      <View style={styles.placeholderContainer}>
                        <ActivityIndicator 
                          color="#6543cc" 
                          size="large"
                          animating={isGenerating}
                        />
                        <Text style={styles.placeholderText}>
                          Scenario will appear here...
                        </Text>
                      </View>
                    )}
                  </ScrollView>
                )}
              </View>
              
              {/* Questions Card */}
              {interactiveQuestions.length > 0 && (
                <View style={styles.questionsCard}>
                  <TouchableOpacity 
                    style={styles.questionsHeader}
                    onPress={() => setQuestionsExpanded(!questionsExpanded)}
                  >
                    <View style={styles.questionsHeaderLeft}>
                      <Ionicons name="help-circle" size={20} color="#6543cc" />
                      <Text style={styles.questionsTitle}>Knowledge Assessment</Text>
                    </View>
                    
                    <TouchableOpacity style={styles.toggleButton}>
                      <Ionicons 
                        name={questionsExpanded ? "chevron-up" : "chevron-down"} 
                        size={20} 
                        color="#9da8b9" 
                      />
                    </TouchableOpacity>
                  </TouchableOpacity>
                  
                  {questionsExpanded && (
                    <View style={styles.questionsContent}>
                      {Object.keys(feedback).length === interactiveQuestions.length && (
                        <View style={styles.assessmentComplete}>
                          <Ionicons name="checkmark-circle" size={24} color="#2ebb77" />
                          <View style={styles.assessmentResults}>
                            <Text style={styles.completionMessage}>Assessment Complete</Text>
                            <Text style={styles.scoreMessage}>
                              You scored {scoreCounter} out of {interactiveQuestions.length} correct
                            </Text>
                          </View>
                        </View>
                      )}
                      
                      {interactiveQuestions.map((question, index) => {
                        const questionFeedback = feedback[index];
                        const isCorrect = questionFeedback?.isCorrect;
                        
                        return (
                          <View key={index} style={styles.questionCard}>
                            <View style={styles.questionHeader}>
                              <Text style={styles.questionNumber}>Question {index + 1}</Text>
                              {questionFeedback && (
                                <View style={[
                                  styles.questionStatus,
                                  isCorrect ? styles.correctStatus : styles.incorrectStatus
                                ]}>
                                  <Ionicons 
                                    name={isCorrect ? "checkmark" : "close"} 
                                    size={16} 
                                    color={isCorrect ? "#2ebb77" : "#ff4e4e"} 
                                  />
                                  <Text style={[
                                    styles.statusText,
                                    isCorrect ? styles.correctText : styles.incorrectText
                                  ]}>
                                    {isCorrect ? "Correct" : "Incorrect"}
                                  </Text>
                                </View>
                              )}
                            </View>
                            
                            <Text style={styles.questionText}>{question.question}</Text>
                            
                            <View style={styles.optionsContainer}>
                              {Object.entries(question.options).map(([optionLetter, optionText]) => {
                                const isSelected = userAnswers[index] === optionLetter;
                                const showCorrect = questionFeedback && question.correct_answer === optionLetter;
                                const showIncorrect = questionFeedback && isSelected && !isCorrect;
                                
                                return (
                                  <TouchableOpacity
                                    key={optionLetter}
                                    style={[
                                      styles.optionButton,
                                      isSelected && styles.selectedOption,
                                      showCorrect && styles.correctOption,
                                      showIncorrect && styles.incorrectOption
                                    ]}
                                    onPress={() => handleAnswerSelect(index, optionLetter)}
                                    disabled={Object.prototype.hasOwnProperty.call(userAnswers, index)}
                                  >
                                    <View style={[
                                      styles.optionLetter,
                                      showCorrect && styles.correctLetter,
                                      showIncorrect && styles.incorrectLetter
                                    ]}>
                                      <Text style={styles.optionLetterText}>{optionLetter}</Text>
                                    </View>
                                    
                                    <Text style={styles.optionText}>{optionText}</Text>
                                    
                                    {showCorrect && (
                                      <Ionicons name="checkmark" size={20} color="#2ebb77" style={styles.optionIcon} />
                                    )}
                                    {showIncorrect && (
                                      <Ionicons name="close" size={20} color="#ff4e4e" style={styles.optionIcon} />
                                    )}
                                  </TouchableOpacity>
                                );
                              })}
                            </View>
                            
                            {questionFeedback && (
                              <View style={styles.feedbackContainer}>
                                <Ionicons name="bulb" size={20} color="#ffc107" style={styles.feedbackIcon} />
                                <Text style={styles.feedbackExplanation}>
                                  {questionFeedback.explanation}
                                </Text>
                              </View>
                            )}
                          </View>
                        );
                      })}
                    </View>
                  )}
                </View>
              )}
            </View>
          )}
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0b0c15',
  },
  header: {
    backgroundColor: '#171a23',
    borderRadius: 15,
    margin: 15,
    marginBottom: 10,
    padding: 20,
    borderWidth: 1,
    borderColor: '#2a2c3d',
    position: 'relative',
    overflow: 'hidden',
    borderTopWidth: 4,
    borderTopColor: '#6543cc',
  },
  title: {
    fontSize: 26,
    fontWeight: 'bold',
    color: '#e2e2e2',
    textAlign: 'center',
    marginBottom: 5,
  },
  subtitle: {
    fontSize: 14,
    color: '#9da8b9',
    textAlign: 'center',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 78, 78, 0.1)',
    borderWidth: 1,
    borderColor: 'rgba(255, 78, 78, 0.3)',
    borderRadius: 10,
    padding: 12,
    marginTop: 15,
  },
  errorText: {
    color: '#ff4e4e',
    marginLeft: 10,
    flex: 1,
    fontSize: 14,
  },
  errorCloseButton: {
    padding: 5,
  },
  scrollView: {
    flex: 1,
  },
  content: {
    padding: 15,
    paddingTop: 0,
  },
  paramsCard: {
    backgroundColor: '#171a23',
    borderRadius: 15,
    borderWidth: 1,
    borderColor: '#2a2c3d',
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.4,
    shadowRadius: 24,
    elevation: 5,
    marginBottom: 20,
  },
  paramsHeader: {
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#2a2c3d',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  paramsHeaderLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
  },
  paramsTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#e2e2e2',
  },
  scoreCounter: {
    alignItems: 'center',
  },
  scoreValue: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#e2e2e2',
  },
  scoreHighlight: {
    color: '#6543cc',
  },
  scoreLabel: {
    fontSize: 12,
    color: '#9da8b9',
  },
  paramsContent: {
    padding: 15,
  },
  paramGroup: {
    marginBottom: 15,
  },
  paramLabel: {
    fontSize: 14,
    color: '#9da8b9',
    marginBottom: 8,
    fontWeight: '500',
  },
  pickerWrapper: {
    borderWidth: 1,
    borderColor: '#2a2c3d',
    borderRadius: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    overflow: 'hidden',
  },
  picker: {
    color: '#e2e2e2',
    height: 50,
  },
  pickerItem: {
    fontSize: 16,
    color: '#e2e2e2',
  },
  inputWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#2a2c3d',
    borderRadius: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    paddingHorizontal: 15,
  },
  inputIcon: {
    marginRight: 10,
  },
  textInput: {
    flex: 1,
    color: '#e2e2e2',
    height: 50,
    fontSize: 16,
  },
  suggestionsContainer: {
    backgroundColor: '#171a23',
    borderWidth: 1,
    borderColor: '#2a2c3d',
    borderRadius: 8,
    marginTop: 5,
    maxHeight: 200,
    zIndex: 1,
  },
  suggestionsList: {
    padding: 5,
  },
  suggestionItem: {
    padding: 10,
    borderRadius: 5,
  },
  suggestionText: {
    color: '#e2e2e2',
    fontSize: 14,
  },
  showAllButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 10,
    borderTopWidth: 1,
    borderTopColor: '#2a2c3d',
    gap: 5,
  },
  showAllText: {
    color: '#6543cc',
    fontSize: 14,
  },
  sliderLabelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  intensityBadge: {
    backgroundColor: '#6543cc',
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
  },
  intensityValue: {
    color: 'white',
    fontSize: 12,
    fontWeight: 'bold',
  },
  slider: {
    width: '100%',
    height: 40,
  },
  sliderMarkers: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  sliderMarker: {
    fontSize: 12,
    color: '#9da8b9',
  },
  generateButton: {
    backgroundColor: '#6543cc',
    borderRadius: 8,
    paddingVertical: 12,
    paddingHorizontal: 20,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 10,
    shadowColor: 'rgba(101, 67, 204, 0.3)',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 15,
    elevation: 5,
  },
  generateButtonDisabled: {
    backgroundColor: 'rgba(101, 67, 204, 0.5)',
    opacity: 0.7,
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  results: {
    gap: 20,
  },
  outputCard: {
    backgroundColor: '#171a23',
    borderRadius: 15,
    borderWidth: 1,
    borderColor: '#2a2c3d',
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.4,
    shadowRadius: 24,
    elevation: 5,
  },
  outputHeader: {
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#2a2c3d',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  outputHeaderLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
  },
  outputTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#e2e2e2',
  },
  outputControls: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
  },
  progressContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
  },
  progressBar: {
    width: 100,
    height: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 4,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#6543cc',
  },
  progressLabel: {
    fontSize: 12,
    color: '#9da8b9',
  },
  toggleButton: {
    width: 30,
    height: 30,
    borderRadius: 15,
    alignItems: 'center',
    justifyContent: 'center',
  },
  outputContent: {
    padding: 15,
    maxHeight: 300,
  },
  scenarioText: {
    color: '#e2e2e2',
    fontSize: 16,
    lineHeight: 24,
  },
  cursor: {
    color: '#6543cc',
    fontWeight: 'bold',
  },
  placeholderContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 30,
    gap: 15,
  },
  placeholderText: {
    color: '#9da8b9',
    fontSize: 16,
  },
  questionsCard: {
    backgroundColor: '#171a23',
    borderRadius: 15,
    borderWidth: 1,
    borderColor: '#2a2c3d',
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.4,
    shadowRadius: 24,
    elevation: 5,
    marginBottom: 20,
  },
  questionsHeader: {
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#2a2c3d',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  questionsHeaderLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
  },
  questionsTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#e2e2e2',
  },
  questionsContent: {
    padding: 15,
  },
  assessmentComplete: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
    borderWidth: 1,
    borderColor: 'rgba(46, 187, 119, 0.3)',
    borderRadius: 10,
    padding: 15,
    marginBottom: 20,
    gap: 15,
  },
  assessmentResults: {
    flex: 1,
  },
  completionMessage: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#e2e2e2',
    marginBottom: 5,
  },
  scoreMessage: {
    fontSize: 14,
    color: '#9da8b9',
  },
  questionCard: {
    backgroundColor: 'rgba(0, 0, 0, 0.15)',
    borderWidth: 1,
    borderColor: '#2a2c3d',
    borderRadius: 12,
    padding: 15,
    marginBottom: 20,
  },
  questionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  questionNumber: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#6543cc',
  },
  questionStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 20,
    gap: 5,
  },
  correctStatus: {
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
  },
  incorrectStatus: {
    backgroundColor: 'rgba(255, 78, 78, 0.1)',
  },
  statusText: {
    fontSize: 12,
    fontWeight: 'bold',
  },
  correctText: {
    color: '#2ebb77',
  },
  incorrectText: {
    color: '#ff4e4e',
  },
  questionText: {
    fontSize: 16,
    color: '#e2e2e2',
    lineHeight: 24,
    marginBottom: 20,
  },
  optionsContainer: {
    gap: 10,
  },
  optionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderWidth: 1,
    borderColor: '#2a2c3d',
    borderRadius: 10,
    padding: 12,
  },
  selectedOption: {
    borderColor: '#6543cc',
    backgroundColor: 'rgba(101, 67, 204, 0.1)',
  },
  correctOption: {
    borderColor: '#2ebb77',
    backgroundColor: 'rgba(46, 187, 119, 0.1)',
  },
  incorrectOption: {
    borderColor: '#ff4e4e',
    backgroundColor: 'rgba(255, 78, 78, 0.1)',
  },
  optionLetter: {
    width: 30,
    height: 30,
    backgroundColor: '#0b0c15',
    borderRadius: 15,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  correctLetter: {
    backgroundColor: '#2ebb77',
  },
  incorrectLetter: {
    backgroundColor: '#ff4e4e',
  },
  optionLetterText: {
    color: '#e2e2e2',
    fontWeight: 'bold',
    fontSize: 14,
  },
  optionText: {
    flex: 1,
    color: '#e2e2e2',
    fontSize: 15,
    lineHeight: 22,
  },
  optionIcon: {
    marginLeft: 10,
  },
  feedbackContainer: {
    flexDirection: 'row',
    backgroundColor: 'rgba(255, 193, 7, 0.05)',
    borderWidth: 1,
    borderColor: 'rgba(255, 193, 7, 0.2)',
    borderRadius: 10,
    padding: 12,
    marginTop: 15,
    gap: 12,
  },
  feedbackIcon: {
    marginTop: 2,
  },
  feedbackExplanation: {
    flex: 1,
    fontSize: 14,
    color: '#9da8b9',
    lineHeight: 22,
  },
});

export default ScenarioSphereScreen;
</file>

<file path="src/screens/tools/XploitCraftScreen.js">
// src/screens/tools/XploitCraftScreen.js
import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  SafeAreaView,
  Image
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { StatusBar } from 'expo-status-bar';
import * as Clipboard from 'expo-clipboard';
import { useToast } from 'react-native-toast-notifications';
import { generatePayload } from '../../api/xploitService';

const XploitCraftScreen = () => {
  const [vulnerability, setVulnerability] = useState('');
  const [evasionTechnique, setEvasionTechnique] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [generatedPayload, setGeneratedPayload] = useState(null);
  
  const scrollViewRef = useRef();
  const toast = useToast();

  const handleGeneratePayload = async () => {
    if (!vulnerability.trim()) {
      toast.show('Please enter a vulnerability', {
        type: 'danger',
        duration: 3000,
      });
      return;
    }

    setIsLoading(true);
    setGeneratedPayload(null);

    try {
      const result = await generatePayload(vulnerability, evasionTechnique, true);
      
      // Parse the result if it's in a usable format
      if (typeof result === 'string') {
        // If the API just returns a string
        setGeneratedPayload({
          code_examples: [
            { 
              title: 'Payload', 
              code: result 
            }
          ],
          explanations: [
            {
              title: 'Explanation',
              content: 'Payload generated successfully.'
            }
          ]
        });
      } else if (typeof result === 'object') {
        // If the API returns a structured object
        setGeneratedPayload(result);
      }
      
      // Scroll to bottom to show results
      setTimeout(() => {
        if (scrollViewRef.current) {
          scrollViewRef.current.scrollToEnd({ animated: true });
        }
      }, 300);
      
    } catch (error) {
      console.error('Error generating payload:', error);
      toast.show('Error generating payload. Please try again.', {
        type: 'danger',
        duration: 3000,
      });
    } finally {
      setIsLoading(false);
    }
  };

  const copyToClipboard = async (text) => {
    try {
      await Clipboard.setStringAsync(text);
      toast.show('Copied to clipboard!', {
        type: 'success',
        duration: 2000,
      });
    } catch (error) {
      console.error('Failed to copy:', error);
      toast.show('Failed to copy to clipboard', {
        type: 'danger',
        duration: 3000,
      });
    }
  };

  const copyAllToClipboard = async () => {
    if (!generatedPayload) return;
    
    try {
      let allText = '';
      
      // Add code examples
      if (generatedPayload.code_examples && generatedPayload.code_examples.length > 0) {
        generatedPayload.code_examples.forEach(example => {
          allText += `### ${example.title} ###\n\n${example.code}\n\n`;
        });
      }
      
      // Add explanations
      if (generatedPayload.explanations && generatedPayload.explanations.length > 0) {
        generatedPayload.explanations.forEach(explanation => {
          allText += `### ${explanation.title} ###\n\n${explanation.content}\n\n`;
        });
      }
      
      await Clipboard.setStringAsync(allText);
      toast.show('All content copied to clipboard!', {
        type: 'success',
        duration: 2000,
      });
    } catch (error) {
      console.error('Failed to copy all:', error);
      toast.show('Failed to copy content', {
        type: 'danger',
        duration: 3000,
      });
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar style="light" />
      
      {/* Logo and Title */}
      <View style={styles.headerContainer}>
        <Text style={styles.title}>XploitCraft</Text>
      </View>
      
      <ScrollView 
        style={styles.scrollView}
        ref={scrollViewRef}
        contentContainerStyle={styles.scrollViewContent}
      >
        {/* Input Fields */}
        <View style={styles.inputContainer}>
          <TextInput
            style={styles.input}
            placeholder="Enter Vulnerability or Exploit"
            placeholderTextColor="#888"
            value={vulnerability}
            onChangeText={setVulnerability}
            editable={!isLoading}
          />
          
          <TextInput
            style={styles.input}
            placeholder="Enter Evasion Technique or Delivery Method"
            placeholderTextColor="#888"
            value={evasionTechnique}
            onChangeText={setEvasionTechnique}
            editable={!isLoading}
          />
        </View>
        
        {/* Generate Button */}
        <View style={styles.buttonContainer}>
          <TouchableOpacity
            style={[styles.generateButton, isLoading && styles.generateButtonDisabled]}
            onPress={handleGeneratePayload}
            disabled={isLoading}
          >
            {isLoading ? (
              <View style={styles.buttonContent}>
                <ActivityIndicator color="#fff" size="small" />
                <Text style={styles.buttonText}>Generating...</Text>
              </View>
            ) : (
              <Text style={styles.buttonText}>Generate Payload</Text>
            )}
          </TouchableOpacity>
        </View>
        
        {/* Results Container */}
        {generatedPayload && (
          <View style={styles.resultsContainer}>
            {/* Code Examples Section */}
            {generatedPayload.code_examples && generatedPayload.code_examples.length > 0 && (
              <View style={styles.sectionContainer}>
                <Text style={styles.sectionTitle}>Code Examples</Text>
                
                {generatedPayload.code_examples.map((example, index) => (
                  <View key={`code-${index}`} style={styles.codeBlock}>
                    <View style={styles.codeHeader}>
                      <Text style={styles.codeTitle}>{example.title}</Text>
                      <TouchableOpacity
                        style={styles.copyButton}
                        onPress={() => copyToClipboard(example.code)}
                      >
                        <Ionicons name="copy-outline" size={16} color="#fff" />
                        <Text style={styles.copyText}>Copy</Text>
                      </TouchableOpacity>
                    </View>
                    <ScrollView style={styles.codeContent}>
                      <Text style={styles.codeText}>{example.code}</Text>
                    </ScrollView>
                  </View>
                ))}
              </View>
            )}
            
            {/* Explanations Section */}
            {generatedPayload.explanations && generatedPayload.explanations.length > 0 && (
              <View style={styles.sectionContainer}>
                <Text style={styles.sectionTitle}>Explanations</Text>
                
                {generatedPayload.explanations.map((explanation, index) => (
                  <View key={`exp-${index}`} style={styles.explanationBlock}>
                    <Text style={styles.explanationTitle}>{explanation.title}</Text>
                    <Text style={styles.explanationText}>{explanation.content}</Text>
                  </View>
                ))}
              </View>
            )}
            
            {/* Copy All Button */}
            <TouchableOpacity
              style={styles.copyAllButton}
              onPress={copyAllToClipboard}
            >
              <Ionicons name="copy-outline" size={20} color="#fff" />
              <Text style={styles.copyAllText}>Copy All Content</Text>
            </TouchableOpacity>
          </View>
        )}
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
  },
  headerContainer: {
    alignItems: 'center',
    paddingVertical: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    borderBottomWidth: 3,
    borderBottomColor: '#660000',
  },
  title: {
    fontSize: 36,
    fontWeight: 'bold',
    color: '#fff',
    textShadowColor: '#ff0000',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 10,
  },
  scrollView: {
    flex: 1,
  },
  scrollViewContent: {
    padding: 20,
  },
  inputContainer: {
    gap: 15,
    marginBottom: 20,
  },
  input: {
    backgroundColor: 'rgba(51, 51, 51, 0.8)',
    borderWidth: 2,
    borderColor: '#660000',
    borderRadius: 10,
    color: '#fff',
    padding: 15,
    fontSize: 16,
  },
  buttonContainer: {
    alignItems: 'center',
    marginBottom: 20,
  },
  generateButton: {
    backgroundColor: '#660000',
    borderRadius: 10,
    paddingVertical: 15,
    paddingHorizontal: 30,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 3,
    borderColor: '#000',
    minWidth: 200,
  },
  generateButtonDisabled: {
    backgroundColor: '#330000',
    opacity: 0.7,
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
    textShadowColor: '#000',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  resultsContainer: {
    backgroundColor: 'rgba(30, 30, 30, 0.92)',
    borderRadius: 10,
    borderWidth: 3,
    borderColor: '#660000',
    padding: 20,
    gap: 20,
  },
  sectionContainer: {
    gap: 15,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#ff0000',
    marginBottom: 10,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 0, 0, 0.3)',
    paddingBottom: 5,
  },
  codeBlock: {
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 10,
    borderWidth: 1,
    borderColor: 'rgba(255, 0, 0, 0.2)',
    overflow: 'hidden',
  },
  codeHeader: {
    backgroundColor: 'rgba(102, 0, 0, 0.7)',
    paddingVertical: 10,
    paddingHorizontal: 15,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  codeTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#fff',
  },
  copyButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    paddingVertical: 5,
    paddingHorizontal: 10,
    borderRadius: 5,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.3)',
    gap: 5,
  },
  copyText: {
    fontSize: 12,
    color: '#fff',
  },
  codeContent: {
    padding: 15,
    maxHeight: 250,
  },
  codeText: {
    fontFamily: 'monospace',
    fontSize: 14,
    color: '#e0e0e0',
  },
  explanationBlock: {
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 10,
    padding: 15,
    borderWidth: 1,
    borderColor: 'rgba(255, 0, 0, 0.2)',
  },
  explanationTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ff6666',
    marginBottom: 10,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 0, 0, 0.2)',
    paddingBottom: 5,
  },
  explanationText: {
    fontSize: 15,
    color: '#e0e0e0',
    lineHeight: 22,
  },
  copyAllButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#660000',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 10,
    borderWidth: 3,
    borderColor: '#000',
    alignSelf: 'center',
    marginTop: 10,
    gap: 10,
  },
  copyAllText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#fff',
  },
});

export default XploitCraftScreen;
</file>

<file path="src/screens/HomeScreen.js">
// src/screens/HomeScreen.js
import React, { useEffect } from 'react';
import { 
  View, 
  Text, 
  ScrollView, 
  StyleSheet, 
  TouchableOpacity, 
  RefreshControl
} from 'react-native';
import { useSelector, useDispatch } from 'react-redux';
import { Ionicons } from '@expo/vector-icons';
import { fetchUserData, claimDailyBonus } from '../store/slices/userSlice';

const HomeScreen = ({ navigation }) => {
  const dispatch = useDispatch();
  const { userId, username, level, xp, coins, status, lastDailyClaim } = useSelector((state) => state.user);
  const isLoading = status === 'loading';
  
  useEffect(() => {
    if (userId) {
      dispatch(fetchUserData(userId));
    }
  }, [dispatch, userId]);
  
  const onRefresh = () => {
    if (userId) {
      dispatch(fetchUserData(userId));
    }
  };
  
  const handleClaimDailyBonus = () => {
    if (userId) {
      dispatch(claimDailyBonus(userId));
    }
  };
  
  // Check if daily bonus is available
  const canClaimDaily = () => {
    if (!lastDailyClaim) return true;
    
    const lastClaim = new Date(lastDailyClaim);
    const now = new Date();
    
    // Check if last claim was more than 24 hours ago
    return (now - lastClaim) > (24 * 60 * 60 * 1000);
  };
  
  // Complete list of all certification options
  const allCertOptions = [
    // Main certifications
    { id: 'aplus',     name: 'A+ Core 1 (1101)',    color: '#6543CC', icon: 'desktop-outline',  primary: true,  screenName: 'APlusTests' },
    { id: 'aplus2',    name: 'A+ Core 2 (1102)',    color: '#1ABC9C', icon: 'desktop-outline',  primary: false, screenName: 'APlus2Tests' },
    { id: 'nplus',     name: 'Network+ (N10-009)',  color: '#FF4C8B', icon: 'wifi-outline',     primary: true,  screenName: 'NetworkPlusTests' },
    { id: 'secplus',   name: 'Security+ (SY0-701)', color: '#2ECC71', icon: 'shield-checkmark-outline', primary: true,  screenName: 'SecurityPlusTests' },
    { id: 'cysa',      name: 'CySA+ (CS0-003)',     color: '#3498DB', icon: 'analytics-outline', primary: true,  screenName: 'CySAPlusTests' },
    { id: 'penplus',   name: 'PenTest+ (PT0-003)',  color: '#E67E22', icon: 'bug-outline',       primary: true,  screenName: 'PenPlusTests' },
    { id: 'linuxplus', name: 'Linux+ (XK0-005)',    color: '#9B59B6', icon: 'terminal-outline',  primary: true,  screenName: 'LinuxPlusTests' },
    // Additional certifications
    { id: 'caspplus',  name: 'CASP+ (CAS-005)',     color: '#E74C3C', icon: 'shield-outline',    primary: false, screenName: 'CaspPlusTests' },
    { id: 'cloudplus', name: 'Cloud+ (CV0-004)',    color: '#3498DB', icon: 'cloud-outline',     primary: false, screenName: 'CloudPlusTests' },
    { id: 'dataplus',  name: 'Data+ (DA0-001)',     color: '#1ABC9C', icon: 'bar-chart-outline', primary: false, screenName: 'DataPlusTests' },
    { id: 'serverplus',name: 'Server+ (SK0-005)',   color: '#9B59B6', icon: 'server-outline',    primary: false, screenName: 'ServerPlusTests' },
    { id: 'cissp',     name: 'CISSP',               color: '#34495E', icon: 'lock-closed-outline',primary: false,screenName: 'CisspTests' },
    { id: 'awscloud',  name: 'AWS Cloud Practitioner', color: '#F39C12', icon: 'cloud-outline',   primary: false, screenName: 'AWSCloudTests' },
  ];
  
  // Filter for primary certifications
  const primaryCertOptions = allCertOptions.filter(cert => cert.primary);
  // Filter for secondary certifications
  const secondaryCertOptions = allCertOptions.filter(cert => !cert.primary);
  
  // This function navigates to the correct stack screen + passes category param
  const navigateToTests = (cert) => {
    // e.g., { id: 'aplus', screenName: 'APlusTests', name: 'A+ Core 1 (1101)' }
    navigation.navigate('Tests', {
      screen: cert.screenName,  // e.g. 'APlusTests'
      params: {
        category: cert.id,      // e.g. 'aplus'
        title: cert.name,
      },
    });
  };
  
  return (
    <ScrollView
      style={styles.container}
      refreshControl={
        <RefreshControl refreshing={isLoading} onRefresh={onRefresh} />
      }
    >
      <View style={styles.header}>
        <Text style={styles.welcomeText}>Welcome back, {username}!</Text>
        
        <View style={styles.statsContainer}>
          <View style={styles.statItem}>
            <Text style={styles.statValue}>Level {level}</Text>
            <View style={styles.statIconContainer}>
              <Ionicons name="trophy-outline" size={16} color="#6543CC" />
            </View>
          </View>
          
          <View style={styles.statItem}>
            <Text style={styles.statValue}>{xp} XP</Text>
            <View style={styles.statIconContainer}>
              <Ionicons name="flash-outline" size={16} color="#FF4C8B" />
            </View>
          </View>
          
          <View style={styles.statItem}>
            <Text style={styles.statValue}>{coins}</Text>
            <View style={styles.statIconContainer}>
              <Ionicons name="cash-outline" size={16} color="#2ECC71" />
            </View>
          </View>
        </View>
      </View>
      
      {/* Daily Bonus Card */}
      <TouchableOpacity
        style={styles.dailyBonusCard}
        onPress={() => navigation.navigate('DailyStation')}
      >
        <View style={styles.dailyBonusContent}>
          <Ionicons
            name={canClaimDaily() ? 'gift-outline' : 'calendar-outline'}
            size={24}
            color="#FFFFFF"
          />
          <View style={styles.dailyBonusTextContainer}>
            <Text style={styles.dailyBonusTitle}>
              {canClaimDaily() ? 'Daily Bonus Available!' : 'Daily Station'}
            </Text>
            <Text style={styles.dailyBonusSubtitle}>
              {canClaimDaily()
                ? 'Claim 250 coins and answer daily challenge'
                : 'Check daily challenge and return tomorrow for bonus'}
            </Text>
          </View>
        </View>
        <Ionicons name="chevron-forward" size={24} color="#FFFFFF" />
      </TouchableOpacity>
      
      {/* Newsletter Card */}
      <TouchableOpacity
        style={styles.newsletterCard}
        onPress={() => navigation.navigate('Newsletter')}
      >
        <View style={styles.newsletterContent}>
          <Ionicons name="newspaper-outline" size={24} color="#FFFFFF" />
          <View style={styles.newsletterTextContainer}>
            <Text style={styles.newsletterTitle}>Daily Cyber Brief</Text>
            <Text style={styles.newsletterSubtitle}>
              Subscribe to our cybersecurity newsletter
            </Text>
          </View>
        </View>
        <Ionicons name="chevron-forward" size={24} color="#FFFFFF" />
      </TouchableOpacity>
      
      {/* Primary certs */}
      <Text style={styles.sectionTitle}>Practice Tests</Text>
      <View style={styles.certGrid}>
        {primaryCertOptions.map((cert) => (
          <TouchableOpacity
            key={cert.id}
            style={[styles.certCard, { backgroundColor: cert.color }]}
            onPress={() => navigateToTests(cert)}
          >
            <Ionicons name={cert.icon} size={28} color="#FFFFFF" />
            <Text style={styles.certName}>{cert.name}</Text>
          </TouchableOpacity>
        ))}
      </View>
      
      {/* Secondary certs */}
      <Text style={styles.sectionTitle}>Other Practice Tests</Text>
      <View style={styles.certGrid}>
        {secondaryCertOptions.map((cert) => (
          <TouchableOpacity
            key={cert.id}
            style={[styles.certCard, { backgroundColor: cert.color }]}
            onPress={() => navigateToTests(cert)}
          >
            <Ionicons name={cert.icon} size={28} color="#FFFFFF" />
            <Text style={styles.certName}>{cert.name}</Text>
          </TouchableOpacity>
        ))}
      </View>
      
      <Text style={styles.sectionTitle}>Training Tools</Text>
      <View style={styles.toolsContainer}>
        <TouchableOpacity 
          style={styles.toolButton}
          onPress={() => navigation.navigate('AnalogyHub')}
        >
          <Ionicons name="bulb-outline" size={24} color="#FF4C8B" />
          <View style={styles.toolTextContainer}>
            <Text style={styles.toolTitle}>Analogy Hub</Text>
            <Text style={styles.toolSubtitle}>Learn complex concepts with analogies</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color="#AAAAAA" />
        </TouchableOpacity>
        
        <TouchableOpacity 
          style={styles.toolButton}
          onPress={() => navigation.navigate('Resources')}
        >
          <Ionicons name="library-outline" size={24} color="#9B59B6" />
          <View style={styles.toolTextContainer}>
            <Text style={styles.toolTitle}>Resources Hub</Text>
            <Text style={styles.toolSubtitle}>Learning resources and tools</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color="#AAAAAA" />
        </TouchableOpacity>
        
        <TouchableOpacity 
          style={styles.toolButton}
          onPress={() => navigation.navigate('ScenarioSphere')}
        >
          <Ionicons name="document-text-outline" size={24} color="#2ECC71" />
          <View style={styles.toolTextContainer}>
            <Text style={styles.toolTitle}>Scenario Sphere</Text>
            <Text style={styles.toolSubtitle}>Practice with real-world scenarios</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color="#AAAAAA" />
        </TouchableOpacity>
        
        <TouchableOpacity 
          style={styles.toolButton}
          onPress={() => navigation.navigate('GRC')}
        >
          <Ionicons name="shield-outline" size={24} color="#3498DB" />
          <View style={styles.toolTextContainer}>
            <Text style={styles.toolTitle}>GRC Questions</Text>
            <Text style={styles.toolSubtitle}>Governance, Risk & Compliance</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color="#AAAAAA" />
        </TouchableOpacity>
        
        <TouchableOpacity 
          style={styles.toolButton}
          onPress={() => navigation.navigate('XploitCraft')}
        >
          <Ionicons name="code-slash-outline" size={24} color="#E67E22" />
          <View style={styles.toolTextContainer}>
            <Text style={styles.toolTitle}>XploitCraft</Text>
            <Text style={styles.toolSubtitle}>Explore security exploit concepts</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color="#AAAAAA" />
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
};

export default HomeScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  header: {
    padding: 20,
    backgroundColor: '#1E1E1E',
  },
  welcomeText: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 20,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#2A2A2A',
    paddingHorizontal: 15,
    paddingVertical: 10,
    borderRadius: 8,
    minWidth: 100,
  },
  statValue: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginRight: 8,
  },
  statIconContainer: {
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  dailyBonusCard: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#6543CC',
    margin: 20,
    marginTop: 15,
    marginBottom: 10,
    padding: 15,
    borderRadius: 10,
  },
  dailyBonusContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  dailyBonusTextContainer: {
    marginLeft: 15,
  },
  dailyBonusTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  dailyBonusSubtitle: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.8)',
  },
  newsletterCard: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#FF4C8B',
    margin: 20,
    marginTop: 0,
    marginBottom: 20,
    padding: 15,
    borderRadius: 10,
  },
  newsletterContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  newsletterTextContainer: {
    marginLeft: 15,
  },
  newsletterTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  newsletterSubtitle: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.8)',
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#FFFFFF',
    margin: 20,
    marginBottom: 10,
  },
  certGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    padding: 10,
  },
  certCard: {
    width: '45%',
    height: 100,
    margin: '2.5%',
    borderRadius: 10,
    padding: 15,
    justifyContent: 'space-between',
  },
  certName: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginTop: 10,
  },
  toolsContainer: {
    padding: 10,
    paddingBottom: 30,
  },
  toolButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#2A2A2A',
    padding: 15,
    borderRadius: 8,
    marginBottom: 10,
  },
  toolTextContainer: {
    flex: 1,
    marginLeft: 15,
  },
  toolTitle: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  toolSubtitle: {
    color: '#AAAAAA',
    fontSize: 14,
  },
});
</file>

<file path="src/screens/LeaderboardScreen.js">
// src/screens/LeaderboardScreen.js
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
  RefreshControl,
  SafeAreaView,
  Platform
} from 'react-native';
import { useSelector } from 'react-redux';
import { Ionicons } from '@expo/vector-icons';
import { fetchLeaderboard } from '../api/leaderboardService';

const LeaderboardScreen = () => {
  const [leaderboardData, setLeaderboardData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  const [error, setError] = useState(null);
  
  const pageSize = 20;
  const { username } = useSelector((state) => state.user);
  
  const loadLeaderboard = useCallback(async (pageNum = 0, refresh = false) => {
    try {
      if (refresh) {
        setRefreshing(true);
        setPage(0);
        pageNum = 0;
      } else if (pageNum > 0) {
        setLoadingMore(true);
      }
      
      const skip = pageNum * pageSize;
      const data = await fetchLeaderboard(skip, pageSize);
      
      // Ensure we have data with proper structure
      const processedData = (data.data || []).map((item, idx) => ({
        ...item,
        rank: skip + idx + 1, // Ensure rank is calculated
      }));
      
      if (refresh || pageNum === 0) {
        setLeaderboardData(processedData);
      } else {
        setLeaderboardData(prevData => [...prevData, ...processedData]);
      }
      
      setHasMore(processedData.length === pageSize);
      setError(null);
    } catch (err) {
      setError('Failed to load leaderboard. Please try again.');
      console.error('Leaderboard error:', err);
    } finally {
      setLoading(false);
      setRefreshing(false);
      setLoadingMore(false);
    }
  }, [pageSize]);
  
  useEffect(() => {
    loadLeaderboard(0);
  }, [loadLeaderboard]);
  
  const onRefresh = () => {
    setRefreshing(true);
    loadLeaderboard(0, true).finally(() => {
      setRefreshing(false);
    });
  };
  
  const loadMoreData = () => {
    if (hasMore && !loadingMore && !refreshing) {
      const nextPage = page + 1;
      setPage(nextPage);
      loadLeaderboard(nextPage);
    }
  };
  
  const renderRankItem = ({ item, index }) => {
    const isCurrentUser = item.username === username;
    
    return (
      <View style={[
        styles.rankItem,
        isCurrentUser && styles.currentUserItem,
        index < 3 && styles.topRankItem
      ]}>
        <View style={styles.rankNumberContainer}>
          {index < 3 ? (
            <View style={[
              styles.topRankBadge,
              index === 0 && styles.goldBadge,
              index === 1 && styles.silverBadge,
              index === 2 && styles.bronzeBadge
            ]}>
              <Text style={styles.topRankText}>{item.rank || index + 1}</Text>
            </View>
          ) : (
            <Text style={styles.rankNumber}>{item.rank || index + 1}</Text>
          )}
        </View>
        
        {/* Avatar placeholder instead of trying to load images */}
        <View style={styles.placeholderAvatar}>
          <Text style={styles.avatarInitial}>
            {item.username?.charAt(0).toUpperCase() || '?'}
          </Text>
        </View>
        
        <View style={styles.userInfoContainer}>
          <Text style={[
            styles.username,
            isCurrentUser && styles.currentUsername
          ]}>
            {item.username}
            {isCurrentUser && (
              <Text style={styles.youText}> (You)</Text>
            )}
          </Text>
        </View>
        
        <View style={styles.statsContainer}>
          <View style={styles.levelContainer}>
            <Text style={styles.levelLabel}>Level</Text>
            <Text style={[styles.levelValue, isCurrentUser && styles.currentUserStats]}>
              {item.level}
            </Text>
          </View>
          
          <View style={styles.xpContainer}>
            <Text style={styles.xpLabel}>XP</Text>
            <Text style={[styles.xpValue, isCurrentUser && styles.currentUserStats]}>
              {item.xp?.toLocaleString() || '0'}
            </Text>
          </View>
        </View>
      </View>
    );
  };
  
  const renderFooter = () => {
    if (!loadingMore) return null;
    
    return (
      <View style={styles.footerContainer}>
        <ActivityIndicator size="small" color="#6543CC" />
        <Text style={styles.footerText}>Loading more...</Text>
      </View>
    );
  };
  
  const renderEmpty = () => {
    if (loading) return null;
    
    return (
      <View style={styles.emptyContainer}>
        <Ionicons name="trophy-outline" size={60} color="#AAAAAA" />
        <Text style={styles.emptyText}>
          {error || 'No leaderboard data available'}
        </Text>
        <TouchableOpacity style={styles.retryButton} onPress={onRefresh}>
          <Text style={styles.retryText}>Retry</Text>
        </TouchableOpacity>
      </View>
    );
  };
  
  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Leaderboard</Text>
        <Text style={styles.subtitle}>
          Top performers ranked by level and experience
        </Text>
      </View>
      
      {loading && !refreshing ? (
        <View style={styles.mainLoadingContainer}>
          <ActivityIndicator size="large" color="#6543CC" />
          <Text style={styles.loadingText}>Loading leaderboard...</Text>
        </View>
      ) : (
        <FlatList
          data={leaderboardData}
          renderItem={renderRankItem}
          keyExtractor={(item, index) => `${item._id || item.username}-${index}`}
          contentContainerStyle={styles.listContent}
          showsVerticalScrollIndicator={true}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={onRefresh}
              colors={['#6543CC']}
              tintColor="#6543CC"
            />
          }
          ListEmptyComponent={renderEmpty}
          ListFooterComponent={renderFooter}
          onEndReached={loadMoreData}
          onEndReachedThreshold={0.2}
        />
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#121212',
  },
  header: {
    padding: 20,
    paddingTop: 10,
    backgroundColor: '#1E1E1E',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 6,
  },
  subtitle: {
    fontSize: 16,
    color: '#AAAAAA',
  },
  listContent: {
    paddingHorizontal: 16,
    paddingBottom: 20,
    minHeight: 400, // Ensure content is scrollable
  },
  rankItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#1E1E1E',
    borderRadius: 12,
    padding: 12,
    marginVertical: 6,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  topRankItem: {
    ...Platform.select({
      ios: {
        shadowColor: '#FFD700',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.3,
        shadowRadius: 8,
      },
      android: {
        elevation: 4,
      },
    }),
  },
  currentUserItem: {
    backgroundColor: 'rgba(101, 67, 204, 0.12)',
    borderWidth: 1,
    borderColor: '#6543CC',
  },
  rankNumberContainer: {
    width: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
  rankNumber: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#AAAAAA',
  },
  topRankBadge: {
    width: 28,
    height: 28,
    borderRadius: 14,
    justifyContent: 'center',
    alignItems: 'center',
  },
  goldBadge: {
    backgroundColor: '#FFD700',
  },
  silverBadge: {
    backgroundColor: '#C0C0C0',
  },
  bronzeBadge: {
    backgroundColor: '#CD7F32',
  },
  topRankText: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#000000',
  },
  placeholderAvatar: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: '#2A2A2A',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  avatarInitial: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  userInfoContainer: {
    flex: 1,
    marginRight: 8,
  },
  username: {
    fontSize: 16,
    fontWeight: '500',
    color: '#FFFFFF',
  },
  currentUsername: {
    color: '#6543CC',
    fontWeight: 'bold',
  },
  youText: {
    fontWeight: 'normal',
    fontSize: 14,
    color: '#AAAAAA',
  },
  statsContainer: {
    flexDirection: 'row',
  },
  levelContainer: {
    alignItems: 'center',
    marginRight: 16,
  },
  levelLabel: {
    fontSize: 12,
    color: '#AAAAAA',
  },
  levelValue: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  xpContainer: {
    alignItems: 'center',
  },
  xpLabel: {
    fontSize: 12,
    color: '#AAAAAA',
  },
  xpValue: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  currentUserStats: {
    color: '#6543CC',
  },
  mainLoadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 10,
    color: '#AAAAAA',
    fontSize: 16,
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
    marginTop: 20,
  },
  emptyText: {
    fontSize: 16,
    color: '#AAAAAA',
    textAlign: 'center',
    marginTop: 10,
    marginBottom: 20,
  },
  retryButton: {
    backgroundColor: '#6543CC',
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  retryText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  footerContainer: {
    padding: 16,
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'row',
  },
  footerText: {
    color: '#AAAAAA',
    marginLeft: 8,
  }
});

export default LeaderboardScreen;
</file>

<file path="src/store/slices/achievementsSlice.js">
// src/store/slices/achievementsSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import achievementService from '../../api/achievementService';

export const fetchAchievements = createAsyncThunk(
  'achievements/fetchAchievements',
  async (_, { rejectWithValue }) => {
    try {
      const response = await achievementService.fetchAchievements();
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const achievementsSlice = createSlice({
  name: 'achievements',
  initialState: {
    all: [],
    status: 'idle',
    error: null
  },
  reducers: {
    // Any additional reducers needed
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchAchievements.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchAchievements.fulfilled, (state, action) => {
        state.all = action.payload;
        state.status = 'succeeded';
      })
      .addCase(fetchAchievements.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      });
  }
});

export default achievementsSlice.reducer;
</file>

<file path="src/store/slices/shopSlice.js">
// src/store/slices/shopSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import * as shopService from '../../api/shopService';

export const fetchShopItems = createAsyncThunk(
  'shop/fetchShopItems',
  async (_, { rejectWithValue }) => {
    try {
      const response = await shopService.getShopItems();
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const initialState = {
  items: [],
  status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'
  error: null,
};

const shopSlice = createSlice({
  name: 'shop',
  initialState,
  reducers: {
    // Any additional reducers needed
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchShopItems.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchShopItems.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.items = action.payload;
      })
      .addCase(fetchShopItems.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      });
  },
});

export default shopSlice.reducer;
</file>

<file path="src/store/slices/userSlice.js">
// src/store/slices/userSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import * as AuthService from '../../api/authService';
import * as SecureStore from 'expo-secure-store';

// Async thunks
export const loginUser = createAsyncThunk(
  'user/loginUser',
  async (credentials, { rejectWithValue }) => {
    try {
      const response = await AuthService.loginUser(credentials);
      return response;
    } catch (error) {
      return rejectWithValue(error.response?.data?.error || 'Login failed');
    }
  }
);

export const fetchUserData = createAsyncThunk(
  'user/fetchUserData',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await AuthService.fetchUserData(userId);
      return response;
    } catch (error) {
      return rejectWithValue(error.response?.data?.error || 'Failed to fetch user data');
    }
  }
);

export const claimDailyBonus = createAsyncThunk(
  'user/claimDailyBonus',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await AuthService.claimDailyBonus(userId);
      return response;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to claim daily bonus');
    }
  }
);

// Initial state
const initialState = {
  userId: null,
  username: '',
  email: '',
  xp: 0,
  level: 1,
  coins: 0,
  achievements: [],
  xpBoost: 1.0,
  currentAvatar: null,
  nameColor: null,
  purchasedItems: [],
  subscriptionActive: false,
  lastDailyClaim: null,
  
  // Status flags
  status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'
  error: null,
};

// Slice
const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    // Synchronous reducers
    setUser: (state, action) => {
      const userData = action.payload;
      state.userId = userData.user_id || userData._id;
      state.username = userData.username;
      state.email = userData.email || '';
      state.xp = userData.xp || 0;
      state.level = userData.level || 1;
      state.coins = userData.coins || 0;
      state.achievements = userData.achievements || [];
      state.xpBoost = userData.xpBoost || 1.0;
      state.currentAvatar = userData.currentAvatar;
      state.nameColor = userData.nameColor;
      state.purchasedItems = userData.purchasedItems || [];
      state.subscriptionActive = userData.subscriptionActive || false;
    },
    
    logout: (state) => {
      // Reset to initial state
      Object.assign(state, initialState);
      // Clear storage
      SecureStore.deleteItemAsync('userId');
    },
    
    updateCoins: (state, action) => {
      state.coins = action.payload;
    },
    
    updateXp: (state, action) => {
      state.xp = action.payload;
    },
    
    // Add this new reducer
    clearAuthErrors: (state) => {
      state.error = null;
      state.status = 'idle';
    }
  },
  extraReducers: (builder) => {
    builder
      // LOGIN
      .addCase(loginUser.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.userId = action.payload.user_id;
        state.username = action.payload.username;
        state.email = action.payload.email || '';
        state.coins = action.payload.coins || 0;
        state.xp = action.payload.xp || 0;
        state.level = action.payload.level || 1;
        state.achievements = action.payload.achievements || [];
        state.xpBoost = action.payload.xpBoost || 1.0;
        state.currentAvatar = action.payload.currentAvatar;
        state.nameColor = action.payload.nameColor;
        state.purchasedItems = action.payload.purchasedItems || [];
        state.subscriptionActive = action.payload.subscriptionActive || false;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      })
      
      // FETCH USER DATA
      .addCase(fetchUserData.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchUserData.fulfilled, (state, action) => {
        state.status = 'succeeded';
        const userData = action.payload;
        state.userId = userData._id;
        state.username = userData.username;
        state.email = userData.email || '';
        state.xp = userData.xp || 0;
        state.level = userData.level || 1;
        state.coins = userData.coins || 0;
        state.achievements = userData.achievements || [];
        state.xpBoost = userData.xpBoost || 1.0;
        state.currentAvatar = userData.currentAvatar;
        state.nameColor = userData.nameColor;
        state.purchasedItems = userData.purchasedItems || [];
        state.subscriptionActive = userData.subscriptionActive || false;
        state.lastDailyClaim = userData.lastDailyClaim;
      })
      .addCase(fetchUserData.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      })
      
      // DAILY BONUS
      .addCase(claimDailyBonus.fulfilled, (state, action) => {
        if (action.payload.success) {
          state.coins = action.payload.newCoins;
          state.xp = action.payload.newXP;
          state.lastDailyClaim = action.payload.newLastDailyClaim;
          
          // If there are newly unlocked achievements
          if (action.payload.newlyUnlocked && action.payload.newlyUnlocked.length > 0) {
            // Add the new achievements to the array if they don't already exist
            action.payload.newlyUnlocked.forEach(achievementId => {
              if (!state.achievements.includes(achievementId)) {
                state.achievements.push(achievementId);
              }
            });
          }
        }
      });
  },
});

// Export actions and reducer
export const { setUser, logout, updateCoins, updateXp, clearAuthErrors } = userSlice.actions;
export default userSlice.reducer;
</file>

<file path="src/store/index.js">
// src/store/index.js
import { configureStore } from '@reduxjs/toolkit';
import userReducer from './slices/userSlice';
import shopReducer from './slices/shopSlice';
import achievementsReducer from './slices/achievementsSlice';
// Import other reducers as you create them
// import testReducer from './slices/testSlice';
// import achievementsReducer from './slices/achievementsSlice';

export const store = configureStore({
  reducer: {
    user: userReducer,
    shop: shopReducer,
    achievements: achievementsReducer
    // Add other reducers here
    // tests: testReducer,
    // achievements: achievementsReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // Ignore these paths in the Redux state
        ignoredActions: ['user/fetchUserData/fulfilled'],
        ignoredPaths: ['user.lastDailyClaim'],
      },
    }),
});

export default store;
</file>

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo
</file>

<file path="App.js">
// App.js
import React, { useEffect } from 'react';
import { StatusBar } from 'react-native';
import { Provider } from 'react-redux';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import store from './src/store';
import AppNavigator from './src/navigation/AppNavigator';

export default function App() {
  return (
    <Provider store={store}>
      <SafeAreaProvider>
        <StatusBar barStyle="light-content" backgroundColor="#121212" />
        <AppNavigator />
      </SafeAreaProvider>
    </Provider>
  );
}
</file>

<file path="app.json">
{
  "expo": {
    "name": "CertGamesApp",
    "slug": "CertGamesApp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "scheme": "certgamesapp",
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      }
    },
    "web": {
      "favicon": "./assets/favicon.png"
    }
  }
}
</file>

<file path="index.js">
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);
</file>

<file path="package.json">
{
  "name": "certgamesapp",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-community/netinfo": "^11.4.1",
    "@react-native-picker/picker": "2.9.0",
    "@react-navigation/bottom-tabs": "^7.2.1",
    "@react-navigation/drawer": "^7.1.2",
    "@react-navigation/native": "^7.0.15",
    "@react-navigation/stack": "^7.1.2",
    "@reduxjs/toolkit": "^2.6.1",
    "axios": "^1.8.3",
    "expo": "~52.0.38",
    "expo-apple-authentication": "~7.1.3",
    "expo-clipboard": "~7.0.1",
    "expo-constants": "~17.0.8",
    "expo-linear-gradient": "~14.0.2",
    "expo-linking": "~7.0.5",
    "expo-local-authentication": "~15.0.2",
    "expo-secure-store": "^14.0.1",
    "expo-splash-screen": "^0.29.22",
    "expo-status-bar": "~2.0.1",
    "expo-web-browser": "~14.0.2",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-gesture-handler": "^2.24.0",
    "react-native-reanimated": "^3.17.1",
    "react-native-toast-notifications": "^3.4.0",
    "react-redux": "^9.2.0",
    "redux": "^5.0.1",
    "socket.io-client": "^4.8.1",
    "@react-native-community/slider": "4.5.5"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0"
  },
  "private": true
}
</file>

</files>
